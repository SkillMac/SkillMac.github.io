[{"title":"linux升级gcc","date":"2018-05-09T01:37:30.000Z","path":"/posts/f62a7c7d/","text":"这一篇是对linux centos7 中 gcc 的升级.这次升级gcc的版本是 8.1.0 方法一12345678910111213141516171819$ su \\\\进入 root# sudo yum install libmpc-devel mpfr-devel gmp-devel...# cd 下载# curl ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/* \\\\* 号为自己想要更新的版本号\\\\ 做法是自己将这个 地址放到浏览器中自己去选取合适的版本直接下载.\\\\ 我这里下载的是 8.1.0 # tar zxfv gcc-8.1.0.tar.gz# cd gcc-8.1.0# ./configure --disable-multilib --enable-languages=c,c++# make -j 4...# make install...# gcc -v...线程模式:posixgcc 版本 8.1.0(GCC)\\\\ ... 意思省略 方法二在 etc/yum.repos.d下面添加repo1touch FedoraRepo.repo 然后添加下面的内容: 123456[warning:fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=https://getfedora.org/static/34EC9CBA.txt 然后更新gcc 1yum -y update gcc gcc-c++ 然后就是新版本了但是这我还不太懂.所以就没有用这个方法. 我用的是方法一.因为方法一可以自己选择gcc版本,并不是所有的东西都要更新到最新的版本,当然这个根据你们自己了.根据情况而定. 方法二更简单一点. 好了今天就先到这了.","tags":[{"name":"gcc","slug":"gcc","permalink":"https://leng521.top/tags/gcc/"}]},{"title":"9宫格纹理的更新问题","date":"2018-04-26T01:40:53.000Z","path":"/posts/1e09c0f5/","text":"这一篇文章主要是讲解一下 cocos2dx 9宫格纹理更新问题我这里就不说 cocos2dx 9宫格怎么使用了。在网上一搜一大堆。基本内容都是那样。我不想做无谓的叙述了。 问题描述现在的环境是： cocos2dx 3.15 VS 2015 使用 lua 写项目 注意这里是说使用 plist 里面的纹理 也就是精灵帧 现在面临的问题是: cocos2dx 对9宫格纹理更新，不能像更新精灵那样使用它提供的函数 setSpriteFrame虽然9宫格就是对精灵的在次封装。 cocos2dx 九宫格的这个函数（setSpriteFrame）在C++定义的头文件中是长这样的 123// UIScale9Sprite.hvirtual void setSpriteFrame(SpriteFrame * spriteFrame, const Rect&amp; capInsets);//它没有提供直接输入字符串来实现纹理的更换. 这说明我们需要一个精灵帧类型，但是这个类型我用了这么时间，基本没用过。 问题剖析我上面有说过九宫格是对纹理的再次封装实现的，说以就去查看他的父类Sprite.h这个是怎么初始化的。 追了 它父类的初始化函数 Sprite.h 看到了它是怎么创建出精灵帧的，下面是他初始化它内部的精灵帧的操作。12345678910111213141516void Sprite::setSpriteFrame(const std::string &amp;spriteFrameName)&#123; CCASSERT(!spriteFrameName.empty(), \"spriteFrameName must not be empty\"); if (spriteFrameName.empty()) &#123; return; &#125; SpriteFrameCache *cache = SpriteFrameCache::getInstance(); // 根据名字在精灵帧缓存中查找相应的精灵帧。 SpriteFrame *spriteFrame = cache-&gt;getSpriteFrameByName(spriteFrameName); CCASSERT(spriteFrame, std::string(\"Invalid spriteFrameName :\").append(spriteFrameName).c_str()); // 设置自己内部的精灵帧对象 setSpriteFrame(spriteFrame);&#125; 原理是在精灵帧缓存中查找对象设置精灵的精灵帧 代码实现这下就好办了。 lua层的代码就是 12345local spriteFrameCache = cc.SpriteFrameCache:getInstance()local frame = spriteFrameCache:getSpriteFrame(\"xxx.png\")-- xxx.png 就是你 plist文件中对应的文件名字。-- 这个就是我们需要的精灵帧对象-- 然后在调用它的 setSpriteFrame 具体的实现代码lua层的c++层我就不说了。暂时没有用到。做法都一样。上面的实现在 cocos2dx display的lua文件里面有实现。所以就直接调用。1234567891011121314151617181920212223242526-- desc: 创建9宫格图片-- params [ path | pos | capInsets | size | rect ]-- params.path 可以是精灵帧 ej: params.path = \"#xxx.png\"-- params.pos 精灵的位置-- params.capInsets 是9宫格中间 Rect 的位置和大小-- params.rect 可以不用填function T.cp_s9( parentNode, params ) local pos = params.pos local s = display.newSprite(params.path,pos.x,pos.y,params) local _ = parentNode and parentNode:addChild(s) return send-- desc: 9宫格图片纹理的更新-- path 无效添加报错机制function T.update_s9( node, path, capInsets, size ) if string.byte(path) == 35 then local sp = display.newSpriteFrame(path) node:setSpriteFrame(sp,capInsets) else if not cc.FileUtils:getInstance():isFileExist(path) then error(string.format(\"invalid path , file isn't exist , path - %s\",path)) end node:setTexture(path) end node:setContentSize(size)end 需要注意的一点就是在九宫格更新纹理后尺寸又变回原来的大小，你需要重新设置大小。","tags":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"https://leng521.top/tags/cocos2dx/"},{"name":"9宫格","slug":"9宫格","permalink":"https://leng521.top/tags/9宫格/"}]},{"title":"python-闭包问题","date":"2018-04-20T02:31:51.000Z","path":"/posts/87435431/","text":"本文主要是python闭包问题的记录。python 实现的有内部函数，那么自然就会使用内部函数外面的变量 。 注意这里是要改变局部变量 可以使用下面的策略，如果只是简单的引用，可以直接引用 不用使用 nonlocal 关键字 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-def A(): xxx = 0 def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment nonlocal xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3 这里主要是使用了python 内部的关键字 nonlocal主要是引用内部函数以外的局部变量 注意这里不是全局变量。 注意这个关键字是python3.x 中可以出现的关键字。在python2.x中会报错。在python2.x的版本中可以使用 list 封装一层，实现使用内部函数以外的局部变量。这里不能使用 元祖 因为元祖的变量时不可变的。 如果要引用全局变量要是用python的另外一个关键字 global。用法和上面相同。 使用例子如下： 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-xxx = 0def A(): def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment global xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"https://leng521.top/tags/闭包/"}]},{"title":"记录使用hexo写博客的问题","date":"2018-04-14T08:17:16.000Z","path":"/posts/a9ff66a6/","text":"在使用 hexo 总会遇到这种那种的错误我这里就记录一下,希望后面使用 hexo 写博客的人能少遇到一点麻烦，少走一点弯路，OK，废话不多说。 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false. 2. hexo skip_render 的使用123skip_render: - 'dir/**' # 忽略dir这目录下的所有文件，不进行渲染 - 'xx/**' # 道理同上。 3. 修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 `hexo clean`,每次记得使用这个命令清除一下","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"}]},{"title":"python_optionparser模块","date":"2018-04-11T08:01:20.000Z","path":"/posts/ce1d3b12/","text":"本文主要是 python 对命令行的处理模块 就象是这样的","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"optionParser","slug":"optionParser","permalink":"https://leng521.top/tags/optionParser/"}]},{"title":"优化cocos2dxSpine库","date":"2018-01-22T12:44:31.000Z","path":"/posts/c4c0a180/","text":"对cocos2dxSpine库的升级和优化本文的大纲1.升级spine在cocos2dx-3.15的运行时库2.优化spine在创建的时候效率 在开发的时候出现的问题1.spine这个软件导出3.6新加的特效在cocos2dx3.15 不能使用2.spine在批量创建的时候帧数会下降 升级spine -&gt;3.6spine code github 地址去这个地址clone或者是下载Zip这个你随便然后会产现这个目录主要就是我使用箭头标记的这两个目录 spine-c/spine-c/include/spine/*.h spine-c/spine-c/src/spine/*.c spine-cocos2dx/src/spine/*.cpp and spine-cocos2dx/src/spine/*.h 找到自己的工程的根目录 然后去找这个目录全部放在 ···/frameworks/cocos2d-x/cocos/editor-support/spine 直接全部替换然后打开自己的VS去编译记住一点将你添加的C或C++的文件给添加到libSpine的工程中的源文件中 选中 Source Files 执行 Shift + Alt + A 添加现有项 或者是鼠标右键添加好可以 然后编译,你会惊奇的发现编译成功了,但是不要高兴的太早了,因为这个在编译Android的时候会报错,当然原因也很简单，接着往下面看。 在Android中的实现你找到 这个目录里面会有 ···/frameworks/cocos2d-x/cocos/editor-support/spineAndroid.mk的文件将你添加的写在这个配置里面 注意只写 *.h 的文件然后使用 Android Studio 编译 Apk, 这里你也可以使用NDK编译,但是在Android2.？这个不记得了,就已经不在支持NDK编译了所以还是使用Android Studio 吧 在 ios 中的实现也是同样如此，这里就不再讲述了 优化spine在创建的时候效率在原先的 spine 创建的时候每次都需要解析数据,生成骷髅数据,其实这个是很消耗CPU的,导致FPS下降。我的做法是保留 spine create 的原有接口,自己再从新写一个新的接口。原理：创建字典保留骷髅数据每次创建的时候询问这个 Map 是否存在 key 没有创建,有直接使用。 代码的写法有很多种,我这只是参考 在SkeletonAnimation.cpp 中添加如下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798SkeletonAnimation* SkeletonAnimation::createFromCache(const std::string&amp; key_skeletonData)&#123; if (spSkeletonData* skeleton_data = SkeletonAnimation::getSkeletonDataFromCache(key_skeletonData)) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; else &#123; skeleton_data = SkeletonAnimation::loadSkeletonDataToCache(key_skeletonData, key_skeletonData + \".json\", key_skeletonData + \".atlas\"); if (skeleton_data) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it == _allSkeletonDataCache.end()) &#123; SkeletonDataInCache skeleton_data_in_cache; spAtlas* atlas = nullptr; spAttachmentLoader* attachmentLoader = nullptr; skeleton_data_in_cache._skeleton_data = nullptr; atlas = spAtlas_createFromFile(atlasFile.c_str(), 0); CCASSERT(atlas, \"loadSkeletonDataToCache Error atlas file.\"); attachmentLoader = SUPER(Cocos2dAttachmentLoader_create(atlas)); spSkeletonJson* json = spSkeletonJson_createWithLoader(attachmentLoader); json-&gt;scale = scale; skeleton_data_in_cache._skeleton_data = spSkeletonJson_readSkeletonDataFile(json, skeletonJsonFile.c_str()); CCASSERT(skeleton_data_in_cache._skeleton_data, json-&gt;error ? json-&gt;error : \"loadSkeletonDataToCache Error reading skeleton data file.\"); spSkeletonJson_dispose(json); spAtlas_dispose(atlas); if (skeleton_data_in_cache._skeleton_data) &#123; _allSkeletonDataCache[key_skeletonData] = skeleton_data_in_cache; return skeleton_data_in_cache._skeleton_data; &#125; else &#123; //error release if (skeleton_data_in_cache._skeleton_data) &#123; spSkeletonData_dispose(skeleton_data_in_cache._skeleton_data); &#125; &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::getSkeletonDataFromCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return it-&gt;second._skeleton_data; &#125; return nullptr;&#125;bool SkeletonAnimation::removeSkeletonData(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); _allSkeletonDataCache.erase(it); return true; &#125; return false;&#125;void SkeletonAnimation::removeAllSkeletonData()&#123; for (iteratorSkeletonData it = _allSkeletonDataCache.begin(); it != _allSkeletonDataCache.end(); ++it) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); &#125; _allSkeletonDataCache.clear();&#125;bool SkeletonAnimation::isExistSkeletonDataInCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return true; &#125; return false;&#125;//endstd::map&lt;std::string, SkeletonAnimation::SkeletonDataInCache&gt; SkeletonAnimation::_allSkeletonDataCache; 在 SkeletonAnimation.h 中添加如下代码1234567891011121314static SkeletonAnimation* createFromCache(const std::string&amp; key_skeletonData);static spSkeletonData* loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale = 1);static spSkeletonData* getSkeletonDataFromCache(const std::string&amp; key_skeletonData);static bool removeSkeletonData(const std::string&amp; key_skeletonData);static void removeAllSkeletonData();static bool isExistSkeletonDataInCache(const std::string&amp; skeletonDataKeyName);private: struct SkeletonDataInCache &#123; spSkeletonData* _skeleton_data; &#125;; typedef std::map&lt;std::string, SkeletonDataInCache&gt;::iterator iteratorSkeletonData; static std::map&lt;std::string, SkeletonDataInCache&gt; _allSkeletonDataCache; //end Binding to lua既然写了这么多了,就要将这些代码绑定到lua中去 找到自己工程的的libluacocos2d的工程这里你可以自己写代码在 lua_cocos2dx_spine_auto.cpp 中,但是这不是一个程序员应该做的。第二种做是:既然它的文件名有 auto 这个单词,一看就不是人写出来的,OK,去寻找答案。 到这个目录中去 ···/frameworks/cocos2d-x/tools/tolua/ 你会发现有一个genbindings.py的文件你一运行可能报错,你去读他的 README.md ,发现他要你装一些python的库,那就按照说的安装吧你可以 pip 命令也可以 自己下载zip 这个随意。然后就是配置NDK,这个下载解压,配置 path 就完了,我就不多说了。 然后你运行可能还会报错 那就打开 genbindings.py 你会发现他需要的是NDK 3.3-3.4 然而自己的NDK经过查看 是 3.5-3.6 没关系,把它这个所有相关 3.3 3.4 全部改成 3.5-3.6的就OK了。 改完后运行 Prefect ^-^. 在lua中调用123456sp.SkeletonAnimation: createFromCache(key)sp.SkeletonAnimation: isExistSkeletonDataInCache(key)sp.SkeletonAnimation: loadSkeletonDataToCache(key,jsonFilePath,atlasFilePath,scale =1) sp.SkeletonAnimation: getSkeletonDataFromCache(key)sp.SkeletonAnimation: removeSkeletonData(key)sp.SkeletonAnimation: removeAllSkeletonData() 这里面有一个问题是你会发现返回的骨胳数据拿不到,这个是cocos2dx在绑定的时候并没有将这个数据类型绑定lua去,我上面那么写就是为了以后留个接口,当然你也可以自己把那个返回值去掉。 好了今天就到这吧。","tags":[{"name":"spine","slug":"spine","permalink":"https://leng521.top/tags/spine/"}]},{"title":"Using-Hexo","date":"2018-01-17T12:07:49.000Z","path":"/posts/6743743b/","text":"这篇文章只是我对 hexo 的一些功能的测试吧，可能后会常用到这些东西 Requirementsinstall Hexo123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David Levithan-Wide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 12alert(&apos;Hello World!&apos;);print(&apos;Hello World!&apos;) language -&gt; OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; language -&gt; python1print('Hello World!') 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块[language] [title] [url] [link text] code snippet language - &gt;OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; 插入Image图片12&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% asset_img fileName.* title&#125; /posts/6743743b/test.lua test.lua 引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 使用iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"},{"name":"IT","slug":"IT","permalink":"https://leng521.top/tags/IT/"}]},{"title":"Hello World","date":"2018-01-17T02:22:30.454Z","path":"/posts/4a17b156/","text":"搭建自己的博客在github page经过2天的折腾的终于把自己的博客给搭建出来了,也可以说是自己的一个Hello World 吧这个主题是使用Litten的theme通过hexo搭建 准备环境* install git * install node * 注册github的账号 Git Downloadnodejs Downloadgithub 注册的地址 再创建之前思考一个事情就是在你做完这些之后，你开始写自己的博客的时候，突然之间要换电脑了，这个时候你要怎么办这个思考是对于那些使用过 github 或者是使用过别的版本控制的工具。 Build to blog安装 nodejs 很简单,就是傻瓜式的安装。 在安装 git 的时候也是一键式安装。 然后自己注册github的账号。 记得配置自己的 nodejs的Path 在 cmd 窗口 输入 path path 我自己的 nodejs 在E盘 同样看看自己的 git 的 path 有没有配置 然后就是验证你的安装是否正确打开你 cmd 输入 git git 输入 node -v node -v github 就不用验证了吧 然后就是利用 node 的 npm 工具去安装 hexo 输入 npm install -g hexo-cli 如果自己的 hexo 安装成功的话 在 cmd 中 输入 hexo -v hexo -v 创建自己的 hexo 工程假设自己的 hexo 的工程目录是在 D:\\Pro\\pro_wdh\\nodejs 1. 在 cmd 中 输入 pushd D:\\Pro\\pro_wdh\\nodejs 2. cmd的当前目录直接跳转到 D:\\Pro\\pro_wdh\\nodejs 3. 使用 hexo init 命令 初始化 （）hexo init [folderName] ） hexo init hexocd hexonmp install 完成之后目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 运行自己的hexo工程在 cmd 中 输入 hexo s 在自己的浏览器中打开 http://localhost:4000/. 这时你会看到自己的静态网页 更多的 hexo的命令hexo 的官网 部署自己的笔记2github网上的一些教程都是 使用 SSH 去上传自己的博客但是使用 htpp 的方式也同样可以 上传 创建自己的 github 的仓库 上面的仓库名字就和你 github 的名字一样就行了 然后就是在 hexo 的根目录下的 _config.yml 中 找到 按照图片上的配置自己的 github 仓库的地址github 仓库的地址在这里拿 然后执行 hexo的命令 在cmd中输入 1.hexo clean 2.hexo g 3.hexo d 静静的等待 上传完成之后 打开 http://Test.github.io 就可以看到自己的博客了 回答上面的提出的思考答案就是 在 github 上创建自己的 branch(分支) 我是在自己的 github 创建自己的 blog(分支) git 的一些命令 不是太全,但是应对日常还是可以的 做法如下： git chcekout -b blog git add -A git commit - m &quot;commit my blog&quot; git push origin blog 解释一下吧 创建新的分支 blog添加自己的文件到缓存区提交到本地版本库推送到远端 更多 git 的知识 这只是一些基础 更多需要你多去尝试,多自己动手。 有疑问可以加QQ一起讨论","tags":[{"name":"hello world","slug":"hello-world","permalink":"https://leng521.top/tags/hello-world/"},{"name":"github page","slug":"github-page","permalink":"https://leng521.top/tags/github-page/"},{"name":"博客","slug":"博客","permalink":"https://leng521.top/tags/博客/"}]}]