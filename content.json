<<<<<<< HEAD
[{"title":"微信小游戏开发记录","date":"2018-06-30T12:22:01.000Z","path":"/posts/777fe656/","text":"刚换个新工作,是做微信小游戏的.已经好长时间没有写一些东西了,今天就在这总结一下我这个月的做的事吧,我也是刚使用 cocos creator 时间不长,以前一直用的是 cocos2dx-lua ,写的不好请多多指教,好了废话不多说. 本片文章主要是对微信小游戏开发和总结.引擎: cocos creator发布平台: 微信小游戏(微信sdk ver:2.1.1) 本文大纲 - 使用 `cocos creator` 引擎发布到微信上 - 记录调用微信 API 的记录 - 微信排行榜实现(开放数据域的使用) - 在开发过程中遇到的问题 发布这里首先要准备的东西是: - appid - 你的游戏工程 - 微信开发工具 appid:是你注册微信小程序公众号时候能够得到的,这个是你发布的时候要用的东西,当然你也可以使用 cocos creator 提供的默认的账号,(使用这个账号的弊端是你项目相关人员没办法测试,只有你的微信账号可以做测试)微信团队注册和接入微信小游戏的教程在这里注册你的微信公众号账号 微信公众平台在这里选择小程序进行注册,然后按照流程进行注册,你可以是个体,也可以是以企业身份进行注册,(个人注册在后期发布上线的时候要做的事情比较少,企业注册就需要东西比个人多两样,后面详细介绍.) 一般这些东西注册比较简单,这里就仔细叙述了,如果你是管理员的话,你可微信扫码直接登录,如果不是可以让管理员给你直接加一下权限. 你需要配置的信息如下: 这里要注意的就是我第二张图里面指向的地方, 这些你都填写完毕后就可以拿到 appid 了,有了这个id后你可以给其他的项目相关测试人员在微信后台添加 成员并给他们相应的权限,这样他们也可以进行测试你现在开发的小游戏了. 然后在 cocos creator 引擎中去填写, 我这里指向了几个地方,这里你们要是明白的话就更好,要是不明白,先这样做,我只是不想要这篇文章篇幅过长. 至于下面的 开放数据域, 服务器地址, 现在可以先不配置, 到后面我会去介绍的. 在这里再说一下,在点击运行的时候需要先配置,微信开发工具,微信开发工具 download 那里面有配置的完整路径.^-^ 然后引擎会在构建完成之后,点击运行,微信开发者工具启动后,点击预览会生成一个二维码,然后在微信后台,成员管理里面的成员只要有测试权限的都可以通过这个二维码进行游戏测试. 好了到这里你就发布成功了. 这个是 cocos creator 官方团队提供发布微信小游戏的教程如果运行出现错误可以到这里看看有没有微信小游戏问题总汇 微信小游戏API微信小游戏API微信小游戏文档 这里只是演示 cocos creator 是怎么调用微信小游戏的 api,复杂的调用我就先不说了. 123456789101112131415161718192021function test(argument) &#123; // CC_WECHATGAME 这个是 creator 全局宏用来判断是否在微信小游戏环境下 if(CC_WECHATGAME)&#123; wx.login(&#123; success: ()=&gt; &#123; // 调用成功后回调 wx.getUserInfo(&#123; success: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: ()=&gt; &#123; // 调用失败后回调 &#125;, complete: ()=&gt; &#123; // 成功失败都会调用 &#125; &#125;); &#125;&#125; 微信开放数据域微信的开放数据域要求,解释起来比较复杂,我先给你提供微信官方的解释,和creator 团队做出的解释和例子.微信的解释creator 的解释 相信你看完这两个解释,会有一些概念了,这里我就开始直接上代码,这个是最直接. 这个是主域渲染的代码sharedCanvas 是微信提供的全局变量,在微信环境下有用,当然这个是有开放数据域的工程后才行. 123456789101112131415161718192021222324252627cc.Class(&#123; extends: cc.Component, properties: &#123; rankView: cc.Sprite, &#125;, onLoad() &#123; if (CC_WECHATGAME) &#123; this.tex = new cc.Texture2D() window.sharedCanvas.width = 720 window.sharedCanvas.height = 1280 &#125; &#125;, update() &#123; this._updateSubDomainCanvas() &#125;, // 刷新子域的纹理 _updateSubDomainCanvas() &#123; if (CC_WECHATGAME) &#123; if (window.sharedCanvas != undefined) &#123; this.tex.initWithElement(window.sharedCanvas) this.tex.handleLoadedTexture() this.rankView.spriteFrame = new cc.SpriteFrame(this.tex) &#125; &#125; &#125;,&#125;); 发送发送数据的代码 1234567891011121314151617181920212223242526272829303132// 这个是上传分数的一段代码/** @param score_ 要上传的分数*/uploadScore(score_)&#123; if(!this.checkIsWeChat()) &#123;return;&#125; GameTools.sendMessage(&#123; type: GameTools.msgType.submitScore, scoreData: &#123; key: cc.TB.GAME.weChatData.keyList[0], score: score_, &#125;, &#125;);&#125;// 这类型和开放数据域那里的类型保持一致就行了.msgType: &#123; clear: 0, updateRank: 1, submitScore: 2, updateSelfRank: 3, groupShare: 4,&#125;,// 这个是调用微信的API 给开放数据域发送数据的 APIsendMessage(data) &#123; if(CC_WECHATGAME) &#123; console.log('send sub content data'); let content = window.wx.getOpenDataContext(); content.postMessage(data); &#125;&#125;, 开放数据域的代码 这里我直接放一个文件的链接,我就不接去部分代码了,你可以直接修改然后自己使用. 开放数据域代码 openContentData.txt 这里在你发布开放数据域的工程的时候 好了开放数据域 介绍结束 ^-^ 问题记录1.游戏包体超过4M 1.将你的资源放置服务器,在微信开放平台后端配置你的服务器地址,这里注意微信是不支持直接填写ip,而且还必须是https协议. 2.最近微信出现个分包加载机制,也可以突破微信不能超过4M的机制,这个我还没有实际实现过就先不写做法了, 2.微信小游戏分享传参问题 1234567891011121314151617181920212223242526272829303132333435 wx.shareAppMessage(&#123; title: '跟我一起玩', query: 'invite=1&amp;wc=2', imageUrl: address + 'share.jpg', success: (res) =&gt; &#123; console.log('分享 成功 ', res); if (res.shareTickets != undefined &amp;&amp; res.shareTickets.length &gt; 0) &#123; &#125; &#125;&#125;);// 这里主要是利用 query 这个字段进行参数传递// **********************************************// 启动let option = wx.getLaunchOptionsSync();console.log('小游戏启动',option);if(option.shareTicket != undefined) &#123; cc.TB.GAME.weChatData.shareTicket = option.shareTicket; this.onGroupShareFunc();&#125;// 由后台切换到前台是调用的函数wx.onShow((res)=&gt;&#123; // shareTicket console.log('切换到前台',res); if(res.shareTicket)&#123; cc.TB.GAME.weChatData.shareTicket = res.shareTicket; // 显示群排行 this.onGroupShareFunc(); &#125;&#125;);// 在这里 这个函数的返回值里 wx.getLaunchOptionsSync();// 和 这个函数 wx.onShow() 回调里面会有刚才传进来的参数 微信分享主要是利用 query 字段,这个字段类型是 string 只要按照这个格式就可以在在通过分享的链接进入游戏是获取相应参数的值. 好了,今天就先到这里了.","tags":[{"name":"cocos creator","slug":"cocos-creator","permalink":"https://leng521.top/tags/cocos-creator/"},{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"}]},{"title":"解决运行exe时缺少dll问题","date":"2018-05-23T09:01:51.000Z","path":"/posts/8e17853e/","text":"今天主要是解决如果你使用 cocos2dx 做的游戏(exe) 要放到别人的电脑上运行问题,在有些时候你可能会将自己的exe放到别人的电脑上,但是不幸的是,运行不了,提示说找不到*.dll. 解决思路1.你可能会直接去百度上下载一堆dll但是发现没什么用,还是会报错.那就看来这个思路是行不通的,换一个思路就是你去思考你的电脑比他电脑多了什么东西,其实也就是多了cocos2dx的运行框架,多了个VS.那既然我们已经将cocos2dx编译出来的和锁依赖的dll已经全部放在他的电脑上了,那就剩下个VS,这下目标很清晰喽,直接从VS下手,事实证明这是对的. 解决方案1.去找VS的dll存放的地方,我这里就不找,直接利用电脑管家去全局搜索某个文件,如下图 2.将你缺少的dll全部放在对方这个路径下C:\\Windows\\SysWOW64 Note:当然这里你怕放在这里影响其他的应用的话你也可以不放在,直接放在和你要运行的exe同级目录下就行.我这里只是为了解决多人时出现的问题. 3.copy你通过VS编译出来的exe和它所依赖的dll文件,具体目录在~/simulator/win32/*~代表你项目的根目录,然后将你项目根目录下的src和res文件夹拷贝到他的电脑上,其实就是将win32目录下的src和res给删除,将你项目根目录下的src和res放进去,为了只是保证资源和代码是最新的. 4.如果有人动了c++代码的话,你如果不是太了解C++中dll是干啥的就直接将自己~/simulator/win32/*.dll这个目录下的dll再重新覆盖一下. 好了就先到这里了.","tags":[{"name":"缺少dll","slug":"缺少dll","permalink":"https://leng521.top/tags/缺少dll/"}]},{"title":"给sublime写自定义的插件","date":"2018-05-10T06:17:48.000Z","path":"/posts/b1de475b/","text":"以前总是在sublime中装各种插件,去实现某种便捷,如装一个 git 插件可以直接快速的去查看当前打开的文件与远端的这个文件的差异.但是这些插件总是满足不了你的欲望,有的时候在有一些奇葩的需求,可能没有现有的插件可用,这个时候就要自己去写插件了.首先Sublime是支持自定义插件的,其次是Sublime的插件是采用python的语法,所以你要在写插件之前至少要了解python语法.不然就望而生畏了. 第一步 创建python脚本文件直接打开 Sublime 在最上面工具栏中 找到 Tools/Developer/New Plugin 点击完成之后会有一个内容类似下面的未保存文件1234567import sublimeimport sublime_pluginclass ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, \"Hello, World!\") 关于 sublime 这两个包的 API可以去 SublimeAPI 可能需要翻墙,我只是翻墙之后快了许多. 第二步 填充自己的python文件并保存到相应位置 打开上面所指向的目录自己新建一个文件夹,和你那个User目录同级就行了.列如我建立一个PythonHead 的目录如下: 里面有个 head.py 的python文件,具体内容如下 123456789101112import sublimeimport sublime_pluginimport datetimestr_head = \"\"\"#!usr/bin/env python2#-*- coding: utf-8 -*-#data:%s\\n\"\"\"class PyHeadCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0,str_head % (datetime.datetime.now().strftime(\"%y-%m-%d %H:%m:%s\"))) 这个自定义的功能主要是给自己python文件定义加了一些通用的注释而已.样子就如下面这样 这一写完之后你可以直接打开 Sublime 的命令行 快捷键 ctrl+` 如果快捷键冲突可以直接 View/Show Console 这个也可以 直接在这里面输入如下代码 就会向上面显示的那样. 当然这样肯定是不行的因为这个效率太低下,这里我们直接使用快捷键 第三步 绑定快捷键在上面的那个PyHead的文件夹下面有个 Default (Windows).sublime-keymap 它这个分了一些平台 如 Default (OSX).sublime-keymap Default (Linux).sublime-keymap这样的文件夹,这个是你绑定快捷键到你这个 功能上面.里面的内容如下(使用json的数据格式): 123[ &#123;\"keys\": [\"ctrl+alt+h\"], \"command\": \"py_head\"&#125;] 如果不熟悉json的话可以自己去补一下. 前面这个定义快捷键,后面是你要调用的函数,这里你可能有疑问了,为啥定义是PyHeadCommand 这个名字 却写个这,那是因为在Sublime中 函数的绑定都是小写, 如果你是大写就像上面那样驼峰式命名在绑定的时候是以下划线开头在这个大写字母前面,然后全部小写.举一个例子吧123如 函数名 PyHead 绑定的 command 是 py_head函数名 pyhead 绑定的 command 是 pyhead 函数名 PYHead 绑定的 command 是 p_y_head 这下应该明白了吧. 这样你就成功的写了一个 Sublime 插件的 hello world,如果你要写更厉害的插件你还得去学习 正则表达式,至于这个是啥怎么用自己去找,网上一大堆. 好了今天就先到这.有时间我在接着写一些其他的文档如 Sublime的API文档.","tags":[{"name":"sublime插件","slug":"sublime插件","permalink":"https://leng521.top/tags/sublime插件/"}]},{"title":"linux升级gcc","date":"2018-05-09T01:37:30.000Z","path":"/posts/f62a7c7d/","text":"这一篇是对linux centos7 中 gcc 的升级.这次升级gcc的版本是 8.1.0 方法一12345678910111213141516171819$ su \\\\进入 root# sudo yum install libmpc-devel mpfr-devel gmp-devel...# cd 下载# curl ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/* \\\\* 号为自己想要更新的版本号\\\\ 做法是自己将这个 地址放到浏览器中自己去选取合适的版本直接下载.\\\\ 我这里下载的是 8.1.0 # tar zxfv gcc-8.1.0.tar.gz# cd gcc-8.1.0# ./configure --disable-multilib --enable-languages=c,c++# make -j 4...# make install...# gcc -v...线程模式:posixgcc 版本 8.1.0(GCC)\\\\ ... 意思省略 方法二在 etc/yum.repos.d下面添加repo1touch FedoraRepo.repo 然后添加下面的内容: 123456[warning:fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=https://getfedora.org/static/34EC9CBA.txt 然后更新gcc 1yum -y update gcc gcc-c++ 然后就是新版本了但是这我还不太懂.所以就没有用这个方法. 我用的是方法一.因为方法一可以自己选择gcc版本,并不是所有的东西都要更新到最新的版本,当然这个根据你们自己了.根据情况而定. 方法二更简单一点. 好了今天就先到这了.","tags":[{"name":"gcc","slug":"gcc","permalink":"https://leng521.top/tags/gcc/"}]},{"title":"9宫格纹理的更新问题","date":"2018-04-26T01:40:53.000Z","path":"/posts/1e09c0f5/","text":"这一篇文章主要是讲解一下 cocos2dx 9宫格纹理更新问题我这里就不说 cocos2dx 9宫格怎么使用了。在网上一搜一大堆。基本内容都是那样。我不想做无谓的叙述了。 问题描述现在的环境是： cocos2dx 3.15 VS 2015 使用 lua 写项目 注意这里是说使用 plist 里面的纹理 也就是精灵帧 现在面临的问题是: cocos2dx 对9宫格纹理更新，不能像更新精灵那样使用它提供的函数 setSpriteFrame虽然9宫格就是对精灵的在次封装。 cocos2dx 九宫格的这个函数（setSpriteFrame）在C++定义的头文件中是长这样的 123// UIScale9Sprite.hvirtual void setSpriteFrame(SpriteFrame * spriteFrame, const Rect&amp; capInsets);//它没有提供直接输入字符串来实现纹理的更换. 这说明我们需要一个精灵帧类型，但是这个类型我用了这么时间，基本没用过。 问题剖析我上面有说过九宫格是对纹理的再次封装实现的，说以就去查看他的父类Sprite.h这个是怎么初始化的。 追了 它父类的初始化函数 Sprite.h 看到了它是怎么创建出精灵帧的，下面是他初始化它内部的精灵帧的操作。12345678910111213141516void Sprite::setSpriteFrame(const std::string &amp;spriteFrameName)&#123; CCASSERT(!spriteFrameName.empty(), \"spriteFrameName must not be empty\"); if (spriteFrameName.empty()) &#123; return; &#125; SpriteFrameCache *cache = SpriteFrameCache::getInstance(); // 根据名字在精灵帧缓存中查找相应的精灵帧。 SpriteFrame *spriteFrame = cache-&gt;getSpriteFrameByName(spriteFrameName); CCASSERT(spriteFrame, std::string(\"Invalid spriteFrameName :\").append(spriteFrameName).c_str()); // 设置自己内部的精灵帧对象 setSpriteFrame(spriteFrame);&#125; 原理是在精灵帧缓存中查找对象设置精灵的精灵帧 代码实现这下就好办了。 lua层的代码就是 12345local spriteFrameCache = cc.SpriteFrameCache:getInstance()local frame = spriteFrameCache:getSpriteFrame(\"xxx.png\")-- xxx.png 就是你 plist文件中对应的文件名字。-- 这个就是我们需要的精灵帧对象-- 然后在调用它的 setSpriteFrame 具体的实现代码lua层的c++层我就不说了。暂时没有用到。做法都一样。上面的实现在 cocos2dx display的lua文件里面有实现。所以就直接调用。1234567891011121314151617181920212223242526-- desc: 创建9宫格图片-- params [ path | pos | capInsets | size | rect ]-- params.path 可以是精灵帧 ej: params.path = \"#xxx.png\"-- params.pos 精灵的位置-- params.capInsets 是9宫格中间 Rect 的位置和大小-- params.rect 可以不用填function T.cp_s9( parentNode, params ) local pos = params.pos local s = display.newSprite(params.path,pos.x,pos.y,params) local _ = parentNode and parentNode:addChild(s) return send-- desc: 9宫格图片纹理的更新-- path 无效添加报错机制function T.update_s9( node, path, capInsets, size ) if string.byte(path) == 35 then local sp = display.newSpriteFrame(path) node:setSpriteFrame(sp,capInsets) else if not cc.FileUtils:getInstance():isFileExist(path) then error(string.format(\"invalid path , file isn't exist , path - %s\",path)) end node:setTexture(path) end node:setContentSize(size)end 需要注意的一点就是在九宫格更新纹理后尺寸又变回原来的大小，你需要重新设置大小。","tags":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"https://leng521.top/tags/cocos2dx/"},{"name":"9宫格","slug":"9宫格","permalink":"https://leng521.top/tags/9宫格/"}]},{"title":"python-闭包问题","date":"2018-04-20T02:31:51.000Z","path":"/posts/87435431/","text":"本文主要是python闭包问题的记录。python 实现的有内部函数，那么自然就会使用内部函数外面的变量 。 注意这里是要改变局部变量 可以使用下面的策略，如果只是简单的引用，可以直接引用 不用使用 nonlocal 关键字 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-def A(): xxx = 0 def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment nonlocal xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3 这里主要是使用了python 内部的关键字 nonlocal主要是引用内部函数以外的局部变量 注意这里不是全局变量。 注意这个关键字是python3.x 中可以出现的关键字。在python2.x中会报错。在python2.x的版本中可以使用 list 封装一层，实现使用内部函数以外的局部变量。这里不能使用 元祖 因为元祖的变量时不可变的。 如果要引用全局变量要是用python的另外一个关键字 global。用法和上面相同。 使用例子如下： 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-xxx = 0def A(): def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment global xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"https://leng521.top/tags/闭包/"}]},{"title":"记录使用hexo写博客的问题","date":"2018-04-14T08:17:16.000Z","path":"/posts/a9ff66a6/","text":"在使用 hexo 总会遇到这种那种的错误我这里就记录一下,希望后面使用 hexo 写博客的人能少遇到一点麻烦，少走一点弯路，OK，废话不多说。 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false. 2. hexo skip_render 的使用123skip_render: - 'dir/**' # 忽略dir这目录下的所有文件，不进行渲染 - 'xx/**' # 道理同上。 3. 修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 `hexo clean`,每次记得使用这个命令清除一下","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"}]},{"title":"python_optionparser模块","date":"2018-04-11T08:01:20.000Z","path":"/posts/ce1d3b12/","text":"本文主要是 python 对命令行的处理模块 就象是这样的","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"optionParser","slug":"optionParser","permalink":"https://leng521.top/tags/optionParser/"}]},{"title":"git命令的记录","date":"2018-03-07T03:00:24.000Z","path":"/posts/82a402af/","text":"现在对git也使用快一年了现在总结一下常用的一些命令。 本文的大纲对以下命令做一些记录1.git clone2.git pull3.git commit4.git push5.git branch6.git remote7.git checkout8.git reset9.git stash10.git配置一些外部工具11.git merge12.git log13.git show14.git diff git clonegit clone 是克隆别的仓库 1234git clone &lt;repo&gt; &lt;directory&gt;参数说明： repo:Git 仓库 directory:本地目录 ej:比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： git clone git://github.com/schacon/grit.git 或者是这样的 git clone git://github.com/schacon/grit.git test 这个就会克隆到 ../test 和目录 git pull拉取别人在远程仓库更新的内容 默认是远程的 origin 分支 git add将本地的改变提交到缓存区 git add -u 是将本地追踪的文件提交到缓存区 123ej:git add -u *.png--添加所有追踪的文件提交到缓存区 前提是以.png 为结尾的文件 git add -A 是将本地未追踪的文件提交到缓存区 123ej:git add -A .--添加所有的未追踪的文件提交到缓存区 git commit 将本地的改变提交到缓存区的内容到本地版本库 123ej:git commit -m &quot;test&quot;-- -m 是对此次的提交内容的描述(desc) git push 将本地的改变提交到本地版本库的内容推送到远程版本库 123ej:git push-- 默认是主为分支(origin) git push 将本地分支推送到云端 1git push origin/远程分支的名字 本地分支的名字 git branch 有关分支的一些使用 git branch 查看本地分支 git branch -vv 查看本地分支 与 远程分支的映射关系 git branch -a 查看 本地和远程分支 git branch -r 查看远程分支 git branch xx 创建新的xx分支 git branch -D xx 删除xx分支 git branch upstream(git 分支的映射关系)建立本地分支与远程分支的映射关系（或者为跟踪关系track）。这样使用`git pull`或者`git push`时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。 ej:从这上面可以看到本地分支与远程分支的映射关系若没有映射关系 git pull 或是 git push 会失败 与远程分支建立映射关系 使用 git branch -u origin/xx 与远程分支 建立 映射关系xx 为 远程分支的名字 与远程分支取消映射关系使用 git branch --unset-upstream 补充：不同名字客之间也是可以建立映射关系的 删除远程的分支12git push origin --delete xxx-- xxx 为远程分支的名字 git fetch 来一个关系式 git pull = git fecth + git merge拉取别人远程仓库的内容到自己本地的一个分支上 1234ej: git fecth origin test:temp -- 拉取远程分支 test 到 本地 temp 分支上 -- 注意这种拉取 本地分支和远程分支 是没有映射关系的 git remotegit remote and git remote -v git remote用来管理本地工作目录对应的远程代码仓库，在一般的工作目录下，执行git remote结果如下： git remote add 我们可以使用git remote add命令来增加一个远程仓库，这个远程仓库可以是ssh地址（如上面这种），可以是本地目录，也可以是git协议或者http协议的地址。 例如，我要把liming的仓库作为我的远程仓库之一，可以执行git remote add 来增加仓库，例如： 123456789$ git remote add liming /home/liming/repo$ git remotelimingorigin$ git remote -vliming /home/liming/repo (fetch)liming /home/liming/repo (push)origin git@remoteRepo (fetch)origin git@remoteRepo (push) 相应的，可以使用git remote rm或者git remote rename对远程代码仓库的名称进行修改（本地的，不会影响到对方的目录） git checkout作用： 1.切换分支 2.放弃对某个文件的修改 3.创建新的分支 git checkout xx 切换到xx分支 git checkout -b xx 在没有的时候 创建的新的分支xx 并跳转到 xx 分支上 git checkout xx.ext 放弃修改直接还原和版本库保持一致 拉取远程方法123git checkout -b 本地分支名x origin/远程分支名xNote:使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 git reset作用： 1.文件从暂存区回退到工作区 2.版本回退 作用1： git reset HEAD filename(xx)作用2: 我就直接转载一篇文章写的挺好的 git reset的使用 git 中文的教程 –貌似要科学上网 git stash你当前正在开发的分支上面，还有未提交的代码，你又不想把代码提交了，怎么办呢？作用： 将本地的改变存储起来，切换到另外的分支上。 1234git stash-- 将本地的改变存储起来git stash list-- 查看本地存储的列表 如何恢复工作现场呢？ 第一种方案，用`git stash apply`恢复，但是恢复后，stash内容不删除，需要用`git stash drop`来删除 第二种方案，用`git stash pop`,恢复的同时把stash内容也删除了。 git配置一些外部工具配置代码对比工具我配置了一个叫diffuse的工具 我这里给你提供一个下载地址，当然你也可以自己去下载别的 download diffuse 1.git查看有哪些对比工具可以设置命令： 1git difftool --tool-help 2.然后再设置对比工具，如： 12git config --global diff.tool diffusegit config --global difftool.diffuse.path &quot;E:\\Program Files (x86)\\Diffuse\\diffuse.exe&quot; 3.设置好后，使用命令是 git difftool 而不是之前的 git diff 了 git ProblemProblem : 1.为什么在切换分支的时,会出现有时要你提交本地的改变才可以切换，有的时候却不需要？ 出现融合的时候是你当前分支改变的内容与你将要切换分支的内容有冲突，这个时候不知要你融合。 1234解决的方法有我种： 1.使用 git stash 保存当前的改变 git stash 的用法在上面 2.使用 git merge 融合要切换的分支到当前的分支 3.使用 git checkout 还原当前冲突的文件 git merge– 2018年3月20日14:36:34git 融合：是融合你当前版本库没有的东西。你可以选择本地的分支也可以是远程的分支 123456-- 融合远程分支ej: git merge origin/分支的名字-- 融合本地分支ej: git merge 分支的名字 git 更高级的用法问题: 在你的使用 git merge 的时候也会出现冲突. git merge –abort选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好 git status -sb罗列出需要解决冲突的文件. 在你合并的时候 你可以将远端共同祖先的文件, 自己本地的文件, 要融合分支的文件,都下载到本地, 123git show :1:hello.rb &gt; hello.common.rbgit show :2:hello.rb &gt; hello.ours.rbgit show :3:hello.rb &gt; hello.theirs.rb git clean -f在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。就是通过上面的命令 git show :1 … 这个命令产出的文件. git log这里在更新一下 git log 的一些命令的使用 git log -n罗列出最近 n 次提交 ej: git log -3 // 罗列出最近三次的提交信息 git show显示一些提交的状态信息 git show –stat [commitId] ej: git show –stat 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42它会罗列出当前这次提交的信息,以文件更改列表的形式显示,如下图 git show [commitId]这个命令和上个命令很相似 , 只是去掉一个 –stat ej git show 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42 src/a.lua显示这次这个文件提交的内容 git diff比较文件的差异 git diff 文件的相对路径 git diff src/a.lua它会罗列出当前的改动与你本地版本库的差异 git diff branch1 branch2 –stat 显示出所有有差异的文件列表 git diff branch1 branch2 文件名字 显示这个文件的详细差异 git diff branch1 branch2 显示这个两个分支差异文件的详细情况.","tags":[{"name":"git命令","slug":"git命令","permalink":"https://leng521.top/tags/git命令/"}]},{"title":"优化cocos2dxSpine库","date":"2018-01-22T12:44:31.000Z","path":"/posts/c4c0a180/","text":"对cocos2dxSpine库的升级和优化本文的大纲1.升级spine在cocos2dx-3.15的运行时库2.优化spine在创建的时候效率 在开发的时候出现的问题1.spine这个软件导出3.6新加的特效在cocos2dx3.15 不能使用2.spine在批量创建的时候帧数会下降 升级spine -&gt;3.6spine code github 地址去这个地址clone或者是下载Zip这个你随便然后会产现这个目录主要就是我使用箭头标记的这两个目录 spine-c/spine-c/include/spine/*.h spine-c/spine-c/src/spine/*.c spine-cocos2dx/src/spine/*.cpp and spine-cocos2dx/src/spine/*.h 找到自己的工程的根目录 然后去找这个目录全部放在 ···/frameworks/cocos2d-x/cocos/editor-support/spine 直接全部替换然后打开自己的VS去编译记住一点将你添加的C或C++的文件给添加到libSpine的工程中的源文件中 选中 Source Files 执行 Shift + Alt + A 添加现有项 或者是鼠标右键添加好可以 然后编译,你会惊奇的发现编译成功了,但是不要高兴的太早了,因为这个在编译Android的时候会报错,当然原因也很简单，接着往下面看。 在Android中的实现你找到 这个目录里面会有 ···/frameworks/cocos2d-x/cocos/editor-support/spineAndroid.mk的文件将你添加的写在这个配置里面 注意只写 *.h 的文件然后使用 Android Studio 编译 Apk, 这里你也可以使用NDK编译,但是在Android2.？这个不记得了,就已经不在支持NDK编译了所以还是使用Android Studio 吧 在 ios 中的实现也是同样如此，这里就不再讲述了 优化spine在创建的时候效率在原先的 spine 创建的时候每次都需要解析数据,生成骷髅数据,其实这个是很消耗CPU的,导致FPS下降。我的做法是保留 spine create 的原有接口,自己再从新写一个新的接口。原理：创建字典保留骷髅数据每次创建的时候询问这个 Map 是否存在 key 没有创建,有直接使用。 代码的写法有很多种,我这只是参考 在SkeletonAnimation.cpp 中添加如下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798SkeletonAnimation* SkeletonAnimation::createFromCache(const std::string&amp; key_skeletonData)&#123; if (spSkeletonData* skeleton_data = SkeletonAnimation::getSkeletonDataFromCache(key_skeletonData)) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; else &#123; skeleton_data = SkeletonAnimation::loadSkeletonDataToCache(key_skeletonData, key_skeletonData + \".json\", key_skeletonData + \".atlas\"); if (skeleton_data) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it == _allSkeletonDataCache.end()) &#123; SkeletonDataInCache skeleton_data_in_cache; spAtlas* atlas = nullptr; spAttachmentLoader* attachmentLoader = nullptr; skeleton_data_in_cache._skeleton_data = nullptr; atlas = spAtlas_createFromFile(atlasFile.c_str(), 0); CCASSERT(atlas, \"loadSkeletonDataToCache Error atlas file.\"); attachmentLoader = SUPER(Cocos2dAttachmentLoader_create(atlas)); spSkeletonJson* json = spSkeletonJson_createWithLoader(attachmentLoader); json-&gt;scale = scale; skeleton_data_in_cache._skeleton_data = spSkeletonJson_readSkeletonDataFile(json, skeletonJsonFile.c_str()); CCASSERT(skeleton_data_in_cache._skeleton_data, json-&gt;error ? json-&gt;error : \"loadSkeletonDataToCache Error reading skeleton data file.\"); spSkeletonJson_dispose(json); spAtlas_dispose(atlas); if (skeleton_data_in_cache._skeleton_data) &#123; _allSkeletonDataCache[key_skeletonData] = skeleton_data_in_cache; return skeleton_data_in_cache._skeleton_data; &#125; else &#123; //error release if (skeleton_data_in_cache._skeleton_data) &#123; spSkeletonData_dispose(skeleton_data_in_cache._skeleton_data); &#125; &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::getSkeletonDataFromCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return it-&gt;second._skeleton_data; &#125; return nullptr;&#125;bool SkeletonAnimation::removeSkeletonData(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); _allSkeletonDataCache.erase(it); return true; &#125; return false;&#125;void SkeletonAnimation::removeAllSkeletonData()&#123; for (iteratorSkeletonData it = _allSkeletonDataCache.begin(); it != _allSkeletonDataCache.end(); ++it) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); &#125; _allSkeletonDataCache.clear();&#125;bool SkeletonAnimation::isExistSkeletonDataInCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return true; &#125; return false;&#125;//endstd::map&lt;std::string, SkeletonAnimation::SkeletonDataInCache&gt; SkeletonAnimation::_allSkeletonDataCache; 在 SkeletonAnimation.h 中添加如下代码1234567891011121314static SkeletonAnimation* createFromCache(const std::string&amp; key_skeletonData);static spSkeletonData* loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale = 1);static spSkeletonData* getSkeletonDataFromCache(const std::string&amp; key_skeletonData);static bool removeSkeletonData(const std::string&amp; key_skeletonData);static void removeAllSkeletonData();static bool isExistSkeletonDataInCache(const std::string&amp; skeletonDataKeyName);private: struct SkeletonDataInCache &#123; spSkeletonData* _skeleton_data; &#125;; typedef std::map&lt;std::string, SkeletonDataInCache&gt;::iterator iteratorSkeletonData; static std::map&lt;std::string, SkeletonDataInCache&gt; _allSkeletonDataCache; //end Binding to lua既然写了这么多了,就要将这些代码绑定到lua中去 找到自己工程的的libluacocos2d的工程这里你可以自己写代码在 lua_cocos2dx_spine_auto.cpp 中,但是这不是一个程序员应该做的。第二种做是:既然它的文件名有 auto 这个单词,一看就不是人写出来的,OK,去寻找答案。 到这个目录中去 ···/frameworks/cocos2d-x/tools/tolua/ 你会发现有一个genbindings.py的文件你一运行可能报错,你去读他的 README.md ,发现他要你装一些python的库,那就按照说的安装吧你可以 pip 命令也可以 自己下载zip 这个随意。然后就是配置NDK,这个下载解压,配置 path 就完了,我就不多说了。 然后你运行可能还会报错 那就打开 genbindings.py 你会发现他需要的是NDK 3.3-3.4 然而自己的NDK经过查看 是 3.5-3.6 没关系,把它这个所有相关 3.3 3.4 全部改成 3.5-3.6的就OK了。 改完后运行 Prefect ^-^. 在lua中调用123456sp.SkeletonAnimation: createFromCache(key)sp.SkeletonAnimation: isExistSkeletonDataInCache(key)sp.SkeletonAnimation: loadSkeletonDataToCache(key,jsonFilePath,atlasFilePath,scale =1) sp.SkeletonAnimation: getSkeletonDataFromCache(key)sp.SkeletonAnimation: removeSkeletonData(key)sp.SkeletonAnimation: removeAllSkeletonData() 这里面有一个问题是你会发现返回的骨胳数据拿不到,这个是cocos2dx在绑定的时候并没有将这个数据类型绑定lua去,我上面那么写就是为了以后留个接口,当然你也可以自己把那个返回值去掉。 好了今天就到这吧。","tags":[{"name":"spine","slug":"spine","permalink":"https://leng521.top/tags/spine/"}]},{"title":"Using-Hexo","date":"2018-01-17T12:07:49.000Z","path":"/posts/6743743b/","text":"这篇文章只是我对 hexo 的一些功能的测试吧，可能后会常用到这些东西 Requirementsinstall Hexo123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David Levithan-Wide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 12alert(&apos;Hello World!&apos;);print(&apos;Hello World!&apos;) language -&gt; OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; language -&gt; python1print('Hello World!') 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块[language] [title] [url] [link text] code snippet language - &gt;OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; 插入Image图片12&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% asset_img fileName.* title&#125; /posts/6743743b/test.lua test.lua 引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 使用iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"},{"name":"IT","slug":"IT","permalink":"https://leng521.top/tags/IT/"}]},{"title":"Hello World","date":"2018-01-16T16:00:00.000Z","path":"/posts/4a17b156/","text":"搭建自己的博客在github page经过2天的折腾的终于把自己的博客给搭建出来了,也可以说是自己的一个Hello World 吧这个主题是使用Litten的theme通过hexo搭建 准备环境* install git * install node * 注册github的账号 Git Downloadnodejs Downloadgithub 注册的地址 再创建之前思考一个事情就是在你做完这些之后，你开始写自己的博客的时候，突然之间要换电脑了，这个时候你要怎么办这个思考是对于那些使用过 github 或者是使用过别的版本控制的工具。 Build to blog安装 nodejs 很简单,就是傻瓜式的安装。 在安装 git 的时候也是一键式安装。 然后自己注册github的账号。 记得配置自己的 nodejs的Path 在 cmd 窗口 输入 path path 我自己的 nodejs 在E盘 同样看看自己的 git 的 path 有没有配置 然后就是验证你的安装是否正确打开你 cmd 输入 git git 输入 node -v node -v github 就不用验证了吧 然后就是利用 node 的 npm 工具去安装 hexo 输入 npm install -g hexo-cli 如果自己的 hexo 安装成功的话 在 cmd 中 输入 hexo -v hexo -v 创建自己的 hexo 工程假设自己的 hexo 的工程目录是在 D:\\Pro\\pro_wdh\\nodejs 1. 在 cmd 中 输入 pushd D:\\Pro\\pro_wdh\\nodejs 2. cmd的当前目录直接跳转到 D:\\Pro\\pro_wdh\\nodejs 3. 使用 hexo init 命令 初始化 （）hexo init [folderName] ） hexo init hexocd hexonmp install 完成之后目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 运行自己的hexo工程在 cmd 中 输入 hexo s 在自己的浏览器中打开 http://localhost:4000/. 这时你会看到自己的静态网页 更多的 hexo的命令hexo 的官网 部署自己的笔记2github网上的一些教程都是 使用 SSH 去上传自己的博客但是使用 htpp 的方式也同样可以 上传 创建自己的 github 的仓库 上面的仓库名字就和你 github 的名字一样就行了 然后就是在 hexo 的根目录下的 _config.yml 中 找到 按照图片上的配置自己的 github 仓库的地址github 仓库的地址在这里拿 然后执行 hexo的命令 在cmd中输入 1.hexo clean 2.hexo g 3.hexo d 静静的等待 上传完成之后 打开 http://Test.github.io 就可以看到自己的博客了 回答上面的提出的思考答案就是 在 github 上创建自己的 branch(分支) 我是在自己的 github 创建自己的 blog(分支) git 的一些命令 不是太全,但是应对日常还是可以的 做法如下： git chcekout -b blog git add -A git commit - m &quot;commit my blog&quot; git push origin blog 解释一下吧 创建新的分支 blog添加自己的文件到缓存区提交到本地版本库推送到远端 更多 git 的知识 这只是一些基础 更多需要你多去尝试,多自己动手。 有疑问可以加QQ一起讨论","tags":[{"name":"hello world","slug":"hello-world","permalink":"https://leng521.top/tags/hello-world/"},{"name":"github page","slug":"github-page","permalink":"https://leng521.top/tags/github-page/"},{"name":"博客","slug":"博客","permalink":"https://leng521.top/tags/博客/"}]}]
=======
[{"title":"解决运行exe时缺少dll问题","date":"2018-05-23T09:01:51.000Z","path":"/posts/8e17853e/","text":"今天主要是解决如果你使用 cocos2dx 做的游戏(exe) 要放到别人的电脑上运行问题,在有些时候你可能会将自己的exe放到别人的电脑上,但是不幸的是,运行不了,提示说找不到*.dll. 解决思路1.你可能会直接去百度上下载一堆dll但是发现没什么用,还是会报错.那就看来这个思路是行不通的,换一个思路就是你去思考你的电脑比他电脑多了什么东西,其实也就是多了cocos2dx的运行框架,多了个VS.那既然我们已经将cocos2dx编译出来的和锁依赖的dll已经全部放在他的电脑上了,那就剩下个VS,这下目标很清晰喽,直接从VS下手,事实证明这是对的. 解决方案1.去找VS的dll存放的地方,我这里就不找,直接利用电脑管家去全局搜索某个文件,如下图 2.将你缺少的dll全部放在对方这个路径下C:\\Windows\\SysWOW64 Note:当然这里你怕放在这里影响其他的应用的话你也可以不放在,直接放在和你要运行的exe同级目录下就行.我这里只是为了解决多人时出现的问题. 3.copy你通过VS编译出来的exe和它所依赖的dll文件,具体目录在~/simulator/win32/*~代表你项目的根目录,然后将你项目根目录下的src和res文件夹拷贝到他的电脑上,其实就是将win32目录下的src和res给删除,将你项目根目录下的src和res放进去,为了只是保证资源和代码是最新的. 4.如果有人动了c++代码的话,你如果不是太了解C++中dll是干啥的就直接将自己~/simulator/win32/*.dll这个目录下的dll再重新覆盖一下. 好了就先到这里了.","tags":[{"name":"缺少dll","slug":"缺少dll","permalink":"https://leng521.top/tags/缺少dll/"}]},{"title":"给sublime写自定义的插件","date":"2018-05-10T06:17:48.000Z","path":"/posts/b1de475b/","text":"以前总是在sublime中装各种插件,去实现某种便捷,如装一个 git 插件可以直接快速的去查看当前打开的文件与远端的这个文件的差异.但是这些插件总是满足不了你的欲望,有的时候在有一些奇葩的需求,可能没有现有的插件可用,这个时候就要自己去写插件了.首先Sublime是支持自定义插件的,其次是Sublime的插件是采用python的语法,所以你要在写插件之前至少要了解python语法.不然就望而生畏了. 第一步 创建python脚本文件直接打开 Sublime 在最上面工具栏中 找到 Tools/Developer/New Plugin 点击完成之后会有一个内容类似下面的未保存文件1234567import sublimeimport sublime_pluginclass ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, \"Hello, World!\") 关于 sublime 这两个包的 API可以去 SublimeAPI 可能需要翻墙,我只是翻墙之后快了许多. 第二步 填充自己的python文件并保存到相应位置 打开上面所指向的目录自己新建一个文件夹,和你那个User目录同级就行了.列如我建立一个PythonHead 的目录如下: 里面有个 head.py 的python文件,具体内容如下 123456789101112import sublimeimport sublime_pluginimport datetimestr_head = \"\"\"#!usr/bin/env python2#-*- coding: utf-8 -*-#data:%s\\n\"\"\"class PyHeadCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0,str_head % (datetime.datetime.now().strftime(\"%y-%m-%d %H:%m:%s\"))) 这个自定义的功能主要是给自己python文件定义加了一些通用的注释而已.样子就如下面这样 这一写完之后你可以直接打开 Sublime 的命令行 快捷键 ctrl+` 如果快捷键冲突可以直接 View/Show Console 这个也可以 直接在这里面输入如下代码 就会向上面显示的那样. 当然这样肯定是不行的因为这个效率太低下,这里我们直接使用快捷键 第三步 绑定快捷键在上面的那个PyHead的文件夹下面有个 Default (Windows).sublime-keymap 它这个分了一些平台 如 Default (OSX).sublime-keymap Default (Linux).sublime-keymap这样的文件夹,这个是你绑定快捷键到你这个 功能上面.里面的内容如下(使用json的数据格式): 123[ &#123;\"keys\": [\"ctrl+alt+h\"], \"command\": \"py_head\"&#125;] 如果不熟悉json的话可以自己去补一下. 前面这个定义快捷键,后面是你要调用的函数,这里你可能有疑问了,为啥定义是PyHeadCommand 这个名字 却写个这,那是因为在Sublime中 函数的绑定都是小写, 如果你是大写就像上面那样驼峰式命名在绑定的时候是以下划线开头在这个大写字母前面,然后全部小写.举一个例子吧123如 函数名 PyHead 绑定的 command 是 py_head函数名 pyhead 绑定的 command 是 pyhead 函数名 PYHead 绑定的 command 是 p_y_head 这下应该明白了吧. 这样你就成功的写了一个 Sublime 插件的 hello world,如果你要写更厉害的插件你还得去学习 正则表达式,至于这个是啥怎么用自己去找,网上一大堆. 好了今天就先到这.有时间我在接着写一些其他的文档如 Sublime的API文档.","tags":[{"name":"sublime插件","slug":"sublime插件","permalink":"https://leng521.top/tags/sublime插件/"}]},{"title":"linux升级gcc","date":"2018-05-09T01:37:30.000Z","path":"/posts/f62a7c7d/","text":"这一篇是对linux centos7 中 gcc 的升级.这次升级gcc的版本是 8.1.0 方法一12345678910111213141516171819$ su \\\\进入 root# sudo yum install libmpc-devel mpfr-devel gmp-devel...# cd 下载# curl ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/* \\\\* 号为自己想要更新的版本号\\\\ 做法是自己将这个 地址放到浏览器中自己去选取合适的版本直接下载.\\\\ 我这里下载的是 8.1.0 # tar zxfv gcc-8.1.0.tar.gz# cd gcc-8.1.0# ./configure --disable-multilib --enable-languages=c,c++# make -j 4...# make install...# gcc -v...线程模式:posixgcc 版本 8.1.0(GCC)\\\\ ... 意思省略 方法二在 etc/yum.repos.d下面添加repo1touch FedoraRepo.repo 然后添加下面的内容: 123456[warning:fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=https://getfedora.org/static/34EC9CBA.txt 然后更新gcc 1yum -y update gcc gcc-c++ 然后就是新版本了但是这我还不太懂.所以就没有用这个方法. 我用的是方法一.因为方法一可以自己选择gcc版本,并不是所有的东西都要更新到最新的版本,当然这个根据你们自己了.根据情况而定. 方法二更简单一点. 好了今天就先到这了.","tags":[{"name":"gcc","slug":"gcc","permalink":"https://leng521.top/tags/gcc/"}]},{"title":"9宫格纹理的更新问题","date":"2018-04-26T01:40:53.000Z","path":"/posts/1e09c0f5/","text":"这一篇文章主要是讲解一下 cocos2dx 9宫格纹理更新问题我这里就不说 cocos2dx 9宫格怎么使用了。在网上一搜一大堆。基本内容都是那样。我不想做无谓的叙述了。 问题描述现在的环境是： cocos2dx 3.15 VS 2015 使用 lua 写项目 注意这里是说使用 plist 里面的纹理 也就是精灵帧 现在面临的问题是: cocos2dx 对9宫格纹理更新，不能像更新精灵那样使用它提供的函数 setSpriteFrame虽然9宫格就是对精灵的在次封装。 cocos2dx 九宫格的这个函数（setSpriteFrame）在C++定义的头文件中是长这样的 123// UIScale9Sprite.hvirtual void setSpriteFrame(SpriteFrame * spriteFrame, const Rect&amp; capInsets);//它没有提供直接输入字符串来实现纹理的更换. 这说明我们需要一个精灵帧类型，但是这个类型我用了这么时间，基本没用过。 问题剖析我上面有说过九宫格是对纹理的再次封装实现的，说以就去查看他的父类Sprite.h这个是怎么初始化的。 追了 它父类的初始化函数 Sprite.h 看到了它是怎么创建出精灵帧的，下面是他初始化它内部的精灵帧的操作。12345678910111213141516void Sprite::setSpriteFrame(const std::string &amp;spriteFrameName)&#123; CCASSERT(!spriteFrameName.empty(), \"spriteFrameName must not be empty\"); if (spriteFrameName.empty()) &#123; return; &#125; SpriteFrameCache *cache = SpriteFrameCache::getInstance(); // 根据名字在精灵帧缓存中查找相应的精灵帧。 SpriteFrame *spriteFrame = cache-&gt;getSpriteFrameByName(spriteFrameName); CCASSERT(spriteFrame, std::string(\"Invalid spriteFrameName :\").append(spriteFrameName).c_str()); // 设置自己内部的精灵帧对象 setSpriteFrame(spriteFrame);&#125; 原理是在精灵帧缓存中查找对象设置精灵的精灵帧 代码实现这下就好办了。 lua层的代码就是 12345local spriteFrameCache = cc.SpriteFrameCache:getInstance()local frame = spriteFrameCache:getSpriteFrame(\"xxx.png\")-- xxx.png 就是你 plist文件中对应的文件名字。-- 这个就是我们需要的精灵帧对象-- 然后在调用它的 setSpriteFrame 具体的实现代码lua层的c++层我就不说了。暂时没有用到。做法都一样。上面的实现在 cocos2dx display的lua文件里面有实现。所以就直接调用。1234567891011121314151617181920212223242526-- desc: 创建9宫格图片-- params [ path | pos | capInsets | size | rect ]-- params.path 可以是精灵帧 ej: params.path = \"#xxx.png\"-- params.pos 精灵的位置-- params.capInsets 是9宫格中间 Rect 的位置和大小-- params.rect 可以不用填function T.cp_s9( parentNode, params ) local pos = params.pos local s = display.newSprite(params.path,pos.x,pos.y,params) local _ = parentNode and parentNode:addChild(s) return send-- desc: 9宫格图片纹理的更新-- path 无效添加报错机制function T.update_s9( node, path, capInsets, size ) if string.byte(path) == 35 then local sp = display.newSpriteFrame(path) node:setSpriteFrame(sp,capInsets) else if not cc.FileUtils:getInstance():isFileExist(path) then error(string.format(\"invalid path , file isn't exist , path - %s\",path)) end node:setTexture(path) end node:setContentSize(size)end 需要注意的一点就是在九宫格更新纹理后尺寸又变回原来的大小，你需要重新设置大小。","tags":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"https://leng521.top/tags/cocos2dx/"},{"name":"9宫格","slug":"9宫格","permalink":"https://leng521.top/tags/9宫格/"}]},{"title":"python-闭包问题","date":"2018-04-20T02:31:51.000Z","path":"/posts/87435431/","text":"本文主要是python闭包问题的记录。python 实现的有内部函数，那么自然就会使用内部函数外面的变量 。 注意这里是要改变局部变量 可以使用下面的策略，如果只是简单的引用，可以直接引用 不用使用 nonlocal 关键字 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-def A(): xxx = 0 def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment nonlocal xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3 这里主要是使用了python 内部的关键字 nonlocal主要是引用内部函数以外的局部变量 注意这里不是全局变量。 注意这个关键字是python3.x 中可以出现的关键字。在python2.x中会报错。在python2.x的版本中可以使用 list 封装一层，实现使用内部函数以外的局部变量。这里不能使用 元祖 因为元祖的变量时不可变的。 如果要引用全局变量要是用python的另外一个关键字 global。用法和上面相同。 使用例子如下： 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-xxx = 0def A(): def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment global xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"https://leng521.top/tags/闭包/"}]},{"title":"记录使用hexo写博客的问题","date":"2018-04-14T08:17:16.000Z","path":"/posts/a9ff66a6/","text":"在使用 hexo 总会遇到这种那种的错误我这里就记录一下,希望后面使用 hexo 写博客的人能少遇到一点麻烦，少走一点弯路，OK，废话不多说。 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false. 2. hexo skip_render 的使用123skip_render: - 'dir/**' # 忽略dir这目录下的所有文件，不进行渲染 - 'xx/**' # 道理同上。 3. 修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 `hexo clean`,每次记得使用这个命令清除一下","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"}]},{"title":"python_optionparser模块","date":"2018-04-11T08:01:20.000Z","path":"/posts/ce1d3b12/","text":"本文主要是 python 对命令行的处理模块 就象是这样的","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"optionParser","slug":"optionParser","permalink":"https://leng521.top/tags/optionParser/"}]},{"title":"git命令的记录","date":"2018-03-07T03:00:24.000Z","path":"/posts/82a402af/","text":"现在对git也使用快一年了现在总结一下常用的一些命令。 本文的大纲对以下命令做一些记录1.git clone2.git pull3.git commit4.git push5.git branch6.git remote7.git checkout8.git reset9.git stash10.git配置一些外部工具11.git merge12.git log13.git show14.git diff git clonegit clone 是克隆别的仓库 1234git clone &lt;repo&gt; &lt;directory&gt;参数说明： repo:Git 仓库 directory:本地目录 ej:比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： git clone git://github.com/schacon/grit.git 或者是这样的 git clone git://github.com/schacon/grit.git test 这个就会克隆到 ../test 和目录 git pull拉取别人在远程仓库更新的内容 默认是远程的 origin 分支 git add将本地的改变提交到缓存区 git add -u 是将本地追踪的文件提交到缓存区 123ej:git add -u *.png--添加所有追踪的文件提交到缓存区 前提是以.png 为结尾的文件 git add -A 是将本地未追踪的文件提交到缓存区 123ej:git add -A .--添加所有的未追踪的文件提交到缓存区 git commit 将本地的改变提交到缓存区的内容到本地版本库 123ej:git commit -m &quot;test&quot;-- -m 是对此次的提交内容的描述(desc) git push 将本地的改变提交到本地版本库的内容推送到远程版本库 123ej:git push-- 默认是主为分支(origin) git push 将本地分支推送到云端 1git push origin/远程分支的名字 本地分支的名字 git branch 有关分支的一些使用 git branch 查看本地分支 git branch -vv 查看本地分支 与 远程分支的映射关系 git branch -a 查看 本地和远程分支 git branch -r 查看远程分支 git branch xx 创建新的xx分支 git branch -D xx 删除xx分支 git branch upstream(git 分支的映射关系)建立本地分支与远程分支的映射关系（或者为跟踪关系track）。这样使用`git pull`或者`git push`时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。 ej:从这上面可以看到本地分支与远程分支的映射关系若没有映射关系 git pull 或是 git push 会失败 与远程分支建立映射关系 使用 git branch -u origin/xx 与远程分支 建立 映射关系xx 为 远程分支的名字 与远程分支取消映射关系使用 git branch --unset-upstream 补充：不同名字客之间也是可以建立映射关系的 删除远程的分支12git push origin --delete xxx-- xxx 为远程分支的名字 git fetch 来一个关系式 git pull = git fecth + git merge拉取别人远程仓库的内容到自己本地的一个分支上 1234ej: git fecth origin test:temp -- 拉取远程分支 test 到 本地 temp 分支上 -- 注意这种拉取 本地分支和远程分支 是没有映射关系的 git remotegit remote and git remote -v git remote用来管理本地工作目录对应的远程代码仓库，在一般的工作目录下，执行git remote结果如下： git remote add 我们可以使用git remote add命令来增加一个远程仓库，这个远程仓库可以是ssh地址（如上面这种），可以是本地目录，也可以是git协议或者http协议的地址。 例如，我要把liming的仓库作为我的远程仓库之一，可以执行git remote add 来增加仓库，例如： 123456789$ git remote add liming /home/liming/repo$ git remotelimingorigin$ git remote -vliming /home/liming/repo (fetch)liming /home/liming/repo (push)origin git@remoteRepo (fetch)origin git@remoteRepo (push) 相应的，可以使用git remote rm或者git remote rename对远程代码仓库的名称进行修改（本地的，不会影响到对方的目录） git checkout作用： 1.切换分支 2.放弃对某个文件的修改 3.创建新的分支 git checkout xx 切换到xx分支 git checkout -b xx 在没有的时候 创建的新的分支xx 并跳转到 xx 分支上 git checkout xx.ext 放弃修改直接还原和版本库保持一致 拉取远程方法123git checkout -b 本地分支名x origin/远程分支名xNote:使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 git reset作用： 1.文件从暂存区回退到工作区 2.版本回退 作用1： git reset HEAD filename(xx)作用2: 我就直接转载一篇文章写的挺好的 git reset的使用 git 中文的教程 –貌似要科学上网 git stash你当前正在开发的分支上面，还有未提交的代码，你又不想把代码提交了，怎么办呢？作用： 将本地的改变存储起来，切换到另外的分支上。 1234git stash-- 将本地的改变存储起来git stash list-- 查看本地存储的列表 如何恢复工作现场呢？ 第一种方案，用`git stash apply`恢复，但是恢复后，stash内容不删除，需要用`git stash drop`来删除 第二种方案，用`git stash pop`,恢复的同时把stash内容也删除了。 git配置一些外部工具配置代码对比工具我配置了一个叫diffuse的工具 我这里给你提供一个下载地址，当然你也可以自己去下载别的 download diffuse 1.git查看有哪些对比工具可以设置命令： 1git difftool --tool-help 2.然后再设置对比工具，如： 12git config --global diff.tool diffusegit config --global difftool.diffuse.path &quot;E:\\Program Files (x86)\\Diffuse\\diffuse.exe&quot; 3.设置好后，使用命令是 git difftool 而不是之前的 git diff 了 git ProblemProblem : 1.为什么在切换分支的时,会出现有时要你提交本地的改变才可以切换，有的时候却不需要？ 出现融合的时候是你当前分支改变的内容与你将要切换分支的内容有冲突，这个时候不知要你融合。 1234解决的方法有我种： 1.使用 git stash 保存当前的改变 git stash 的用法在上面 2.使用 git merge 融合要切换的分支到当前的分支 3.使用 git checkout 还原当前冲突的文件 git merge– 2018年3月20日14:36:34git 融合：是融合你当前版本库没有的东西。你可以选择本地的分支也可以是远程的分支 123456-- 融合远程分支ej: git merge origin/分支的名字-- 融合本地分支ej: git merge 分支的名字 git 更高级的用法问题: 在你的使用 git merge 的时候也会出现冲突. git merge –abort选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好 git status -sb罗列出需要解决冲突的文件. 在你合并的时候 你可以将远端共同祖先的文件, 自己本地的文件, 要融合分支的文件,都下载到本地, 123git show :1:hello.rb &gt; hello.common.rbgit show :2:hello.rb &gt; hello.ours.rbgit show :3:hello.rb &gt; hello.theirs.rb git clean -f在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。就是通过上面的命令 git show :1 … 这个命令产出的文件. git log这里在更新一下 git log 的一些命令的使用 git log -n罗列出最近 n 次提交 ej: git log -3 // 罗列出最近三次的提交信息 git show显示一些提交的状态信息 git show –stat [commitId] ej: git show –stat 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42它会罗列出当前这次提交的信息,以文件更改列表的形式显示,如下图 git show [commitId]这个命令和上个命令很相似 , 只是去掉一个 –stat ej git show 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42 src/a.lua显示这次这个文件提交的内容 git diff比较文件的差异 git diff 文件的相对路径 git diff src/a.lua它会罗列出当前的改动与你本地版本库的差异 git diff branch1 branch2 –stat 显示出所有有差异的文件列表 git diff branch1 branch2 文件名字 显示这个文件的详细差异 git diff branch1 branch2 显示这个两个分支差异文件的详细情况.","tags":[{"name":"git命令","slug":"git命令","permalink":"https://leng521.top/tags/git命令/"}]},{"title":"优化cocos2dxSpine库","date":"2018-01-22T12:44:31.000Z","path":"/posts/c4c0a180/","text":"对cocos2dxSpine库的升级和优化本文的大纲1.升级spine在cocos2dx-3.15的运行时库2.优化spine在创建的时候效率 在开发的时候出现的问题1.spine这个软件导出3.6新加的特效在cocos2dx3.15 不能使用2.spine在批量创建的时候帧数会下降 升级spine -&gt;3.6spine code github 地址去这个地址clone或者是下载Zip这个你随便然后会产现这个目录主要就是我使用箭头标记的这两个目录 spine-c/spine-c/include/spine/*.h spine-c/spine-c/src/spine/*.c spine-cocos2dx/src/spine/*.cpp and spine-cocos2dx/src/spine/*.h 找到自己的工程的根目录 然后去找这个目录全部放在 ···/frameworks/cocos2d-x/cocos/editor-support/spine 直接全部替换然后打开自己的VS去编译记住一点将你添加的C或C++的文件给添加到libSpine的工程中的源文件中 选中 Source Files 执行 Shift + Alt + A 添加现有项 或者是鼠标右键添加好可以 然后编译,你会惊奇的发现编译成功了,但是不要高兴的太早了,因为这个在编译Android的时候会报错,当然原因也很简单，接着往下面看。 在Android中的实现你找到 这个目录里面会有 ···/frameworks/cocos2d-x/cocos/editor-support/spineAndroid.mk的文件将你添加的写在这个配置里面 注意只写 *.h 的文件然后使用 Android Studio 编译 Apk, 这里你也可以使用NDK编译,但是在Android2.？这个不记得了,就已经不在支持NDK编译了所以还是使用Android Studio 吧 在 ios 中的实现也是同样如此，这里就不再讲述了 优化spine在创建的时候效率在原先的 spine 创建的时候每次都需要解析数据,生成骷髅数据,其实这个是很消耗CPU的,导致FPS下降。我的做法是保留 spine create 的原有接口,自己再从新写一个新的接口。原理：创建字典保留骷髅数据每次创建的时候询问这个 Map 是否存在 key 没有创建,有直接使用。 代码的写法有很多种,我这只是参考 在SkeletonAnimation.cpp 中添加如下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798SkeletonAnimation* SkeletonAnimation::createFromCache(const std::string&amp; key_skeletonData)&#123; if (spSkeletonData* skeleton_data = SkeletonAnimation::getSkeletonDataFromCache(key_skeletonData)) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; else &#123; skeleton_data = SkeletonAnimation::loadSkeletonDataToCache(key_skeletonData, key_skeletonData + \".json\", key_skeletonData + \".atlas\"); if (skeleton_data) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it == _allSkeletonDataCache.end()) &#123; SkeletonDataInCache skeleton_data_in_cache; spAtlas* atlas = nullptr; spAttachmentLoader* attachmentLoader = nullptr; skeleton_data_in_cache._skeleton_data = nullptr; atlas = spAtlas_createFromFile(atlasFile.c_str(), 0); CCASSERT(atlas, \"loadSkeletonDataToCache Error atlas file.\"); attachmentLoader = SUPER(Cocos2dAttachmentLoader_create(atlas)); spSkeletonJson* json = spSkeletonJson_createWithLoader(attachmentLoader); json-&gt;scale = scale; skeleton_data_in_cache._skeleton_data = spSkeletonJson_readSkeletonDataFile(json, skeletonJsonFile.c_str()); CCASSERT(skeleton_data_in_cache._skeleton_data, json-&gt;error ? json-&gt;error : \"loadSkeletonDataToCache Error reading skeleton data file.\"); spSkeletonJson_dispose(json); spAtlas_dispose(atlas); if (skeleton_data_in_cache._skeleton_data) &#123; _allSkeletonDataCache[key_skeletonData] = skeleton_data_in_cache; return skeleton_data_in_cache._skeleton_data; &#125; else &#123; //error release if (skeleton_data_in_cache._skeleton_data) &#123; spSkeletonData_dispose(skeleton_data_in_cache._skeleton_data); &#125; &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::getSkeletonDataFromCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return it-&gt;second._skeleton_data; &#125; return nullptr;&#125;bool SkeletonAnimation::removeSkeletonData(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); _allSkeletonDataCache.erase(it); return true; &#125; return false;&#125;void SkeletonAnimation::removeAllSkeletonData()&#123; for (iteratorSkeletonData it = _allSkeletonDataCache.begin(); it != _allSkeletonDataCache.end(); ++it) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); &#125; _allSkeletonDataCache.clear();&#125;bool SkeletonAnimation::isExistSkeletonDataInCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return true; &#125; return false;&#125;//endstd::map&lt;std::string, SkeletonAnimation::SkeletonDataInCache&gt; SkeletonAnimation::_allSkeletonDataCache; 在 SkeletonAnimation.h 中添加如下代码1234567891011121314static SkeletonAnimation* createFromCache(const std::string&amp; key_skeletonData);static spSkeletonData* loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale = 1);static spSkeletonData* getSkeletonDataFromCache(const std::string&amp; key_skeletonData);static bool removeSkeletonData(const std::string&amp; key_skeletonData);static void removeAllSkeletonData();static bool isExistSkeletonDataInCache(const std::string&amp; skeletonDataKeyName);private: struct SkeletonDataInCache &#123; spSkeletonData* _skeleton_data; &#125;; typedef std::map&lt;std::string, SkeletonDataInCache&gt;::iterator iteratorSkeletonData; static std::map&lt;std::string, SkeletonDataInCache&gt; _allSkeletonDataCache; //end Binding to lua既然写了这么多了,就要将这些代码绑定到lua中去 找到自己工程的的libluacocos2d的工程这里你可以自己写代码在 lua_cocos2dx_spine_auto.cpp 中,但是这不是一个程序员应该做的。第二种做是:既然它的文件名有 auto 这个单词,一看就不是人写出来的,OK,去寻找答案。 到这个目录中去 ···/frameworks/cocos2d-x/tools/tolua/ 你会发现有一个genbindings.py的文件你一运行可能报错,你去读他的 README.md ,发现他要你装一些python的库,那就按照说的安装吧你可以 pip 命令也可以 自己下载zip 这个随意。然后就是配置NDK,这个下载解压,配置 path 就完了,我就不多说了。 然后你运行可能还会报错 那就打开 genbindings.py 你会发现他需要的是NDK 3.3-3.4 然而自己的NDK经过查看 是 3.5-3.6 没关系,把它这个所有相关 3.3 3.4 全部改成 3.5-3.6的就OK了。 改完后运行 Prefect ^-^. 在lua中调用123456sp.SkeletonAnimation: createFromCache(key)sp.SkeletonAnimation: isExistSkeletonDataInCache(key)sp.SkeletonAnimation: loadSkeletonDataToCache(key,jsonFilePath,atlasFilePath,scale =1) sp.SkeletonAnimation: getSkeletonDataFromCache(key)sp.SkeletonAnimation: removeSkeletonData(key)sp.SkeletonAnimation: removeAllSkeletonData() 这里面有一个问题是你会发现返回的骨胳数据拿不到,这个是cocos2dx在绑定的时候并没有将这个数据类型绑定lua去,我上面那么写就是为了以后留个接口,当然你也可以自己把那个返回值去掉。 好了今天就到这吧。","tags":[{"name":"spine","slug":"spine","permalink":"https://leng521.top/tags/spine/"}]},{"title":"Using-Hexo","date":"2018-01-17T12:07:49.000Z","path":"/posts/6743743b/","text":"这篇文章只是我对 hexo 的一些功能的测试吧，可能后会常用到这些东西 Requirementsinstall Hexo123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David Levithan-Wide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 12alert(&apos;Hello World!&apos;);print(&apos;Hello World!&apos;) language -&gt; OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; language -&gt; python1print('Hello World!') 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块[language] [title] [url] [link text] code snippet language - &gt;OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; 插入Image图片12&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% asset_img fileName.* title&#125; /posts/6743743b/test.lua test.lua 引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 使用iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"},{"name":"IT","slug":"IT","permalink":"https://leng521.top/tags/IT/"}]},{"title":"Hello World","date":"2018-01-16T16:00:00.000Z","path":"/posts/4a17b156/","text":"搭建自己的博客在github page经过2天的折腾的终于把自己的博客给搭建出来了,也可以说是自己的一个Hello World 吧这个主题是使用Litten的theme通过hexo搭建 准备环境* install git * install node * 注册github的账号 Git Downloadnodejs Downloadgithub 注册的地址 再创建之前思考一个事情就是在你做完这些之后，你开始写自己的博客的时候，突然之间要换电脑了，这个时候你要怎么办这个思考是对于那些使用过 github 或者是使用过别的版本控制的工具。 Build to blog安装 nodejs 很简单,就是傻瓜式的安装。 在安装 git 的时候也是一键式安装。 然后自己注册github的账号。 记得配置自己的 nodejs的Path 在 cmd 窗口 输入 path path 我自己的 nodejs 在E盘 同样看看自己的 git 的 path 有没有配置 然后就是验证你的安装是否正确打开你 cmd 输入 git git 输入 node -v node -v github 就不用验证了吧 然后就是利用 node 的 npm 工具去安装 hexo 输入 npm install -g hexo-cli 如果自己的 hexo 安装成功的话 在 cmd 中 输入 hexo -v hexo -v 创建自己的 hexo 工程假设自己的 hexo 的工程目录是在 D:\\Pro\\pro_wdh\\nodejs 1. 在 cmd 中 输入 pushd D:\\Pro\\pro_wdh\\nodejs 2. cmd的当前目录直接跳转到 D:\\Pro\\pro_wdh\\nodejs 3. 使用 hexo init 命令 初始化 （）hexo init [folderName] ） hexo init hexocd hexonmp install 完成之后目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 运行自己的hexo工程在 cmd 中 输入 hexo s 在自己的浏览器中打开 http://localhost:4000/. 这时你会看到自己的静态网页 更多的 hexo的命令hexo 的官网 部署自己的笔记2github网上的一些教程都是 使用 SSH 去上传自己的博客但是使用 htpp 的方式也同样可以 上传 创建自己的 github 的仓库 上面的仓库名字就和你 github 的名字一样就行了 然后就是在 hexo 的根目录下的 _config.yml 中 找到 按照图片上的配置自己的 github 仓库的地址github 仓库的地址在这里拿 然后执行 hexo的命令 在cmd中输入 1.hexo clean 2.hexo g 3.hexo d 静静的等待 上传完成之后 打开 http://Test.github.io 就可以看到自己的博客了 回答上面的提出的思考答案就是 在 github 上创建自己的 branch(分支) 我是在自己的 github 创建自己的 blog(分支) git 的一些命令 不是太全,但是应对日常还是可以的 做法如下： git chcekout -b blog git add -A git commit - m &quot;commit my blog&quot; git push origin blog 解释一下吧 创建新的分支 blog添加自己的文件到缓存区提交到本地版本库推送到远端 更多 git 的知识 这只是一些基础 更多需要你多去尝试,多自己动手。 有疑问可以加QQ一起讨论","tags":[{"name":"hello world","slug":"hello-world","permalink":"https://leng521.top/tags/hello-world/"},{"name":"github page","slug":"github-page","permalink":"https://leng521.top/tags/github-page/"},{"name":"博客","slug":"博客","permalink":"https://leng521.top/tags/博客/"}]}]
>>>>>>> 92df836d6ada5610ea8c742e58cb4efe919aa486
