[{"title":"着色器的简单实用","date":"2019-03-16T06:47:37.000Z","path":"/posts/b52cbf29/","text":"Cocos Creator 版本: 2.0.8时间: 2019年3月15日16:53:18 由于Cocos 的材质系统并不是太完善 所以官方并没有推出相关 着色器的文档,但是官方给出了一个Demo, 可以更具这个进行改造一下就可以写自己的着色器了.官方给出的着色器的例子 给 Sprite 填充一些函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 支持自定义Shaderconst renderEngine = cc.renderer.renderEngine;const SpriteMaterial = renderEngine.SpriteMaterial;const GraySpriteMaterial = renderEngine.GraySpriteMaterial;const STATE_CUSTOM = 101;// 取自定义材质cc.Sprite.prototype.getMaterial = function(name) &#123; if (this._materials) &#123; return this._materials[name]; &#125; else &#123; return undefined; &#125;&#125;// 设置自定义材质cc.Sprite.prototype.setMaterial = function(name, mat) &#123; if (!this._materials) &#123; this._materials = &#123;&#125; &#125; this._materials[name] = mat;&#125;// 激活某个材质cc.Sprite.prototype.activateMaterial = function(name) &#123; var mat = this.getMaterial(name); if (mat &amp;&amp; mat !== this._currMaterial) &#123; if (mat) &#123; if (this.node) &#123; mat.color = this.node.color; &#125; if (this.spriteFrame) &#123; mat.texture = this.spriteFrame.getTexture(); &#125; this.node._renderFlag |= cc.RenderFlow.FLAG_COLOR; this._currMaterial = mat; this._currMaterial.name = name; this._state = STATE_CUSTOM; this._activateMaterial(); &#125; else &#123; console.error(\"activateMaterial - unknwon material: \", name); &#125; &#125;&#125;// 取当前的材质cc.Sprite.prototype._activateMaterial = function() &#123; let spriteFrame = this._spriteFrame; // WebGL 暂时支持WebGL if (cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS) &#123; // Get material let material; if (this._state === cc.Sprite.State.GRAY) &#123; if (!this._graySpriteMaterial) &#123; this._graySpriteMaterial = new GraySpriteMaterial(); this.node._renderFlag |= cc.RenderFlow.FLAG_COLOR; &#125; material = this._graySpriteMaterial; this._currMaterial = null; &#125; else if (this._state === STATE_CUSTOM) &#123; if (!this._currMaterial) &#123; console.error(\"_activateMaterial: _currMaterial undefined!\") return; &#125; material = this._currMaterial; &#125; else &#123; if (!this._spriteMaterial) &#123; this._spriteMaterial = new SpriteMaterial(); this.node._renderFlag |= cc.RenderFlow.FLAG_COLOR; &#125; material = this._spriteMaterial; this._currMaterial = null; &#125; // Set texture if (spriteFrame &amp;&amp; spriteFrame.textureLoaded()) &#123; let texture = spriteFrame.getTexture(); if (material.texture !== texture) &#123; material.texture = texture; this._updateMaterial(material); &#125; else if (material !== this._material) &#123; this._updateMaterial(material); &#125; if (this._renderData) &#123; this._renderData.material = material; &#125; this.markForUpdateRenderData(true); this.markForRender(true); &#125; else &#123; this.disableRender(); &#125; &#125;&#125; 构建一个Shader Library 在自定义Shader的时候 要在游戏运行前, 传递自定义的 Shader 给引擎进行编译 123456789101112131415161718192021/* Shader Library*/var ShaderLib = &#123; _shaders: &#123;&#125;, // 增加一个新的Shader addShader: function(shader) &#123; if (this._shaders[shader.name]) &#123; console.error(\"addShader - shader already exist: \", shader.name); return; &#125; cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines); this._shaders[shader.name] = shader; &#125;, // 取Shader的定义 getShader: function(name) &#123; return this._shaders[name]; &#125;&#125; 构建自定义材质(Material) 这个和 Unity 差不多 也是 多通道(pass)渲染 但是这个例子里面只有 单通道, 没有用到多通道,我这里举一个多通道的例子吧 比如渲染 描边, 在第一个通道渲染 比原图大5像素的图片, 第二个通道 渲染原图, 进而实现描边.至于这个 多通道 我后面看一下 Creator Engine 源码吧 ,, 有时间写一下,, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * Custom Material */const renderEngine = cc.renderer.renderEngine;const renderer = renderEngine.renderer;const gfx = renderEngine.gfx;const Material = renderEngine.Material;var CustomMaterial = (function (Material$$1) &#123; function CustomMaterial(shaderName, params, defines, passList) &#123; Material$$1.call(this, false); var pass; if(!passList) &#123; // 配置一个简单的的通道 你仔细看后发现后面其实 是个 数组,, 也就是说可以配置多个通道. // 这里的 shaderName 就是 前面 传递给引擎的 自定义 Shader 的名字 pass = new renderer.Pass(shaderName); pass.setDepth(false, false); pass.setCullMode(gfx.CULL_NONE); pass.setBlend( gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA, gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA ); &#125; var techParams = [ &#123; name: 'texture', type: renderer.PARAM_TEXTURE_2D &#125;, &#123; name: 'color', type: renderer.PARAM_COLOR4 &#125; ]; if (params) &#123; techParams = techParams.concat(params); &#125; var mainTech = new renderer.Technique( ['transparent'], techParams, passList ? passList : [pass], ); this.name = shaderName; this._color = &#123; r: 1, g: 1, b: 1, a: 1 &#125;; this._effect = new renderer.Effect( [ mainTech ], &#123;&#125;, defines, ); this._mainTech = mainTech; this._texture = null; &#125; if (Material$$1) CustomMaterial.__proto__ = Material$$1; CustomMaterial.prototype = Object.create(Material$$1 &amp;&amp; Material$$1.prototype); CustomMaterial.prototype.constructor = CustomMaterial; var prototypeAccessors = &#123; effect: &#123; configurable: true &#125;, texture: &#123; configurable: true &#125;, color: &#123; configurable: true &#125; &#125;; prototypeAccessors.effect.get = function () &#123; return this._effect; &#125;; prototypeAccessors.texture.get = function () &#123; return this._texture; &#125;; prototypeAccessors.texture.set = function (val) &#123; if (this._texture !== val) &#123; this._texture = val; this._effect.setProperty('texture', val.getImpl()); this._texIds['texture'] = val.getId(); &#125; &#125;; prototypeAccessors.color.get = function () &#123; return this._color; &#125;; prototypeAccessors.color.set = function (val) &#123; var color = this._color; color.r = val.r / 255; color.g = val.g / 255; color.b = val.b / 255; color.a = val.a / 255; this._effect.setProperty('color', color); &#125;; CustomMaterial.prototype.clone = function clone() &#123; var copy = new CustomMaterial(); copy.texture = this.texture; copy.color = this.color; copy.updateHash(); return copy; &#125;; // 设置自定义参数的值 CustomMaterial.prototype.setParamValue = function (name, value) &#123; this._effect.setProperty(name, value); &#125;; // 设置定义值 CustomMaterial.prototype.setDefine = function (name, value) &#123; this._effect.define(name, value); &#125;; Object.defineProperties(CustomMaterial.prototype, prototypeAccessors); return CustomMaterial;&#125;(Material)); 开始测试刚才写的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 先 Creator 的 写法太长 进行简单的封装const renderer = cc.renderer.renderEngine.renderer;const PARAMTYPE = &#123; i: renderer.PARAM_INT, i2: renderer.PARAM_INT2, i3: renderer.PARAM_INT3, i4: renderer.PARAM_INT4, f : renderer.PARAM_FLOAT, f2 : renderer.PARAM_FLOAT2, f3 : renderer.PARAM_FLOAT3, f4 : renderer.PARAM_FLOAT4, mat2: renderer.PARAM_MAT2, mat3: renderer.PARAM_MAT3, mat4: renderer.PARAM_MAT4, tex2d: renderer.PARAM_TEXTURE_2D, texCube: renderer.PARAM_TEXTURE_CUBE,&#125;cc.Class(&#123; properties: &#123; &#125;, onLoad() &#123; // 初始化 给 Sprite 补充的函数 require(\"SpriteHook\").init(); // 初始化 自定义 的 Shader // 这个 Flash 文件 后面同意给出 // 因为我还写了几个简单的 Shader ShaderLib.addShader(require(\"Flash\")); // 初始化 为了实现这效果需要的变量 this._time = 0; this._sin = 0; this.sp = this.node.getComponent(cc.Sprite); this.flashShader(); &#125;, /* 给精灵设置 材质 */ flashShader() &#123; let name = 'Flash'; let material = this.sp.getMaterial(name); if(!material) &#123; var CustomMaterial = require(\"CustomMaterial\"); material = new CustomMaterial(name,[ &#123;name: 'run_time', type: PARAMTYPE.f&#125; ]); this.sp.setMaterial(name, material); &#125; this.sp.activateMaterial(name); &#125;, update(dt) &#123; this._time += dt; this._sin = Math.sin(this._time); if(this._sin &gt; 0.99) &#123; this._sin = 0; this._time = 0; &#125; const material = this.sp.getCurrMaterial('Flash'); if(!material) &#123; return; &#125; material.setParamValue('run_time', this._sin); &#125;&#125;); 自定义 着色器的代码Flash (扫光)12345678910111213141516// 要初始化的变量this._time = 0;this._sin = 0;// 要不停更新的变量(就是要放在update函数里面的变量)this._time += dt;this._sin = Math.sin(this._time);if(this._sin &gt; 0.99) &#123; this._sin = 0; this._time = 0;&#125;const material = this.sp.getCurrMaterial('Flash');if(!material) &#123; return;&#125;material.setParamValue('run_time', this._sin); 12345678910111213141516171819202122232425262728293031323334353637383940var shader = &#123; name: \"Flash\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 v_uv0; void main() &#123; vec4 pos = viewProj * vec4(a_position, 1.); gl_Position = pos; v_uv0 = a_uv0; &#125; `, frag: `uniform sampler2D texture; /*uniform vec4 color;*/ uniform float run_time; varying vec2 v_uv0; void main() &#123; vec4 origin_color = texture2D(texture, v_uv0); float width = 0.05; float start = run_time * 1.2; float strength = 0.01; float offset = 0.2; vec4 out_color = origin_color; if(v_uv0.x &lt; (start - offset * v_uv0.y) &amp;&amp; v_uv0.x &gt; (start - offset * v_uv0.y - width)) &#123; vec3 blendColor = strength * vec3(255,255,255); out_color = vec4((blendColor * vec3(origin_color.rgb)),out_color.a); &#125; gl_FragColor = out_color; &#125; `&#125; Mosaic(方形马赛克)1// 这个没有要变量的 就是根据 周围像素区中进行模糊 12345678910111213141516171819202122232425262728293031var shader = &#123; name: \"Mosaic\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 uv0; void main () &#123; vec4 pos = viewProj * vec4(a_position, 1); gl_Position = pos; uv0 = a_uv0; &#125; `, frag: `uniform sampler2D texture; uniform vec3 imageSize; uniform float mosaicSize; varying vec2 uv0; void main(void) &#123; vec4 color; vec2 xy = vec2(uv0.x * imageSize.x, uv0.y * imageSize.y); vec2 xyMosaic = vec2(floor(xy.x / mosaicSize) * mosaicSize, floor(xy.y / mosaicSize) * mosaicSize); vec2 uvMosaic = vec2(xyMosaic.x / imageSize.x, xyMosaic.y / imageSize.y); color = texture2D( texture, uvMosaic); gl_FragColor = color; &#125;`,&#125; Move(UV动画)123456789101112// 要初始化的变量this._time = 0;// 要更新的变量this._time += dt;this._moveTime = this._time;this._moveTime %= 3.35;const material = this.sp.getCurrMaterial('Move');if(!material) &#123; return;&#125;material.setParamValue('run_time', this._moveTime); 123456789101112131415161718192021222324252627var shader = &#123; name: \"Move\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 uv0; void main () &#123; vec4 pos = viewProj * vec4(a_position, 1); gl_Position = pos; uv0 = a_uv0; &#125; `, frag: `uniform sampler2D texture; uniform float run_time; varying vec2 uv0; void main() &#123; float x = uv0.x + run_time * 0.3; vec2 uv_o = vec2(x - floor(x),uv0.y); gl_FragColor = texture2D(texture, uv_o); &#125;`,&#125; Vortex(风暴)123456789101112131415161718192021// 要初始化的变量this._angle = 0;this._radius = 0.1;this._time = 0;// 要不停更新的变量(就是要放在update函数里面的变量)this._time += dt;this._angle += 0.03;this._radius += 0.003;if(this._angle &gt;= 5) &#123; this._angle = 0; this._radius = 0.1; &#125;const material = this.sp.getCurrMaterial('Vortex');if(!material) &#123; return;&#125;material.setParamValue('_Radius',this._radius);material.setParamValue('_Angle',this._angle); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var shader = &#123; name: \"Vortex\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 uv0; void main () &#123; vec4 pos = viewProj * vec4(a_position, 1); gl_Position = pos; uv0 = a_uv0; &#125; `, frag: ` uniform sampler2D texture; uniform float _Radius; uniform float _Angle; varying vec2 uv0; vec2 swirl(vec2 uv) &#123; //先减去贴图中心点的纹理坐标,这样是方便旋转计算 uv -= vec2(0.5, 0.5); //计算当前坐标与中心点的距离。 float dist = length(uv); //计算出旋转的百分比 float percent = (_Radius - dist) / _Radius; if (percent &lt; 1.0 &amp;&amp; percent &gt;= 0.0) &#123; //通过sin,cos来计算出旋转后的位置。 float theta = percent * percent * _Angle * 8.0; float s = sin(theta); float c = cos(theta); //uv = vec2(dot(uv, vec2(c, -s)), dot(uv, vec2(s, c))); uv = vec2(uv.x*c - uv.y*s, uv.x*s + uv.y*c); &#125; //再加上贴图中心点的纹理坐标，这样才正确。 uv += vec2(0.5, 0.5); return uv; &#125; void main() &#123; vec2 uv_new = swirl(uv0); gl_FragColor = texture2D(texture, uv_new); &#125; `,&#125; Water(水)12345678910// 要初始化的变量this._time = 0;// 要更新的变量this._time += dt;const material = this.sp.getCurrMaterial('Water');if(!material) &#123; return;&#125;material.setParamValue('run_time', this._time); 1234567891011121314151617181920212223242526272829303132333435363738394041var shader = &#123; name: \"Water\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 uv0; void main () &#123; vec4 pos = viewProj * vec4(a_position, 1); gl_Position = pos; uv0 = a_uv0; &#125; `, frag: `uniform sampler2D texture; uniform vec3 imageSize; uniform float run_time; varying vec2 uv0; #define F cos(x-y)*cos(y),sin(x+y)*sin(y) vec2 s(vec2 p) &#123; float d=run_time*0.2,x=8.*(p.x+d),y=8.*(p.y+d); return vec2(F); &#125; void mainImage( out vec4 fragColor, in vec2 fragCoord ) &#123; vec2 rs = imageSize.xy; vec2 uv = fragCoord; vec2 q = uv+2./imageSize.x*(s(uv)-s(uv+rs)); // q.y=1.-q.y; fragColor = texture2D(texture, q); &#125; void main() &#123; mainImage(gl_FragColor, uv0.xy); &#125;`,&#125; Wave(波浪)12345678910// 要初始化的变量this._time = 0;// 要更新的变量this._time += dt;const material = this.sp.getCurrMaterial('Wave');if(!material) &#123; return;&#125;material.setParamValue('run_time', this._time); 1234567891011121314151617181920212223242526272829303132333435363738var shader = &#123; name: \"Wave\", defines: [], vert: `uniform mat4 viewProj; attribute vec3 a_position; attribute vec2 a_uv0; varying vec2 v_uv0; void main() &#123; vec4 pos = viewProj * vec4(a_position, 1.); gl_Position = pos; v_uv0 = a_uv0; &#125; `, frag: `uniform sampler2D texture; /*uniform vec4 color;*/ uniform float run_time; uniform vec2 offsetXY; uniform float speed; varying vec2 v_uv0; void main() &#123; vec4 out_color; vec2 xy = v_uv0; xy.x += (sin(xy.x * 30. + run_time * speed) / 30. * offsetXY.x); xy.y += (sin(xy.y * 30. + run_time * speed) / 30. * offsetXY.y); gl_FragColor = texture2D(texture, xy); &#125; `&#125; 还有一个简单的置灰效果没有写，这个因为Creator Engine 自带，所以就没有写。可以看一下Sprite 这个组件的API官方应该介绍的有， 置灰其实 rgb×0.3 就差不多了。 将所有的 逻辑整合到一个脚本里面 ShaderComponent 由于后缀名字为 js 会导致博客渲染出错, 所以改为 txt 你们自行改之就行.这里面会去 require 那几个着色器 你们自己将上面自定义的着色器代码 创建出来. 这么做会带来的一些问题1.精灵运行渐变的Action 就会没有效果 因为这里只是采样纹理的颜色并做出一定的变换并没有融合节点本身的颜色值，如果想做透明变换，你可以给着色器传递值2.在手机上可能会因为精度问题导致，渲染有问题， 你可以采取高精度的类型 如： #ifdef GL_ES highp float xx; #enif 还 中等精度 mediump lowp 如果有其他问题或则是意见可以加我QQ讨论。有些时候博客只是给你一些参考，如有写的不对的地方欢迎指正。写博客不易，切勿吐槽。谢谢。","tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"},{"name":"Shader","slug":"Shader","permalink":"https://leng521.top/tags/Shader/"}]},{"title":"CocosCreator一些简单的优化记录","date":"2019-02-19T12:23:34.000Z","path":"/posts/7f7eba5/","text":"cocos creator 一些简单的优化记录目标: 微信小游戏引擎版本: 2.0.8语言: js时间: 2019年2月19日15:50:29 大纲: - 缩小包体 - 优化 drawcall - 增加游戏编译后包体的安全性(防止反编译) - 优化游戏的计算量 微信小游戏对包体的大小控制的很严格只有4M后面又提出了分包加载的机制,但是能自己优化一些还是更好的一些做法. 缩小包体压缩纹理这里提供的第一个方法是压缩纹理,这个是比较的直接有效果. 1.压缩纹理使用 TinyPng, pngquant, 等等压缩纹理的工具. 这里有一个使用脚本进行压缩的工具,最近在看了一下 gulp,发现有个png压缩的插件,于是就写了一个批量用脚本压缩的工具吧,很简陋用法也很简单.如果你想看懂的具体的细节的话,需要去阅读以下gulp的基本知识点吧. 其实 gulp 还是相对比较的简单易用的.这些依赖的包你就自己安装,如果不会的话,你可以去阅读nodejs的npm (对包管理的一个工具) 相关知识点吧. 插件地址 123456789101112// 配置projectPath =&gt; &#123;你的工程根路径/build&#125;var projectPath = \"\";var gulp = require('gulp');var tinypng_nokey = require('gulp-tinypng-nokey');gulp.task('default', function (cb) &#123; gulp.src([projectPath + \"/res/raw-assets/**/*.&#123;png,jpg,jpeg&#125;\"]) .pipe(tinypng_nokey()) .pipe(gulp.dest(projectPath + \"/res/dest/\")) .on(\"end\", cb);&#125;); 注意： 如果执行gulp命令时提示”不是内部或外部命令，也不是可运行的程序或批处理文件”，则需要执行npm i -g gulp命令重新安装，完成后再执行gulp命令。 成功安装过一次之后，下一个项目在操作时不用再次安装。 进入命令行1gulp 这个操作执行完会在 {projectPath/res/dest} 当然你也可以直接输出到本目录,它会直接进行替换的.(或者更改成你想要的目录)大概纹理会减小 30% ~ 40%. 2.这里你可以使用TexturePacker这些第三方的辅助工具进行纹理压缩,你也可以使用CocosCreator内置的auto atlas(自动图集)的工具进行合图. 做第二步的目的是: 可以减少总体的透明像素,也会有一定的体积减少 能够和批优化游戏的性能 3.如果做原生的游戏的话你可以使用 *.webp 这种后缀的图片是 png 的物理体积的 1/10 倍. 你可直接在百度搜索 png 转 webp 应该有相关的脚本文件, 依赖之间的工作经验的话, 你可以写 python 去做这件事情, 当然也可以是其他的语言. 注意 这种做法只是物理体积的减小,如果是你又资源是需要在远端下载的本地的需求那这将是一个不错的选择,但是他并不能优化的运行时所占用的内存.意思就是说你 png 占用的内存在 webp 这种格式 他同样占用这么多. 由于微信不允许这种纹理后缀名字,所以这种做法不适用于微信小游戏. png 如果压缩过图片是不能进行 png 到 webp 的转换的 会出错, 解决方案是让你们的美术人员将这张图片导入 ps 以不压缩的方式从新导出. 这里面贴出代码, 感兴趣的你也可以自己去实现一下. 移除不需要的模块在打包前，找到项目设置–&gt;模块设置，将项目中没有用到的模块移除（取消勾选状态），如下图所示。 注意 这个也许不能优化游戏的运行速度但是能有效的减少你的包体大小. 尤其是你游戏中有好友排行榜,这个会含有两个 Creator 的引擎库文件是极其占用包体资源的. 优化 drawcall 游戏中 drawcall 是游戏性能比较重要的一个指标, drawcall 越低,证明 cpu 给 gpu 传递次数越少, 每次 cpu 通知 gpu 是需要性能开销的如果能一次传递过去,就能优化游戏的运行效率的. 自动合图 尽量让你相同的精灵帧是挨在一起的. 类似下面这样:123456789101112131415161718A A A B 这样就会只有2个`drawcall`A B A A 这样的设计时很糟糕的. =&gt; 3 个 drawcall- Node - A- Node - A// 这种排列不影响 和批 1 个 drawcall- Node - A - B- Node - A - B// 这种的排列布局 不能和批 4 个 drawcall相同的预制件不能 和批 注意 这个只针对于cocos creator 的渲染机制, 不同的引擎他的和批策略可能不相同. 将碎图进行合图这里面有将多个碎图合成一个大图, 这样也可以实现 和批 处理, 这里有两种实现合图: TexturePacker auto atlas 这个是Cocos Creator内置的合图工具. 下面说一下这两种工具在开发的过程中的优缺点. 1.TexturePacker 的 drawcall的优化在浏览器中可以直接看到, 后者需要打包后才能看到.2.在开发过程中如果纹理更换的频繁,前者需要不停的打包,开发效率低下,后者则不用管(因为是在打包后才能看的见合图的图集). fnt的图片 和 游戏资源进行合图官方描述 将需要自动合图的图片放在同一个目录下，并在此目录下创建一个自动图集配置（AutoAtlas） 可以勾选不包含未引用的资源 要管理好自己的资源目录避免一些没用的资源也打包到一个图集里面. 注意 系统字体会打断和批 做倒计时尽量避免使用系统字体,效率没有 fnt 的搞笑, 因为一个系统字体是包含中文和英文的, 在没有必要的情况下, 尽量就不要使用. 做和批测试的时候尽量使用 Google Chrome 浏览器,其他浏览器在和批效果上好像没有效果.但是小游戏其实算是属于一个原生的游戏,所以这些都会微信小游戏还是生效的. 动态合图官方描述 这个特性是 Cocos Creator 2.x 更换渲染层提供的机制.更大的提高游戏性能一种机制. 动态合图功能使用更简单，只需要在代码中开启动态合图功能即可，也可以更改相关属性。1234cc.dynamicAtlasManager.enabled = true; // 开启动态合图//cc.dynamicAtlasManager.maxAtlasCount = 5; // 最大合图数量//cc.dynamicAtlasManager.textureSize = 1024; // 创建的图集的宽高//cc.dynamicAtlasManager.maxFrameSize = 512; // 可以添加进图集的图片的最大尺寸 注意 动态合图时，目前发现除了Chrome浏览器上DrawCall次数正常以外，其他浏览器的DrawCall次数并非预期结果。 增加游戏编译后包体的安全性(防止反编译)由于js动态运行时语言,所以你开发的项目可能很容易被别人给反编译,窃取了你的劳动成果. 这里只是有效的让代码进行混合,并不能保证一定不能被反编译. 这里还是用 gulp 提供的插件 gulp-javascript-obfuscator插件的介绍地址插件github地址 里面的option(设置)很多 1234567891011121314151617181920212223242526272829compact: true,controlFlowFlattening: false,controlFlowFlatteningThreshold: 0.75,deadCodeInjection: false,deadCodeInjectionThreshold: 0.4,debugProtection: false,debugProtectionInterval: false,disableConsoleOutput: false,domainLock: [],identifierNamesGenerator: &apos;hexadecimal&apos;,identifiersPrefix: &apos;&apos;,inputFileName: &apos;&apos;,log: false,renameGlobals: false,reservedNames: [],reservedStrings: [],rotateStringArray: true,seed: 0,selfDefending: false,sourceMap: false,sourceMapBaseUrl: &apos;&apos;,sourceMapFileName: &apos;&apos;,sourceMapMode: &apos;separate&apos;,stringArray: true,stringArrayEncoding: false,stringArrayThreshold: 0.75,target: &apos;browser&apos;,transformObjectKeys: false,unicodeEscapeSequence: false 123456789101112131415var projectPath = \"\";var javascriptObfuscator = require(\"gulp-javascript-obfuscator\")gulp.task(\"js\", function (cb) &#123; gulp.src([projectPath + \"/src/project.js\"]) .pipe(javascriptObfuscator(&#123; // compact: true, //类型：boolean默认：true mangle: true, //短标识符的名称，如a，b，c stringArray: true, target: \"browser\", &#125;)) .pipe(gulp.dest(projectPath + \"/js-dst\") .on(\"end\", cb));&#125;); 注意 可能会使包体增大一点点,这个你可以在几去做权衡. 优化游戏的计算量 减少对粒子的使用,或者是减少总共的粒子数. 游戏的数据配置,尽量使用数据简洁,紧凑的数据格式(json),读取速度快. 尽量减少混合,混合是逐像素进行计算的,计算量较大. 减少 富文本 和 mask 占用 drawcall 的数量比较多. 尽量少使用 系统字体(ttf) 不能和批, 效率没有 游戏项目里面的 fnt 效率高. 图片不符合尺寸尽量然美术进行调整,不然虽然效果一致的,但是运行时占用的内存是不一样的.游戏是(物理缩放), ps(本质的缩放).","tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"},{"name":"优化","slug":"优化","permalink":"https://leng521.top/tags/优化/"}]},{"title":"git操作命令记录(二)","date":"2019-01-23T13:01:07.000Z","path":"/posts/b0c8e6a5/","text":"时间: 2019年1月23日18:51:03 后面的格式是,在每篇文章开头都会加上时间,好比较你现在的时间和这篇博客书写的时间,你好判定你是借鉴还是可以直接用. 今天主要是介绍 git 的其他命令. git 仓库打标签(tag) git 扩展工具 lfs(large file system) git tag给分支打标签git tag &lt;tagName&gt; 这个命令是给本地仓库最近的一次提交打个标签. ej:1git tag 1.0.0 获取本地所有的标签git tag ej:12git tag&gt; 1.0.0 删除本地标签git tag -d &lt;tagName&gt; ej:1git tag -d 1.0.0 给标签添加描述信息git tag -a &lt;tagName&gt; -m &quot;&lt;decription&gt;&quot; ej:1git tag -a 1.0.1 -m &quot;online version1.0.1&quot; 给标签添加描述信息git tag -a &lt;tagName&gt; -m &quot;&lt;decription&gt;&quot; ej:1git tag -a 1.0.1 -m &quot;online version1.0.1&quot; 给指定的提交打上标签git tag &lt;tagName&gt; &lt;commitId&gt; 这里查询相关的 提交Id(commitId) 可以使用 git log 去看, 但是显示的 commitId 太长了不太好看可以使用下面的命令查看 git log –abbrev-commit 其实给git的 commitId 七位就可以锁定一次提交记录. ej:1git tag 1.0.2 7b23fc5 显示标签的详细情况git show &lt;tagName&gt; ej:1git show 1.0.2 上面这些都是本地的操作,你肯定还需要将你这些,tag提交上去. 推送指定标签到远端git push origin &lt;tagName&gt; ej:1git push origin 1.0.1 推送本地所有的标签git push origin --tags ej:1git push origin --tags 删除远端标签git push origin :refs/tags/&lt;tagName&gt; git push origin --delete tag &lt;tagName&gt; ej:12git push origin :refs/tags/1.0.1git push origin --delete tag 1.0.1 也许有些人会疑惑,怎么去查看远程的 tag,这个你就不用纠结了,因为每次git pull的时候,都会将别人推送上去的 tag 给拉取到本地再次使用 git tag 查看就行了. 删除远端 tag 的工作流(workflow) 先删除本地的tag 然后在删除远端的 tag. git lfsgit-lfs参考地址 这个扩展工具是解决 主仓库日渐庞大的时候 拉取缓慢的问题. 每次提交都会使仓库的总体积变的原来越大.尤其是一些大的项目这一点会体现的越来越明显,导致别人在拉取的时候会变得很缓慢. git lfs 的解决方案是 将一些大的文件 储存在另外的仓库中,保证你的主仓库的体积不会很大.正如,git-lfs 中说到的 更快的拉取速度.但是它并没有解决仓库体积的问题. git-lfs 的工作流(workflow)1.先去安装 这个扩展工具.2.然后在你的仓库目录下,打开 git 执行 git lfs install3.添加你要追踪的大尺寸文件,它这里支持模糊匹配 git lfs track &quot;*.extName&quot;4.执行 git lfs install的时候会产生一个.gitattributes的文件 确保他被提交被追踪 git add .gitattributes 使用 git lfs track 查看现有的文件追踪模式 提交后执行git lfs ls-files 可以显示当前跟踪的文件列表 其他的文件添加跟正常的git 工作流是保持一致. 拉取代码直接就是 git pull , 注意不需要使用 git lfs pull了.","tags":[{"name":"git","slug":"git","permalink":"https://leng521.top/tags/git/"},{"name":"git 扩展工具","slug":"git-扩展工具","permalink":"https://leng521.top/tags/git-扩展工具/"}]},{"title":"scons自动构建工具(二)","date":"2018-12-25T14:01:58.000Z","path":"/posts/66615451/","text":"上一篇好像写的有点长了,上传不上去,所以又写了第二篇续写第一篇. 环境变量影响 scons 构建it uses the dictionary stored in the $ENV construction variable as the external environment for executing commands.解释: 它使用成字典的方式存储在 ENV 的构造变量中 作为外部可执行命令的环境12345678910111213141516171819202122添加 Path 环境变量到 ENV中执行path = ['/usr/local/bin', '/bin', '/usr/bin']env = Environment(ENV = &#123;'PATH' : path&#125;)env['ENV']['PATH'] = ['/usr/local/bin', '/bin', '/usr/bin']env['ENV']['PATH'] = '/usr/local/bin:/bin:/usr/bin'因为是 scons 的配置文件是以 python 的环境执行的 所以 你可以使用 os.environ['PATH'] 获取环境变量, 例子如下:这样做,可以让自己的代码可移植,跨平台import osenv = Environment(ENV = &#123;'PATH' : os.environ['PATH']&#125;)或者你可以将整个 环境变量 全部赋值给 ENVimport osenv = Environment(ENV = os.environ)你可以在已有的环境变量中 拼接 scons 提供如下的 方法:PrependENVPath()AppendENVPath()env =环境(ENV = os.environ)env.PrependENVPath('PATH'，'/ usr / local / bin')env.AppendENVPath('LIB'，'/ usr / local / lib') 使用外部工具使用外部工具的时候 scons 默认的搜索路径:scons 内置工具目录Sconstruct 同级目录下/site_scons/site_tools/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Builtin tool or tool located within site_toolsenv = Environment(tools = ['SomeTool'])env.SomeTool(targets, sources)# The search locations would include by defaultSCons/Tool/SomeTool.pySCons/Tool/SomeTool/__init__.py./site_scons/site_tools/SomeTool.py./site_scons/site_tools/SomeTool/__init__.py也可以给 添加 除了 scons 默认搜索路径# Tool located within the toolpath directory optionenv = Environment(tools = ['SomeTool'], toolpath = ['/opt/SomeToolPath', '/opt/SomeToolPath2'])env.SomeTool(targets, sources)# The search locations in this example would include:/opt/SomeToolPath/SomeTool.py/opt/SomeToolPath/SomeTool/__init__.py/opt/SomeToolPath2/SomeTool.py/opt/SomeToolPath2/SomeTool/__init__.pySCons/Tool/SomeTool.pySCons/Tool/SomeTool/__init__.py./site_scons/site_tools/SomeTool.py./site_scons/site_tools/SomeTool/__init__.py嵌套工具# namespaced targetenv = Environment(tools = ['SubDir1.SubDir2.SomeTool'], toolpath = ['/opt/SomeToolPath'])env.SomeTool(targets, sources)# With this example the search locations would include/opt/SomeToolPath/SubDir1/SubDir2/SomeTool.py/opt/SomeToolPath/SubDir1/SubDir2/SomeTool/__init__.pySCons/Tool/SubDir1/SubDir2/SomeTool.pySCons/Tool/SubDir1/SubDir2/SomeTool/__init__.py./site_scons/site_tools/SubDir1/SubDir2/SomeTool.py./site_scons/site_tools/SubDir1/SubDir2/SomeTool/__init__.py使用 sys.path 作为扩展的工具路径# namespaced target using sys.path within toolpathimport syssearchpaths = []for item in sys.path: if os.path.isdir(item): searchpaths.append(item)env = Environment(tools = ['someinstalledpackage.SomeTool'], toolpath = searchpaths)env.SomeTool(targets, sources)你可以使用这个包 来避免使用 pip 安装包 拼接前面复杂的路径# namespaced target using sys.pathimport sysenv = Environment(tools = ['SomeTool'], toolpath = [PyPackageDir('tools_example.subdir1.subdir2')])env.SomeTool(targets, sources) 这次你了解 构造变量的这几个方法MergeFlags, ParseFlags, and ParseConfig methods of a construction environmentMergeFlags, ParseFlags ParseConfig ###123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172MergeFlags尝试合并某个构造变量 例子如下:env = Environment()env.Append(CCFLAGS = '-option -O3 -O1')flags = &#123; 'CCFLAGS' : '-whatever -O3' &#125;env.MergeFlags(flags)print env['CCFLAGS']&gt;&gt;&gt;&gt;scons -Q['-option', '-O1', '-whatever', '-O3']scons: '.' is up to date.env = Environment()env.Append(CPPPATH = ['/include', '/usr/local/include', '/usr/include'])flags = &#123; 'CPPPATH' : ['/usr/opt/include', '/usr/local/include'] &#125;env.MergeFlags(flags)print env['CPPPATH']&gt;&gt;&gt;&gt;scons -Q['/include', '/usr/local/include', '/usr/include', '/usr/opt/include']scons: '.' is up to date.如果我们这个方法传递的不是列表 scons 会自动调用 ParseFlags 将其解析成列表env = Environment()env.Append(CCFLAGS = '-option -O3 -O1')env.Append(CPPPATH = ['/include', '/usr/local/include', '/usr/include'])env.MergeFlags('-whatever -I/usr/opt/include -O3 -I/usr/local/include')print env['CCFLAGS']print env['CPPPATH']&gt;&gt;&gt;&gt;scons -Q['-option', '-O1', '-whatever', '-O3']['/include', '/usr/local/include', '/usr/include', '/usr/opt/include']scons: `.' is up to date.ParseFlags [ParseFlags](https://scons.org/doc/production/HTML/scons-user/ch08s02.html)讲一个有规律的字符串 解析成一个字典列表-I 指要包含的 源码路径-L 库文件的路径env = Environment()d = env.ParseFlags(\"-I/opt/include -L/opt/lib -lfoo\")for k,v in sorted(d.items()): if v: print k, venv.MergeFlags(d)env.Program('f1.c')支持递归输入 主要是看例子 和输出结果去理解这些东西, 这里官方也没有解释的太清楚 后面还得多去实践的真知env = Environment()d = env.ParseFlags([\"-I/opt/include\", [\"-L/opt/lib\", \"-lfoo\"]])for k,v in sorted(d.items()): if v: print k, venv.MergeFlags(d)env.Program('f1.c')&gt;&gt;&gt;&gt;% scons -QCPPPATH ['/opt/include']LIBPATH ['/opt/lib']LIBS ['foo']cc -o f1.o -c -I/opt/include f1.ccc -o f1 f1.o -L/opt/lib -lfooParseConfig这个东西没有看明白 这里先记录一下链接Finding Installed Library Information: the ParseConfig Function[ParseConfig](https://scons.org/doc/production/HTML/scons-user/ch08s03.html) 在构建程序的时候 帮助信息12345678910111213141516171819202122232425262728293031323334353637383940Help(\"\"\"Type: 'scons program' to build the production program, 'scons debug' to build the debug version.\"\"\", append=True)加上 append = True 在下面出现 `Use scons -H for help about command-line options.` 这样的字段&gt;&gt;&gt;&gt;scons -hscons: Reading SConscript files ...scons: done reading SConscript files.Type: 'scons program' to build the production program, 'scons debug' to build the debug version.Use scons -H for help about command-line options.你可以缩短的 命令输出 如下这种操作env = Environment(CCCOMSTR = \"Compiling $TARGET\", LINKCOMSTR = \"Linking $TARGET\")env.Program('foo.c')&gt;&gt;&gt;&gt;% scons -QCompiling foo.oLinking foo比如下面的例子 如果用户输入的 详细字段不为 True 则自定义 编译命令 其实是简短编译命令env = Environment()if ARGUMENTS.get('VERBOSE') != \"1': env['CCCOMSTR'] = \"Compiling $TARGET\" env['LINKCOMSTR'] = \"Linking $TARGET\"env.Program('foo.c')Progress 控制流程输出[Progress](https://scons.org/doc/production/HTML/scons-user/ch09s03.html)GetBuildFailures[打印详细的错误信息](https://scons.org/doc/production/HTML/scons-user/ch09s04.html) 从命令行控制构建流程传送门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219&gt;&gt;&gt;&gt; 如果你想使用者调用一些除了scons提供的指令,你可以这样做ARGUMENTS 这个东西将会帮到你.但是有个缺陷是不能存储两个值,只能 key-value 的形式.ARGUMENTS.get() 获取 debug 这个指令 没有用后面的默认值env = Environment()debug = ARGUMENTS.get('debug', 0)if int(debug): env.Append(CCFLAGS = '-g')env.Program('prog.c')ej:scons -Q debug=0&gt;&gt;&gt;&gt; 如果你想 一对多 你可以使用这个东西ARGLISTcppdefines = []for key, value in ARGLIST: if key == 'define': cppdefines.append(value)env = Environment(CPPDEFINES = cppdefines)env.Object('prog.c')ej: scons -Q define=FOO define=BAR&gt;&gt;&gt;&gt; 从文件中读取用户构建配置&gt;&gt;&gt;&gt; 会读取 custom.py 文件的配置表vars = Variables('custom.py')vars.Add('RELEASE', 'Set to 1 to build for release', 0)env = Environment(variables = vars, CPPDEFINES=&#123;'RELEASE_BUILD' : '$&#123;RELEASE&#125;'&#125;)env.Program(['foo.c', 'bar.c'])Help(vars.GenerateHelpText(env))&gt;&gt;&gt;&gt; custom.py&gt;&gt;&gt;&gt; RELEASE=1&gt;&gt;&gt;&gt; 可以结合 两种做法 读取用户 在命令行输入或则是配置文件&gt;&gt;&gt;&gt; 其中 本地配置文件会首先 覆盖 命令行 的 配置vars = Variables('custom.py',ARGUMENTS)&gt;&gt;&gt;&gt; 定义构造变量的函数&gt;&gt;&gt;&gt; Bool 可以指定的值有 true =&gt; t on all 1 true False =&gt; f 0 no falsevars = Variables('custom.py')vars.Add(BoolVariable('RELEASE', 'Set to build for release', 0))env = Environment(variables = vars, CPPDEFINES=&#123;'RELEASE_BUILD' : '$&#123;RELEASE&#125;'&#125;)env.Program('foo.c')ej:scons -Q RELEASE=yes foo.o&gt;&gt;&gt;&gt; Enum 有个 allowed_values 的字段 定义枚举变量值&gt;&gt;&gt;&gt; map 字段备用映射名 map=&#123;'navy':'blue'&#125;,&gt;&gt;&gt;&gt; ignorecase=1 忽略 指定指令的大小写 如 COLOR=NaVyvars = Variables('custom.py')vars.Add(EnumVariable('COLOR', 'Set background color', 'red', allowed_values=('red', 'green', 'blue')))env = Environment(variables = vars, CPPDEFINES=&#123;'COLOR' : '\"$&#123;COLOR&#125;\"'&#125;)env.Program('foo.c')ej: scons -Q COLOR=red&gt;&gt;&gt;&gt; ListVariable 允许一个字段指定多个值&gt;&gt;&gt;&gt; 允许使用 all 或则是 nonevars = Variables('custom.py')vars.Add(ListVariable('COLORS', 'List of colors', 0, ['red', 'green', 'blue']))env = Environment(variables = vars, CPPDEFINES=&#123;'COLORS' : '\"$&#123;COLORS&#125;\"'&#125;)env.Program('foo.c')ej: scons -Q COLORS=red,blue foo.o =&gt; cc -o foo.o -c -DCOLORS=\"red blue\" foo.cej: scons -Q COLORS=all foo.o =&gt; cc -o foo.o -c -DCOLORS=\"red green blue\" foo.cej: scons -Q COLORS=none foo.o =&gt; cc -o foo.o -c -DCOLORS=\"\" foo.c&gt;&gt;&gt;&gt; PathVariable 路径变量&gt;&gt;&gt;&gt; 提供输入的路径是文件 PathVariable.PathIsFile&gt;&gt;&gt;&gt; 是目录 PathVariable.PathIsDir&gt;&gt;&gt;&gt; 目录不存在,并创建 PathVariable.PathIsDirCreate&gt;&gt;&gt;&gt; 不关心上面的三点 PathVariable.PathAcceptej:vars = Variables('custom.py')vars.Add(PathVariable('CONFIG', 'Path to configuration file', '/etc/my_config', PathVariable.PathIsFile))env = Environment(variables = vars, CPPDEFINES=&#123;'CONFIG_FILE' : '\"$CONFIG\"'&#125;)env.Program('foo.c')&gt;&gt;&gt;&gt; PackageVariable&gt;&gt;&gt;&gt; 启用或禁止 路径名字 没有太懂vars = Variables('custom.py')vars.Add(PackageVariable('PACKAGE', 'Location package', '/opt/location'))env = Environment(variables = vars, CPPDEFINES=&#123;'PACKAGE' : '\"$PACKAGE\"'&#125;)env.Program('foo.c')ej:% scons -Q foo.occ -o foo.o -c -DPACKAGE=\"/opt/location\" foo.c% scons -Q PACKAGE=/usr/local/location foo.occ -o foo.o -c -DPACKAGE=\"/usr/local/location\" foo.c% scons -Q PACKAGE=yes foo.occ -o foo.o -c -DPACKAGE=\"True\" foo.c% scons -Q PACKAGE=no foo.occ -o foo.o -c -DPACKAGE=\"False\" foo.c&gt;&gt;&gt;&gt; AddVariables 一次性添加多个变量功能vars = Variables()vars.AddVariables( ('RELEASE', 'Set to 1 to build for release', 0), ('CONFIG', 'Configuration file', '/etc/my_config'), BoolVariable('warnings', 'compilation with -Wall and similiar', 1), EnumVariable('debug', 'debug output and symbols', 'no', allowed_values=('yes', 'no', 'full'), map=&#123;&#125;, ignorecase=0), # case sensitive ListVariable('shared', 'libraries to build as shared libraries', 'all', names = list_of_libs), PackageVariable('x11', 'use X11 installed here (yes = search some places)', 'yes'), PathVariable('qtdir', 'where the root of Qt is installed', qtdir),)&gt;&gt;&gt;&gt; UnknownVariables 在用户使用了未定义的 指令时 你可以警告调用者 拼写错误 并退出程序vars = Variables(None)vars.Add('RELEASE', 'Set to 1 to build for release', 0)env = Environment(variables = vars, CPPDEFINES=&#123;'RELEASE_BUILD' : '$&#123;RELEASE&#125;'&#125;)unknown = vars.UnknownVariables()if unknown: print(\"Unknown variables: %s\"%unknown.keys()) Exit(1)env.Program('foo.c')&gt;&gt;&gt;&gt; 你可以在用户使用某个命令的时候 提醒用户一些操作if 'bar' in COMMAND_LINE_TARGETS: print(\"Don't forget to copy `bar' to the archive!\")Default(Program('foo.c'))Program('bar.c')ej:% scons -Q barDon't forget to copy `bar' to the archive!&gt;&gt;&gt;&gt; Default() 用户没有指定构建是 可以使用 这个函数 默认 构建一个程序env = Environment()hello = env.Program('hello.c')env.Program('goodbye.c')Default(hello)ej: % scons -Q cc -o hello.o -c hello.c cc -o hello hello.o % scons -Q scons: `hello' is up to date. % scons -Q goodbye cc -o goodbye.o -c goodbye.c cc -o goodbye goodbye.oDefault 跟过用法 [传送门](https://scons.org/doc/production/HTML/scons-user/ch10s03.html)&gt;&gt;&gt;&gt; DEFAULT_TARGETS 主要是迎合上面 Default 函数, 看一下例子应该很容易理解prog1 = Program('prog1.c')Default(prog1)print(\"DEFAULT_TARGETS is %s\"%map(str, DEFAULT_TARGETS))ej:% sconsscons: Reading SConscript files ...DEFAULT_TARGETS is ['prog1']scons: done reading SConscript files.scons: Building targets ...cc -o prog1.o -c prog1.ccc -o prog1 prog1.oscons: done building targets.&gt;&gt;&gt;&gt; BUILD_TARGETSprog1 = Program('prog1.c')Program('prog2.c')Default(prog1)print (\"BUILD_TARGETS is %s\"%map(str, BUILD_TARGETS))ej:% scons -QBUILD_TARGETS is ['prog1']cc -o prog1.o -c prog1.ccc -o prog1 prog1.o% scons -Q prog2BUILD_TARGETS is ['prog2']cc -o prog2.o -c prog2.ccc -o prog2 prog2.o% scons -Q -c .BUILD_TARGETS is ['.']Removed prog1.oRemoved prog1Removed prog2.oRemoved prog2&gt;&gt;&gt;&gt; 产生帮助文档(help)vars = Variables(None, ARGUMENTS)vars.Add('RELEASE', 'Set to 1 to build for release', 0)env = Environment(variables = vars)Help(vars.GenerateHelpText(env)) InstallBuilder 安装构建的可执行程序安装暂时没有 显示功能上需求就不做详细叙述了传送门 与平台无关的文件操作scons 封装了 与平台无关的文件操作如: 拷贝(copy),移动(move),移除(delete),创建(touch),创建目录(mkdir),执行(execute)传送门WWW 控制构建目标的移除12345678910111213141516171819202122&gt;&gt;&gt;&gt; 有的时候你想要在每次构建一个东西的时候,不清除上一次的构建,而是以增量的方式构建&gt;&gt;&gt;&gt; Preciousenv = Environment(RANLIBCOM='')lib = env.Library('foo', ['f1.c', 'f2.c', 'f3.c'])env.Precious(lib)&gt;&gt;&gt;&gt; 有的时候你可能使用 scons -c 但是这个命令会将所有的构建产物都移除掉,你可以使用这个命令,保证有些东西不被 -c 指令 给移除掉&gt;&gt;&gt;&gt; NoCleanenv = Environment(RANLIBCOM='')lib = env.Library('foo', ['f1.c', 'f2.c', 'f3.c'])env.NoClean(lib)&gt;&gt;&gt;&gt; Clean 有的时候你可能 清楚自己在产生过程中生成的 自定义文件 你可以这样做t = Command('foo.out', 'foo.in', 'build -o $TARGET $SOURCE')Clean(t, 'foo.log')ej:% scons -Qbuild -o foo.out foo.in% scons -Q -cRemoved foo.outRemoved foo.log 分级构建分级构建,就是你的源文件可能不是一个目录,需要多一个目录构建.传送门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt;&gt;&gt;&gt; SConscript 根目录调用每个子目录的 构建脚本, 通常子目录的构建脚本叫 SConscript 这是官方的解释SConscript(['drivers/display/SConscript', 'drivers/mouse/SConscript', 'parser/SConscript', 'utilities/SConscript'])&gt;&gt;&gt;&gt; 通常里面的路径都是相对于当前这个构建脚本 如果你先让子构建脚本 使用顶级目录你可以这样做 加上 '#' 这个符号env = Environment()env.Program('prog', ['main.c', '#lib/foo1.c', 'foo2.c'])&gt;&gt;&gt;&gt; 当然你也可以直接使用绝对路径 不需要加任何符号&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; 你可以在多个构建脚本共享变量 你可以使用 Export Import 这两个方法ej:env = Environment()Export(env)or:env = Environment()debug = 10Export(env, debug)or:Export('env debug')or:SConscript('src/SConscript', 'env')or:SConscript('src/SConscript', exports='env')ej:Import(env)Import(env, debug)Import('env debug')Import('*')&gt;&gt;&gt;&gt; 有事你需要 从两个此目录返回结果 构建出一个对象env = Environment()Export('env')objs = []for subdir in ['foo', 'bar']: o = SConscript('%s/SConscript' % subdir) objs.append(o)env.Library('prog', objs)other Sconstruct(其他构建脚本): Import('env') obj = env.Object('foo.c') Return('obj')&gt;&gt;&gt;&gt; 分离构建 目标 和 源文件分离构建结果传送门1234567891011121314方式1:主要是利用这个字段 variant_dirSConscript('src/SConscript', variant_dir='build')禁掉在输出目录拷贝源文件SConscript（'src / SConscript'，variant_dir ='build'，duplicate = 0）方式2:VariantDir('build', 'src', duplicate=0)env = Environment()env.Program('build/hello.c')子脚本VariantDir('build', 'src')SConscript('build/SConscript') 变体构建传送门同一个目录构建不同的目标产物(可执行程序)1234567891011121314151617platform = ARGUMENTS.get('OS', Platform())include = \"#export/$PLATFORM/include\"lib = \"#export/$PLATFORM/lib\"bin = \"#export/$PLATFORM/bin\"env = Environment(PLATFORM = platform, BINDIR = bin, INCDIR = include, LIBDIR = lib, CPPPATH = [include], LIBPATH = [lib], LIBS = 'world')Export('env')env.SConscript('src/SConscript', variant_dir='build/$PLATFORM') 国际化传送门 编写自己的 builder(构造器)传送门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&gt;&gt;&gt;&gt; 创建构造器env = Environment()bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')env.Append(BUILDERS = &#123;'Foo' : bld&#125;)env.Foo('file.foo', 'file.input')env.Program('hello.c')or:env = Environment()bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')env['BUILDERS']['Foo'] = bldenv.Foo('file.foo', 'file.input')env.Program('hello.c')&gt;&gt;&gt;&gt; 指定构建的文件后缀 和 输出文件的后缀bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET', suffix = '.foo', src_suffix = '.input')env = Environment(BUILDERS = &#123;'Foo' : bld&#125;)env.Foo('file1')env.Foo('file2')&gt;&gt;&gt;&gt; 构建是调用 python 命令 target:A list of Node objects representing the target or targets to be built by this builder function. The file names of these target(s) may be extracted using the Python str function.(是一个目标节点列表,可通过 str 的方法 解析里面的内容)source:A list of Node objects representing the sources to be used by this builder function to build the targets. The file names of these source(s) may be extracted using the Python str function.(是一个源节点列表,可通过 str 的方法 解析里面的内容)env:The construction environment used for building the target(s). The builder function may use any of the environment's construction variables in any way to affect how it builds the targets.(这个构造变量被用在 目标节点上, 这个构造器可能使用任意的构造环境中的构造变量以任意的方式去影响如何构建目标节点)(这个解释可能有点绕,其实还是挺容易懂得,不是吗?)&gt;&gt;&gt;&gt; 自定义构建函数 上面是三个参数的解释, 很详细.def build_function(target, source, env): # Code to build \"target\" from \"source\" return Nonebld = Builder(action = build_function, suffix = '.foo', src_suffix = '.input')env = Environment(BUILDERS = &#123;'Foo' : bld&#125;)env.Foo('file')&gt;&gt;&gt;&gt; Generator 产生一条记录信息def generate_actions(source, target, env, for_signature): return 'foobuild &lt; %s &gt; %s' % (source[0], target[0])bld = Builder(generator = generate_actions, suffix = '.foo', src_suffix = '.input')env = Environment(BUILDERS = &#123;'Foo' : bld&#125;)env.Foo('file')&gt;&gt;&gt;&gt; Builders That Modify the Target or Source Lists Using an Emitter(修改目标节点或者是 源节点 通过发射器)bld = Builder(action = 'my_command $SOURCES &gt; $TARGET', suffix = '.foo', src_suffix = '.input', emitter = '$MY_EMITTER')def modify1(target, source, env): return target, source + ['modify1.in']def modify2(target, source, env): return target, source + ['modify2.in']env1 = Environment(BUILDERS = &#123;'Foo' : bld&#125;, MY_EMITTER = modify1)env2 = Environment(BUILDERS = &#123;'Foo' : bld&#125;, MY_EMITTER = modify2)env1.Foo('file1')env2.Foo('file2')&gt;&gt;&gt;&gt; 放置自定义工具或者是 构造器&gt;&gt;&gt;&gt; scons 会自动加载 site_scons/site_init.py 比任意一个 构建脚本都早&gt;&gt;&gt;&gt; site_scons/site_tools 在顶级的构建脚本是最后执行的 它覆盖其他的构建脚本定义&gt;&gt;&gt;&gt; site_scons/site_init.pydef TOOL_ADD_HEADER(env): \"\"\"A Tool to add a header from $HEADER to the source file\"\"\" add_header = Builder(action=['echo \"$HEADER\" &gt; $TARGET', 'cat $SOURCE &gt;&gt; $TARGET']) env.Append(BUILDERS = &#123;'AddHeader' : add_header&#125;) env['HEADER'] = '' # set default valueSConstruct# Use TOOL_ADD_HEADER from site_scons/site_init.pyenv=Environment(tools=['default', TOOL_ADD_HEADER], HEADER=\"=====\")env.AddHeader('tgt', 'src')site_scons/my_utils.pyfrom SCons.Script import * # for Execute and Mkdirdef build_id(): \"\"\"Return a build ID (stub version)\"\"\" return \"100\"def MakeWorkDir(workdir): \"\"\"Create the specified dir immediately\"\"\" Execute(Mkdir(workdir))import my_utilsprint(\"build_id=\" + my_utils.build_id())my_utils.MakeWorkDir('/tmp/work') 缓存构建的文件缓存构建文件其实就是将构建出来的中间产物给放到一个缓存目录里面,如果目录文件不存,就直接构建中间产物,在其下次构建是,就不必再次构建它,提高构建效率.传送门 12345678910111213141516171819202122232425&gt;&gt;&gt;&gt; 主要使用 CacheDir('./cache')&gt;&gt;&gt;&gt; scons -Q --cache-show 保持每次构建的显示命令都是一样, 不使用这个字段会出现如果在在缓存里面存在,就和没有时的输出不一样,问题.ej: % scons -Q cc -o hello.o -c hello.c cc -o hello hello.o % scons -Q -c Removed hello.o Removed hello % scons -Q --cache-show cc -o hello.o -c hello.c cc -o hello hello.o&gt;&gt;&gt;&gt; NoCache() 指定某些中间产物,不放入缓存ej: env = Environment() obj = env.Object('hello.c') env.Program('hello.c') CacheDir('cache') NoCache('hello.o')&gt;&gt;&gt;&gt; scons -Q --cache-disable 通过命令行禁掉 缓存&gt;&gt;&gt;&gt; scons -Q --cache-force 强制更新缓存&gt;&gt;&gt;&gt; scons -Q --random 随机缓存 或者是使用构建脚本设置 SetOption('random', 1)-- random 主要是面对多个程序通同时构建的情况. 让他的构建库的顺序尽量不一致,最小化减少缓存. 验证 python scons 版本EnsurePythonVersion(2, 5) 验证 python 版本 如果低于构建结束EnsureSConsVersion(1, 0) 验证 scons 版本 别名目标别名也没啥说的传送门1234env = Environment()hello = env.Program('hello.c')env.Install('/usr/bin', hello)env.Alias('install', '/usr/bin') 多平台配置（Autoconf功能主要是检查某些依赖的文件是否存在等等.传送门 从代码存储库构建传送门 编写扫描仪传送门 Not Writing a Builder: the Command Builder主要是自定义写构造器的简化版本传送门 Pseudo-Builders: the AddMethod function(伪造构建起, 添加方法)这个东西个自定义工具差不多传送门","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"c++","slug":"c","permalink":"https://leng521.top/tags/c/"},{"name":"scons","slug":"scons","permalink":"https://leng521.top/tags/scons/"}]},{"title":"scons自动构建工具","date":"2018-12-23T15:00:52.000Z","path":"/posts/79065537/","text":"这篇文章可能有点长,如果你想要学到一些知识,而不是简单入门,你要有耐心的看下去,当然在看的时候,也要自己思考,也许我写的有问题,这个时候你可以再去看看,官方文档.这个教程由于内容太多,有些还没来得及写.一般我这里不会太多的去,介绍它的历史,和它是干啥的,你可以自己去找度娘去了解.我这里只有逻辑和事例代码. 工具版本: 3.0.1scons user guide scons user guide scons 普通简单的构建123456789// file name main.cpp#include &lt;iostream&gt;int main(int argc, char const *argv[])&#123; using namespace std; cout&lt;&lt; \"helloworld\" &lt;&lt; endl; return 0;&#125; 12#!/usr/bin/env pythonProgram('main.cpp') 多个文件构建12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# 构建多个文件Program(['main.cpp','other.cpp'])# 使用 匹配 的方式选择构建的的文件# 可以使用 Glob()Program(Glob('*.cpp'))Glob() =&gt; 匹配的方式有个- * 通配符- ? 匹配任意一个字符- [abc] 匹配任意一个符- [!abc] 输了abc 之外的字符Split函数 scons为了方便可以使用 分割函数一空格分割同样做到 多文件编译Program(\"HelloWorld\",Split(\"main.c other.c\"))Program(\"HelloWorld\",Split(\"\"\" main.c other.c\"\"\"))允许使用 多行字符串scons 也可以使用指定参数的形式调用src_files = Split('main.c file1.c file2.c')Program(target = 'program', source = src_files)当然也可以反转参数src_files = Split('main.c file1.c file2.c')Program(source = src_files, target = 'program') Object 构建方法1234Object('main.c')在 POSIX 系统上产生 *.o 文件在 windows 系统上产生 *.obj 文件 清楚构建对中产生的对象1scons -c 让scons 简介输出1scons -Q 设置可执行文件的名字12345Program(\"HelloWorld\",\"main.cpp\")在构建目录下产生 名字叫 HelloWorld.exe 的可执行文件在 POSIX 系统上产生 HelloWorld 的可执行文件如果不在 第一个参数 指定 可执行文件的名字 那么将会使用 第一个文件的名字 为可执行程序的名字 构建多个可执行程序1234Program('H1',['main.c'])Program('H2',['main1.c'])只需要调用多遍 Program 这个构造器就行了 多个可执行程序 使用共同的源文件123456common = [\"common1.c\", \"common2.c\"]program1 = [\"pro1.c\"] + commonprogram2 = [\"pro2.c\"] + commonProgram(\"pro1\",program1)Program(\"pro2\",program2)) 构建 Library(库)从源文件中12345678910Library('haha',['main.c'])你可以混合构建最终的库 scons 可以识别出来那些需要编译 这个只会编译 main.cLibrary('haha',['main.c','common.o'])构建静态库StaticLibrary()构建动态库SharedLibrary() 链接库1234567891011121314LIBS =&gt; 指定要链接的库的名字LIBPATH =&gt; 要连接库名字的路径Library('foo', ['f1.c', 'f2.c', 'f3.c'])Program('prog.c', LIBS=['foo', 'bar'], LIBPATH='.')这里可以简写 如果是一个 直接写库名字 不需要写成使用 列表 包一层Library('foo', ['f1.c', 'f2.c', 'f3.c'])Program('prog.c', LIBS='foo', LIBPATH='.')多个库路径可以使用 如下格式['/home/libs','/home/gg/libs']'/home/libs:/home/gg/libs'(POSIX系统上的冒号：)'C:\\\\libs;C:\\\\gg\\\\libs'(Windows系统上的分号;) 构造其方法返回节点列表1234567891011121314这么做的目的是让我们写的 构建文件是平台的不同平台 编译后的文件后缀不一样(a.obj(Windows), a.o(Lunix)) 所以 scons 帮我们处理了返回节点列表 soncs 去处理这些差异hello_list = Object('hello.c', CCFLAGS='-DHELLO')goodbye_list = Object('goodbye.c', CCFLAGS='-DGOODBYE')Program(hello_list + goodbye_list)打印节点列表print(hello_list[0]) // hello.obj(Windows)判断文件是否存在if not os.path.exists(program_name): print('不存在') 清晰区分 目录节点 和 文件节点12345678hello_c = File('hello.c')Program(hello_c)目录节点Dir()不知道是 目录还是文件Entry() 从一个节点或字符串获取路径123env=Environment(VAR=\"value\")n=File(\"foo.c\")print(env.GetBuildPath([n, \"sub/dir/$VAR\"])) 重复构建 scons 可以识别出来 会出现 scons: `.’ is up to date. 指出已经是最新的了 自定义 Decider(‘MD5’) 自定义 重构规则 Decider(‘MD5’) 默认是使用 md5 记录一个文件是够需要从新构建甚至 可以使用 ‘content’ 代表同名词 md5 的缺陷是 如果修改了注释 scons 也认为 没有修改Decider(‘make’) 只要文件的修改时间改变就从新构建 同义词 ‘timestamp-newer’(判定规则是 比上次构建的时间戳新 就从新构建 但是有的使用会碰到 文件还原 这样就会出现 之前构建的时候 比 现在的 新 下面的 记录规则 可以解决这个问题)‘timestamp-match’ 匹配时间戳是否与构建的时候一样,‘MD5-timestamp’ 判定规则是 MD5 和 时间错都改变的时候 在重新构建 (如果在SCons构建文件的最后一秒内修改了源文件 这种情况可能不合适, 但是基本可能不存在) 编写自定义Decider函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Program('hello.c')def decide_if_changed(dependency, target, prev_ni): if self.get_timestamp() != prev_ni.timestamp: dep = str(dependency) tgt = str(target) if specific_part_of_file_has_changed(dep, tgt): return True return FalseDecider(decide_if_changed)展开第三个参数params : prev_ni : .csig The content signature, or MD5 checksum, of the contents of the dependency file the list time the target was built. .size The size in bytes of the dependency file the list time the target was built. .timestamp The modification time of the dependency file the list time the target was built.当第一次构建的时候 这个参数 prev_ni 不存在读这些东西的时候需要静心观看 不然就可能看不懂呦env = Environment()def config_file_decider(dependency, target, prev_ni): import os.path # We always have to init the .csig value... # 获取依赖文件的签名信息 dep_csig = dependency.get_csig() # .csig may not exist, because no target was built yet... if 'csig' not in dir(prev_ni): return True # Target file may not exist yet if not os.path.exists(str(target.abspath)): return True if dep_csig != prev_ni.csig: # Some change on source file =&gt; update installed one return True return Falsedef update_file(): f = open(\"test.txt\",\"a\") f.write(\"some line\\n\") f.close()update_file()# Activate our own decider functionenv.Decider(config_file_decider)env.Install(\"install\",\"test.txt\")不同的环境使用不同 判定规则env1 = Environment(CPPPATH = ['.'])env2 = env1.Clone()env2.Decider('timestamp-match')env1.Program('prog-MD5', 'program1.c')env2.Program('prog-timestamp', 'program2.c') 隐式构造变量123456789/* main.c */#include &lt;hello.h&gt;int main()&#123; printf(\"Hello, %s!\\n\", string);&#125;/* hello.h */#define string \"world\" 123456# SconsturctProgram('hello.c', CPPPATH = '.')也可以是多个 路径 也可以像 LIBPATH 那样Program('hello.c', CPPPATH = ['include', '/home/project/inc'])Window 分割符是 分号 (;) Linux 分隔符是 冒号(:)Program('hello.c', CPPPATH = 'include:/home/project/inc') 缓存隐式依赖关系1SetOption（'implicit_cache'，1） 或则是使用命令行 scons -Q –implicit-cache scons -Q –implicit-deps-changed 通知 scons 跟新隐式缓存 依赖的文件改变时 scons -Q –implicit-deps-unchanged 强制及时依赖的文件改变时 仍然使用 缓存依赖 显示依赖关系有的时候 scons 没有扫描(detected)到依赖关系的时候 scons 允许你 显示指定 依赖关系 12345678hello = Program('hello.c')Depends(hello, 'other_file')Depends 的第二个参数 也可以是节点 列表hello = Program('hello.c')goodbye = Program('goodbye.c')Depends(hello, goodbye) 外部文件的依赖关系：ParseDepends 功能123456#define FOO_HEADER &lt;foo.h&gt;#include FOO_HEADERint main() &#123; return FOO;&#125; 上面这种情况 scons 可能无法 知道依赖关系 1234obj = Object('hello.c', CCFLAGS='-MD -MF hello.d', CPPPATH='.')SideEffect('hello.d', obj)ParseDepends('hello.d') Program('hello', obj) 借助编译器 对宏的展开 并生成一个 .d 的文件 第一次 scons 无法检测依赖 第二次 scons 可以根据生成的 .d的文件确定依赖关系 忽略依赖项12345678910111213hello_obj=Object('hello.c')hello = Program(hello_obj)Ignore(hello_obj, 'hello.h')上面的例子可能很难想象 它依赖的头文件 改变了 不从新编译有一种情况 比如多个系统 使用同一个 头文件 每个系统的头文件 会有略微的差异此时依赖的头文件改变了 但是不需要重新编译hello = Program('hello.c', CPPPATH=['/usr/include'])Ignore(hello, '/usr/include/stdio.h')hello_obj=Object('hello.c')hello = Program(hello_obj)Ignore('.',[hello,hello_obj]) AlwaysBuild12hello = Program('hello.c')AlwaysBuild(hello) 构造环境feature的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107创建新的 构造环境env = Environment()一个简单的例子 设置 c编译器 env = Environment(CC = 'gcc', CCFLAGS = '-O2') env.Program('foo.c')访问构造环境的各个变量 (它是个具有关联方法的对象)env = Environment()print(\"CC is: %s\"%env['CC'])如果你仅仅是访问他的构造变量,你可以这样做 调用构造环境的 Dictionary 方法env = Environment(FOO = 'foo', BAR = 'bar')dict = env.Dictionary()for key in ['OBJSUFFIX', 'LIBSUFFIX', 'PROGSUFFIX']: print(\"key = %s, value = %s\" % (key, dict[key]))on Windows &gt; OBJSUFFIX =&gt; .obj LIBSUFFIX =&gt; .lib PROGSUFFIX =&gt; .exeon Linux &gt; OBJSUFFIX =&gt; .o LIBSUFFIX =&gt; .a PROGSUFFIX =&gt; 获取构造环境中的变量 方法2使用 subst() 方法 使用 $ + 变量字段 的方式访问使用这个方法的好处是 它可以将构造变量展开env = Environment()print(\"CC is: %s\"%env.subst('$CC'))# $CCCOM处理 变量 展开带来的问题如果访问一个不存在的变量是 scons 并不会报错 如果想要报错你可以这样做AllowSubstExceptions() 开始 使用 subst 函数异常的功能 这是个全局变量除了定义默认的异常外 还可以定义 其他异常如 零除异常AllowSubstExceptions(IndexError, NameError, ZeroDivisionError)env = Environment()print(\"value is: %s\"%env.subst( '-&gt;$&#123;1 / 0&#125;&lt;-' ))创建默认的 构造环境 可以设置 目标编译器DefaultEnvironment(CC = '/usr/local/bin/gcc')当然也可以这样做env = DefaultEnvironment()env['CC'] = '/usr/local/bin/gcc'使用 DefaultEnvironment() 可以加快你初始化构造变量在初始化时 scons 会在 系统的环境变量中搜索 可用的 编译器 连接器等 你可以指定 搜索的 工具 加快scons的初始化速度 你可以这样做直接指定 编译工具 链接工具 指定 c编译器 为gccenv = DefaultEnvironment(tools = ['gcc', 'gnulink'], CC = '/usr/local/bin/gcc')多构造环境 你可以这样做 不同的构造环境 使用不同的配置opt = Environment(CCFLAGS = '-O2')dbg = Environment(CCFLAGS = '-g')opt.Program('foo', 'foo.c')dbg.Program('foo', 'foo.c')--------------------------------------产生编译产物 *.obj(on Windows)opt = Environment(CCFLAGS = '-O2')dbg = Environment(CCFLAGS = '-g')o = opt.Object('foo-opt', 'foo.c')opt.Program(o)d = dbg.Object('foo-dbg', 'foo.c')dbg.Program(d)克隆当前的环境变量克隆一份一模一样的构造环境env = Environment(CC = 'gcc')opt = env.Clone(CCFLAGS = '-O2')dbg = env.Clone(CCFLAGS = '-g')env.Program('foo', 'foo.c')o = opt.Object('foo-opt', 'foo.c')opt.Program(o)d = dbg.Object('foo-dbg', 'foo.c')dbg.Program(d)替换构造环境env = Environment(CCFLAGS = '-DDEFINE1')env.Replace(CCFLAGS = '-DDEFINE2')env.Program('foo.c')仅在尚未定义的情况下设置值env.SetDefault(SPECIAL_FLAG = '-extra-option')附加到构造变量末尾env = Environment(CCFLAGS = ['-DMY_VALUE'])env.Append(CCFLAGS = ['-DLAST'])env.Program('foo.c')附加唯一值Some times it's useful to add a new value only if the existing construction variable doesn't already contain the value. This can be done using the AppendUnique method:官方解释: 有时 它是有用的 在这个构造变量没有包含这个变量的时候添加一个新值 , 这样可以使使用这个 方法做env.AppendUnique(CCFLAGS=['-g'])In the above example, the -g would be added only if the $CCFLAGS variable does not already contain a -g value.解释: 在上面这个例子, -g 标识将被添加 仅仅这个 $CCFLAGS 变量曾没有包含这个 -g 的标识附加到值的开头env = Environment(CCFLAGS = ['-DMY_VALUE'])env.Prepend(CCFLAGS = ['-DFIRST'])env.Program('foo.c')附加唯一值到开头 和上面在结尾附加值 的 逻辑是一样的env.PrependUnique（CCFLAGS = [ ' - G']）","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"c++","slug":"c","permalink":"https://leng521.top/tags/c/"},{"name":"scons","slug":"scons","permalink":"https://leng521.top/tags/scons/"}]},{"title":"cocos2dx-JS-OC-Java互相调用","date":"2018-12-15T02:21:49.000Z","path":"/posts/41d43874/","text":"cocos2dx js java oc 和 js 的相互调用引擎版本: 3.17语言: jsXcode: 10.1AndroidStudio: 3.2.1时间: 2018年12月14日16:23:47 看这篇文章需要 会一些 android java oc ios 的一些知识的基础 不然看着可能有点费劲. js调用javajs 调用 java java中声名的方法需要是静态方法(static method) Android 平台下123456if(cc.sys.os == cc.sys.OS_ANDROID)&#123; jsb.reflection.callStaticMethod('类名加全路径','方法名字','方法的签名','传递参数');&#125;ej: js jsb.reflection.callStaticMethod('org/cocos2dx/javascript/AppActivity','getStrVdong','(Ljava/lang/String;)V','haha'); 1234567891011121314ej: javapublic static void getStrVdong(String str) &#123; log.i('cocso2dx-js js call java', str);&#125; 其他方法签名的写法ej: (Ljava/lang/String;)V //参数是字符串 没有返回值 (I)V // void(int); ()V // void(); (IZ)V // void(int,boolean); (IZ)Z // boolean(int,boolean); ()Ljava/lang/String; //String(); 支持传递的数据类型 Z 布尔 I int F float 字符串 Ljava/lang/String; 注意这里有个字符串是有个分号的 java调用jsjava调用js 实际是 将字符串转成 function 然后调用 12345678910111213141516/* 导入需要的包 */import org.cocos2dx.lib.Cocos2dxJavascriptJavaBridge;import org.cocos2dx.lib.Cocos2dxHelper;/*这里需要注意的是调用 js 代码需要运行在 GL 线程中这里实现的逻辑是 将回调的逻辑移交到 js 代码层中, 这样就可以在 js 中 写逻辑 java 在合适的时机去执行这个调用 比如在做支付的时候 需要在之后响应后在 做游戏逻辑的处理.*/public static void callFuncVdong(final String code) &#123; Cocos2dxHelper.runOnGLThread(new Runnable()&#123; @Override public void run() &#123; Cocos2dxJavascriptJavaBridge.evalString(code); &#125; &#125;);&#125; 123456789/*写一下 js 调用的例子*/ej: jsb.reflection.callStaticMethod( \"org/cocos2dx/javascript/AppActivity\", \"callFuncVdong\", \"(Ljava/lang/String;)V\", \"g_funcList.callFunc()\"); /*呼叫一个全局函数*/ 问题记录js调用 java 没反应 有很大的几率是 js调用中 方法签名没有写正确 你需要检查你的写法 具体的写法上面有写的. js 调用 ocjs 调用 oc 其实和 Java的写法是大同小异的 在 ios/AppController.h 中声名 静态函数 1+(NSString *) showVdong:(NSString *)str title:(NSString *)tit; 在 ios/AppController.mm 文件中实现 123456789@implementation// 在这个之间实现函数+(NSString *) showVdong:(NSString *)str title:(NSString *)tit &#123; return @\"haha\";&#125;@end js 调用用例 1234if(cc.sys.os == cc.sys.OS_IOS || cc.sys.os == cc.sys.OS_OSX) &#123; var ret = jsb.reflection.callStaticMethod(\"AppController\",\"showVdong:title\",\"你是谁???\",\"天呢\"); cc.log('****************',ret);&#125; oc 调用 js 在 ios/AppController.mm 文件中实现 12345678#include \"cocos/scripting/js-bindings/manual/ScriptingCore.h\"+(NSString *) showVdong:(NSString *)str title:(NSString *)tit &#123; ScriptingCore::getInstance()-&gt;evalString(\"test\"); return @\"haha\";&#125; js 中的测试用例 123var test = function() &#123; cc.log(\"OC call JS success !!!\");&#125; 参考地址(这个是CocosCreator原生游戏调用) &gt; https://www.cnblogs.com/billyrun/articles/8529503.html","tags":[{"name":"cocos2d-x","slug":"cocos2d-x","permalink":"https://leng521.top/tags/cocos2d-x/"}]},{"title":"AndroidStudio打包Cocos2dx","date":"2018-12-08T03:05:57.000Z","path":"/posts/a2412c06/","text":"前几天闲着没事,去弄了一下AndroidStudio打包最新版 cocos2dx 系列原生平台的安装包. 引擎版本: 3.17AndroidStudio版本: 3.2.1SDK: 27NDK: android-ndk-r16bgradle: 4.1 首先提供这几个下载地址,有的可能需要翻墙,这个你们自己解决. gradleandroid sdk android studio 自带有下载的管理器anroid ndkandroid studiococos2dx-系列 报错记录Gradle sync failed: SSL peer shut down incorrectly 查这个路径下 gradle–&gt;wrapper–&gt;gradle-wrapper.properties 要下载 gradle 版本 ej:distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip gradle下载地址 删除原先的资源 存放到下面路径下 C:\\Users\\Administrator.gradle\\wrapper\\dists\\gradle-4.1-all\\bzyivzo6n839fup2jbap0tjew 记住一定要放到这个乱码的文件夹中 如果上面的步骤你你把android随机生成的文件夹(bzyivzo6n839fup2jbap0tjew) 删了 你可以执行下面的步骤 D:\\pro\\cocos_pro\\testCocosJs\\frameworks\\runtime-src\\proj.android\\gradlew.bat 执行这个脚本也可以. 执行你这里面的这个预处理脚本,它会重新生成一个类似于上面个文件夹,不要希望这个脚本能够下载好你想要的 gradle 版本.这会很慢,可以直接停掉这个批处理.执行这一步的目的是为了生成 上面类似的文件夹(bzyivzo6n839fup2jbap0tjew). 当然如果你有更好的方案也可以. No cached version of com.android.tools.build:gradle:3.0.0 available for offline mode. File/setting/build…/gradle/Offline work 禁掉 如果 gradle 同步的很慢可以使用 镜像工程 替换proj.adnroid/build.gradle 中的地址替换为镜像库 maven { url ‘https://maven.aliyun.com/repository/google&#39; } maven { url ‘https://maven.aliyun.com/repository/jcenter&#39; } maven { url ‘http://maven.aliyun.com/nexus/content/groups/public&#39; } 我这个下面有截图 官方提供的打包配置 地址 官方打包配置 No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 在 ndk 的根目录里面有个 toolchains 的文件夹 里面没有 这个文件 mips64el-linux-android 原因是我用的是 r18 的 但是那里面没有这个东西,我去使用r16 里面就有这个东西. ndk r9 下载路径 提供一下r9的下载路径 因为之前打包 3.15 是用的是 r9 所以这里记录一下地址 防止后面找不到了, 上面ndk 归档 只是到了 r10. NDK r9d： r9-x86-windowr9-x86_64-window[r9-x86-mac]http://dl.google.com/android/ndk/android-ndk-r9d-darwin-x86.tar.bz2（Mac环境）r9-x86-linuxr9-x86_64-linuxr9d-cxx-stl-libs-with-debug-info 配置NDK 环境变量 ANDROID_NDK_ROOT 编译externalNativeBuildDebug出错 可能出现路径太长导致 文件 查找失败(win10)下面路径有个大神写了个补丁. [修复ndk打包长路径查找失败]https://discuss.cocos2d-x.org/t/the-solution-of-ndk-compile-system-longpaths-issue-on-windows-platform/42705 这个打包记录是纯净的打包没有介入任何 sdk(如,微信的sdk facebook 第三方广告平台(admob) 等); 我的每篇文章都不希望写的太长,不然看着都烦人. 这里之所以记录时间是为了 提醒一下 阅读者这里也许不是最新的,如果已过很长时间,那就给你提供,经验的借鉴吧. 时间: 2018年12月7日22:28:49","tags":[{"name":"cocos2d-x","slug":"cocos2d-x","permalink":"https://leng521.top/tags/cocos2d-x/"},{"name":"android studio","slug":"android-studio","permalink":"https://leng521.top/tags/android-studio/"}]},{"title":"记录TweenLite库","date":"2018-11-21T13:45:42.000Z","path":"/posts/90e70f70/","text":"今天主要记录一下 TweenLite 这个补间动画库,他们的官方地址TweenLite官方网址 库版本是:2.0.2 这里面有几个文件可以使用 TweenLite TimelineLite TweenlineMax TweenMax 我这里就简单说一下这几个文件都做了什么事情,说先说明一下我这里主要研究跟 CocosCreator 相关的功能,它里面还有一些关于h5的东西,感兴趣的可以了解一下. 讲解每个文件的功能TweenLite这个是 Tween 动画的基础库, 所有的其他更丰富的功能都是在这个基础上封装的. 里面主要使用1TweenLite.to(target:Object, duration:Number, vars:Object) 第一个是操作的对象,第二个是执行的时间,第三个是要进行补间的属性. 首先你们要导入这个文件(TweenLite.js)你下载的文件里面应该是有个压缩后的文件 (TweenLite.min.js) 这个更省空间 例如如下的例子123456789import TweenLite from \"TweenLite.min\"function main() &#123; TweenLite.to(this.node,2,&#123;x:100,y:\"+=100\",rotation:45,opacity:\"+=255\",onComplete:()=&gt;&#123; console.log('执行结束'); &#125;&#125;);&#125;main(); 上面这个例子是 让一个node 同时执行 位置, 旋转 和透明度的 变换,这种写法要比 CocosCreator 的那套 Action 要简洁 其他的 API 我就捡着几个重要的说一下吧,其他的你们可以看一下他们的官文文档讲解的很清楚 主要说第三个参数12345678910111213&#123; x:100,// 跑到当前坐标系下 x=100 的位置 y:\"+=100\", // 自身值 增加100 ..., onStartParams:['123'], onStart:(p1)=&gt;&#123;console.log(p1)&#125;,// 输出 123 在这个动画开始执行的时候调用 onCompleteParams:['123'], onComplete:(p1)=&gt;&#123;console.log(p1)&#125;,// 输出入123 在这个动画结束的时候调用 onReverseComplete:()=&gt;&#123;&#125;, // 调用翻转函数的说 这个动画结束后 会调用 delay:2,// 开始延时 ease: Elastic.easeOut, // 要使用这东西要导入 easeing 文件下的那个 easePack.js 文件&#125; 调用TweenLite.to 函数的时候是会去返回一个对象的, 在这个补间动画库中 使用的是链式(chain)调用, 这个对象使用几个 api 的 pause 暂停当前的动画play 播放当前动画resume 恢复当前动画reverse 在任意时间都可以调用这个 翻转函数 翻转当前动画restart 从新开始progress 它的取值区间是[0,1] 指定当前动画处开始播放seek 跳转到指定位置 和 progress 函数有点相似 这个指的是时间的位置点 例子如下1234567891011121314import Ease from \"EasePack.min\";import TweenLite from \"TweenLite.min\"let tl = TweenLite.to(this.node,2,&#123; x:100, ease: Elastic.easeOut&#125;);tl.play();tl.pause();tl.resume();tl.restart();tl.progress(0.5);tl.seek(0.5);tl.progress(0.5).pause(); 因为他是链式调用所以 最后一个的写法是不会报错的.你们要是想要使用 ease 这个属性的话 是需要将 EasePack.min.js 导入到工程中 不需要在代码中导入, 至于为什么可以自己去看他们 uncompressed 文件下对应的代码文件. 后面那三个文件都是在这个基础上扩展的所以需要理解这个文件的用法. TweenLite 还有其他的几个静态函数 TweenLite.to TweenLite.from TweenLite.fromTo 用法比较的简单看文档也就可知道了. TimelineLite看这个名字凭字面上的意思是 时间线 也可以理解成 时间轴,看官方文档解释是他可以形成一个队列,就是说你可以组成一个动画列表一次播放. 例子如下123456import TimelineLite from \"TimelineLite.min\"let tl = new TimelineLite();// 创建一个新实例对象tl.to(this.node,2,&#123;x:\"+=100\"&#125;).to(this.node,2,&#123;y:\"+=100\"&#125;); 这个就是创建了一个动画队列,让一个物体向x轴正方向移动100像素, 然后在向y轴正方向移动100像素. 里面的参数配置和 TweenLite 里面的配置是一样的. 他提供了 TweenLite对象的嵌套 同时也支持 Timeline 的嵌套 为什么这么说看下面的例子 12345678910111213141516import TimelineLite from \"TimelineLite.min\";import TweenLite from \"TweenLite.min\";let tl = new TimelineLite();// 创建一个新实例对象tl.to(this.node,2,&#123;x:\"+=100\"&#125;).to(this.node,2,&#123;y:\"+=100\"&#125;);let tl1 = new TimelineLite();tl1.add(TweenLite.to(this.node,2,&#123;x:\"+=100\"&#125;));tl1.add(TweenLite.to(this.node,2,&#123;y:\"+=100\"&#125;));let tl2 = new TimelineLite();tl2.to(this.node,2,&#123;x:\"+=100\"&#125;);tl1.append(tl2); 这里面 to 和 add 的功能效果都是一样的 可以看到 add 里面是个 TweenLite 对象 所以 TimelineLite是维护 TweenLite每个对象进而形成 一个队列 TimelineLite 还有其他的用 入 addLabel 等函数,看他们解释和代码例子很容易懂 TimelineMax是对 TimelineLite 进行的扩展 主要扩展 使用 加入 repeat repeatDelay yoyo currentLabel(), addCallback(), removeCallback(), tweenTo(), tweenFromTo(), getLabelAfter(), getLabelBefore(), getActive(). 如果上面额功能不能满足你们项目的需求可以再去用 TimelineMax 这个更强大额 扩展包. TweenMaxTweenMax 是对 TweenLite 的扩展, 也加入 repeat(), repeatDelay(), yoyo() 等等, 而且看他们未压缩的 代码 好像这个文件是可以不要依赖 其他三的,因为他把其他三个都压缩到这个文件里面了,但是相应的文件的大小也增加了,同时也集成了一些扩展插件. 你们的项目如果对 代码的大小没有太高的要求的话,你们可以去直接导入这个TweenMax.min.js 这个文件. 上面讲了这么多也只是个入们吧,这个库里面还封装了一些很多有趣的东西,你们可以去多了解了解. 这里使用这个库去替代 CocosCreator 的 Action 主要是 api 使用灵活, 写法简单,运行速度也很快. 也有一些 Action 所不具有的动能 入随时翻转,控制动画流程,暂停动画等等,随机点开始播放动画,时间轴交叉等. 好了,今天就先到这里.写作不易,且行且珍惜. 我是小魏. 时间:2018年11月21日17:16:36.","tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"},{"name":"TweenLite","slug":"TweenLite","permalink":"https://leng521.top/tags/TweenLite/"}]},{"title":"QQ玩一玩打包","date":"2018-10-30T14:45:53.000Z","path":"/posts/dd666e1a/","text":"今天主要纪录最近对 QQPlay(玩一玩)打包的纪录. 然后这里只是纪录我目前使用的引擎(Cocos Creator version 2.x.x),精力有限. QQPlay官方文档 大纲1. 玩一玩包体中缺少`Utils`文件 2. 怎么读取最新的 bricks 引擎 3. 解决 xcode 打包到手机过程中出现的错误 4. 空泛讲解整个玩一玩上传流程 5. 避免上传后台而实时跟新 android 机里面的逻辑为最新 6. 实现厘米秀大部分功能 7. 关于获取每个游戏用户的 openkey 的获取问题 未完待续厘米秀游戏性能审核标准自建后台 前后端需要注意什么审核前游戏应该准备些什么玩一玩后台需要的一些配置 玩一玩包体中缺少Utils文件在你上传厘米秀后台的时候如果只是单纯使用Cocos Creator 发布QQPlay 平台的时候,在 ~/build/qqplay/libs/element/ 这个路径下缺少一个 Utils.js 的脚本文件 但是引擎团队在2.x.x 版本中 还一直没有修复这个问题,原因在 ~/build/qqplay/libs/qqplay-adapter.js 中又引入过这个文件.在论坛中搜到的解决方案是 将 qqplay-adapter.js 脚本中的这一行代码注释掉,这个在前期没用到对应功能的时候不会报错,但是等用到Utils.js 里面的功能是就会发现会再次报错. 报错的原因:加载远程图片会使用 libs/element/HTMLImageElement.js 脚本 解决方案: 使用CocosCreator(1.x.x) 版本随便打包个 QQPlay 平台,将其中的Utils.js粘到当前工程中 的 ~/build/qqplay/libs/element/ 目录中 修改Utils.js中对其他库的引用路径(CocosCreator(2.x.x)中将第三方引来的脚本归类到~build/qqplay/libs/other/这个目录下了), 修改的点如下: 建立一个和 ~/build 同级的目录(build-templates) 将上一步的 Utils.js文件也复制一份到 ~/build-templates/qqplay/libs/element/ 中, 类似于下面的这样 (这样做的目的是可以每次构建的时候,打的玩一玩的包都含有 Utils.js 脚本); 1.9.3 打包的 Utils.js 脚本 可以参考 这里面我已经修改过了,可以直接使用. 怎么读取最新的 bricks 引擎下面这是引擎团队的说法 和 玩一玩官方文档的说法玩一玩 官方说法 需要科学上网bitbucket官网解决方案: 登录官网注册账号 将自己的账号发给 `hudong@tencent.com邮件的主题写引擎申请权限`等待大概 4 天左右 腾讯的相关工作人员会给你这个账号添加权限,你就可以试试获取最新的xcode工程 10.25 玩一玩官网 给出了 bricks 引擎的下载地址,也就是说你可以不用申请了bricks XCode 工程bricks 下载页面 解决 xcode 打包到手机过程中出现的错误这里主要是 苹果签名 出的错误这里面 会有 详细的 解决方案(我不想重复造轮子)解决打包签名报错问题他这里面用的是 将 com.tencent.PublicBrickEngineGame 修改为 com.test.PublicBrickEngineGame 你会发现还是报错 ,,, 那就将 test 修改为被人很难想到的名字就行了 ,,, 然后 try again 空泛讲解整个玩一玩上传流程 引擎打包 QQPlay 平台的包 修复引擎包内缺少的文件 gameConfig.json 里面需要的填充的内容如下 gameConfig.json|官方解释地址 在你调试期间可以先 不把 构建面板的 MD5 开始 , 这样你可以,先将 gameConfig.json 放入到 ~/build-templates/qqplay/ 中 ,,, 测试完毕后将 MD5 开启, 然后打正式包的时候需要手动填充 gameConfig.json 文件.gameConfig.json 内容如下: 在后台创建测试版 避免上传后台而实时跟新 android 机里面的逻辑为最新参考文档这个讲解的也很详细 ,,, 我就不重复造轮子了. 我到现在都还不知道怎么看 log 哪位大神知道 可以在下面评论 我加 QQ ,, 请教请教. 实现厘米秀大部分功能参考文章官方文档程序员主要是一些细节,,,可能会困扰你,这里我就不说啥了,,,官方也提供的挺详细的,,,你也可以借鉴.我这里在提供一份我封装好的 里面(获取 openId, 获取QQ名字, 获取QQ头像地址, 分数上传, 获取好友分数排行榜, 各个时间点的绑定, 公众号跳转, 分享, 分享链接, 生成快捷方式传参, 储存/读取个人云端数据,存储游戏数据到本地,获取openkey,创建 banner广告, 创建激励视频广告, Post 请求)还有一些功能 未完成(暂时项目没有需求就写, 后面会持续更新); 关于获取每个游戏用户的 openkey 的获取问题获取 openkey 是验证当前用户是否是手Q环境,,,避免有些模拟请求,,,使其更安全. 这个 openkey 比较的坑,,, 这是官方文档你会发现 这里面 没啥 这个 game.json 是个啥东西,,, needOpenkey 又是个啥 ,,, 然后点击游戏上架章节 嗯哼 Not Found ,,, 于是 又去找了找,你会发现这里还有点提示信息 到最后也没说 到底要放在哪里? 解决方案:在和gameConfig.json 同目录里面 创建一个 game.json 文件 里面内容为123&#123; \"needOpenkey\": 1&#125; 然后随同到包内. 然后就是调用12345BK.QQ.fetchOpenKey(function (errCode, cmd, data) &#123; if (errCode == 0) &#123; var openKey = data.openKey; &#125;&#125;); 这个借口去获取用户的 openkey","tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"},{"name":"QQ玩一玩","slug":"QQ玩一玩","permalink":"https://leng521.top/tags/QQ玩一玩/"}]},{"title":"微信小游戏记录长连接(websocket)","date":"2018-09-15T02:55:43.000Z","path":"/posts/ba881459/","text":"哎,距离上次写博客竟然一个月了,真是时间不等人呀,好了废话不多说,直接进入正题.今天主要记录这几个问题: websocket 端口问题, http(短连接) 端口问题, 由于公司的云服务器都是使用的是阿里云,但是小游戏是腾讯的,腾讯云又推出了一堆有利于小游戏的服务,但是我们用不来了,那就自己去解决里面会遇到的问题, websocket 端口问题在微信小游戏里面所有用户的逻辑服务器或者是资源服务器 都是需要在微信公众平台配置服务器信息,但是微信是只要求使用 wss 协议 而且还必须是443端口,这就会暴露出一个问题,因为 https 写协议也是 443 端口,, 这就会出现端口占用问题? 解决的方案 使用 nginx 反向代理功能, 主要的思路就是 让 nginx 占用443 端口,然后在由 nginx 去分发不同的请求. 这里也没有什么好讲的吧 ,, 主要是 nginx 的配置表需要配置正确, 就可以实现上述的功能,这里就去讲解一下那个配置表要配置的东西, 12345678910111213141516171819202122232425262728293031323334# 将 http 连接升级map $http_upgrade $connection_upgrade &#123; default upgrade; &apos;&apos; close;&#125;# 这个 配置反向代理的地址upstream websocket &#123; server 127.0.0.1:3000;&#125;server &#123; # 开启 443 端口监听 listen 443 ssl; ... # 配置证书 这个是需要你自己的ssl证书 ssl_certificate *.crt ssl_certificate_key *.key # 这几个 也需要配置 , 这个我 还没有 特备的清楚具体的作用, 暂时就先不解释了 ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_protocols TLSV1.1 TLSV1.2 SSLv2 SSLv3; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location /wss&#123; proxy_pass https://websocket/; # 代理到上面的地址去 proxy_http_version 1.1; # 协议升级 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; &#125;&#125; 然后 运行 nginx -t 去检查语法是否有误 如果没有出现错误 ,,, 就 nginx -s reload // 重启 然后你就可以 使用 http https wss 协议了wss://localhost/wsshttps://localhost/http://localhost/ http 短连接端口问题微信小游戏短连接是使用的是 https 协议 一般 https 的默认端口是 443 , 一般你在浏览器没有加端口,那是浏览器默认为443 ,,, 但是前面说了可以使用 nginx 来实现反向代理的问题, 如果是短连接的话 有个简单的 方法 ,, 经过我测试, 在微信后台配置其他端口在手机上是可以访问,所以 如果项目只是 短连接请求的话可以直接在后台配置你服务器开启的端口,这种方法只适用于 短连接,,, 长连接是不行, 长连接在 后台配置 会出现 在 微信开发工具上测试正常,到手机上测试会出现操作失败的错误,,,而且也连接不上. 好了,这篇文章就先这样. 我也不想 让文章的篇幅过长.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"websocket","slug":"websocket","permalink":"https://leng521.top/tags/websocket/"}]},{"title":"微信小游戏接入广告","date":"2018-08-18T14:34:25.000Z","path":"/posts/967bbd27/","text":"今天主要更新微信小游戏广告接入问题… 微信小游戏现在已经开始对外测试了,只要你的 UV(累计用户超过1000) 且没有违规行为,就可以填写个人信息,如,个人银行卡相关信息等,然后提交审核.如果接过广告的程序员,应该都知道在接入广告的时候需要先创建广告位,产生相关id.大致流程 满足条件 –&gt; 填写个人信息 –&gt; 提交申请 –&gt; 在微信后台创建广告位 –&gt; 游戏前端添加相应的代码逻辑 填写个人信息主要需要填写银行相关信息,账单流水邮件接收人的相关信息,,,这里我截图了,放在公司了,后面补上. 创建爱你广告位 这里主要是广告的类型,,,目前下游戏提供的广告类型,,,只有横幅广告 和 激励广告 横幅广告: 1.一般放在游戏的下方和游戏弹窗触发的情境下 2.横幅广告组件一旦被创建里面的广告内容不会被更新,如果需要更新内容需要,需要将当前组件销毁,重新创建新的组件 3.需要自己去放置位置,这里需要自己去计算位置和缩放和适配,计算不好会遮挡按钮,这个会违反微信小游戏广告规范,这样会有封号,或者是账号被冻结的问题. 激励广告: 1.这个一般是全屏,不需要自己去考虑组件的位置等等 2.主要运用的场景是游戏复活,获取积分,获取道具,获取新关卡机会等等 3.主要负责视频是否播放完毕 客户端逻辑实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 展示横幅广告showAD() &#123; if(CC_WECHATGAME &amp;&amp; wx &amp;&amp; typeof(wx.createBannerAd) != undefined) &#123; this.destroyAd() // 横幅广告接入 let bannerAd = wx.createBannerAd(&#123; adUnitId: 'adunit-68c37174ce72ce6b', style: &#123; left: 0, top: 0, width: 350 &#125; &#125;) // 一般放置屏幕的中下方 bannerAd.onResize(function()&#123; bannerAd.style.left = screenWidth / 2 - bannerAd.style.realWidth / 2 + 0.1; bannerAd.style.top = screenHeight - bannerAd.style.realHeight + 0.1; &#125;) // 默认广告组件是关闭的 bannerAd.show() this._lastBannerAd = bannerAd &#125; &#125;, // 销毁横幅广告 destroyAd() &#123; if(this._lastBannerAd) &#123; this._lastBannerAd.destroy() this._lastBannerAd = null &#125; &#125;, // 展示 激励广告 // obj.success 广告展示完毕回调 // obj.fail 广告展示中途被玩家给关闭会回调 showViewAd(obj)&#123; if(CC_WECHATGAME &amp;&amp; wx &amp;&amp; typeof(wx.createRewardedVideoAd) != undefined) &#123; let videoAd = wx.createRewardedVideoAd(&#123; adUnitId: 'adunit-4db163908fba72f2' &#125;) videoAd.load() .then(() =&gt; videoAd.show()) .catch(err =&gt; &#123; // console.log(err.errMsg) videoAd.load.then(() =&gt; videoAd.show()) &#125;) videoAd.onClose(res =&gt; &#123; if (res &amp;&amp; res.isEnded || res === undefined) &#123; // 正常播放结束，可以下发游戏奖励 if(obj.success) &#123; obj.success(res) &#125; &#125; else &#123; // 播放中途退出，不下发游戏奖励 if(obj.fail) &#123; obj.fail() &#125; &#125; &#125;) videoAd.onError(res =&gt;&#123; console.log('错误',res) &#125;) &#125; else &#123; T.showTips('微信版本过低,请升级使用') &#125; &#125;, 客户端的代码比较的简单,代码里都有注释,这里就不做过多的解释了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"广告","slug":"广告","permalink":"https://leng521.top/tags/广告/"}]},{"title":"微信小游戏开发问题总结","date":"2018-08-11T15:43:19.000Z","path":"/posts/4ec7de9/","text":"最近一个月有点忙呵,都没有时间写博客,今天就抽出一点时间记录一下这一个月中我开发过程遇到的问题,顺便记录一下微信小游戏开发过程中遇到的问题. 今天就接着,上面写的发布流程,接着写会面临的问题吧. 更新新版本问题你的游戏上线后,首先面临的一个问题就是,游戏更新逻辑问题,比如提示玩家更新游戏到最新的游戏版本.这里就直接使用小游戏提供的API. 我这里废话不多说直接给你们参考代码. 123456789101112131415161718192021checkNewVersion() &#123; if (CC_WECHATGAME &amp;&amp; typeof wx.getUpdateManager === 'function') &#123; const updateManager = wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123;&#125;) updateManager.onUpdateReady(function ( res ) &#123; wx.showModal(&#123; title: '更新提示', content: '新版本来袭，是否重启应用？', success: function (res) &#123; if (res.confirm) &#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123;&#125;) &#125; &#125; 这里主要是用到了微信交互控件中的 showModal . 这个函数 直接就是在启动应用的时候直接调用.检测是否有新版本. 微信用户拒绝授权问题还是直接上代码,说的多,不如自己看明白是怎么回事.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667getUserInfo(func_) &#123; if(!this.checkIsWeChat()) &#123;return;&#125; wx.getUserInfo(&#123; withCredentials : false, success: (res) =&gt; &#123; let userInfo = res.userInfo // 授权成功 // avatarUrl // nickName // gender //性别 0：未知、1：男、2：女 // province 省 // city // country &#125;, fail: (res)=&gt;&#123; // 未授权 处理 wx.showModal(&#123; title: '温馨提示', content: '为了良好的体验,请开启用户信息授权', success: res =&gt;&#123; if(res.confirm || res.cancel) &#123; let button = wx.createOpenSettingButton(&#123; type: 'text', text: '打开设置页面', style: &#123; left: 10, top: 76, width: 170, height: 40, lineHeight: 40, backgroundColor: '#4b6881', color: '#ffffff', textAlign: 'center', fontSize: 16, borderRadius: 4 &#125; &#125;) button.show() button.onTap(() =&gt; &#123; wx.getSetting(&#123; success: res =&gt; &#123; button.destroy() if(res.authSetting['scope.userInfo']) &#123; wx.getUserInfo(&#123; withCredentials : false, success: res =&gt; &#123; let info = res.userInfo KUN.Server.uploadUserData(JSON.stringify(info),res=&gt;&#123; if(res == '1') &#123; func_() &#125; else &#123; // 暂时不做处理 &#125; &#125;) &#125; &#125;) &#125; &#125; &#125;) &#125;) &#125; &#125; &#125;) &#125; &#125;); &#125;, 这里面就随便讲解一下,主要是用到了这个apiwx.createOpenSettingButton,在现在的微信小游戏的文档里面没有 按钮事件响应的方法名,我这里处理的方法是在模拟器中把button打印出来然后看里面的详细属性和方法,我这里发现了一个叫 onTap. 主要的思路是 首次进入游戏 -&gt; 用户拒绝授权 -&gt; 获取用户信息失败 -&gt; 创建打开时设置的按钮 -&gt; 绑定监听事件(onTap) -&gt; 再次处理获取用户信息的逻辑. 小游戏跳转功能最近小游戏又更新了一下,出现了一个小程序跳转功能,主要的API 是wx.navigateToMiniProgram 这里面你主要去填写 appid 和要跳转的发行版本 ,,, 其他的你可以去选择也可以不用选择. 还是老样子直接上代码12345678910111213141516171819if (typeof(wx.navigateToMiniProgram) != 'undefined') &#123; wx.navigateToMiniProgram(&#123; appId: 'xxxx', path: '', // 这个可以填写个空. // extarData: &#123; // open: '' // &#125;, envVersion: 'release', success(res) &#123; // 打开成功 &#125;, fail(res) &#123; // 打开失败 &#125; &#125;)&#125;else&#123; // 提示用户微信版本过低&#125; 小游戏推广中遇到的错误在我这篇博客没有写完之前就收到了 boss 的微信消息,说用户进不去了,黑屏了,我是一脸蒙蔽,测试完全没有问题,去推广的时候就出现问题了, 主要是以下几个问题(我只是记录我遇到问题,希望能够对你有帮助,只是说作参考吧,我也是一点点去采坑,一点点去记录.o(￣︶￣)o(持续更新中)) 1.用户的微信小游戏版本太低,导致你使用微信最新api时候报错. 只要在调用该API的时候 加一个判断 typeof(你要调用的小游戏的函数) != undefined,即可 2.服务器地址配置 https协议只能是 443 吗? 经过我测试,不是的只要你在小程序后台配置 类似这样的格式其实也是可以的 这样就可以去访问 服务器其他的端口了 https://xxx.com:8080 我这里说明一下,我没有去测试 websocket 因为现在业务还没有这方面的业务.有的小伙伴可去测试一下,可以告诉我一声.谢谢. 暂时先写到这里,后面这个我会持续更新的,如有不对欢迎指正.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"}]},{"title":"微信小游戏发布流程","date":"2018-07-09T15:02:35.000Z","path":"/posts/da41a120/","text":"今天主要说一下微信小游戏发布流程吧,这篇文章不会写的太长,涉及的东西不多. 个人发布 和 企业发布的流程 代码上传的注意的问题 代码审核会出现的问题 #个人发布和企业发布 这里的个人发布和企业发布是 取决于 你注册这个公众号时 绑定的主体信息是 个人还是企业 个人发布个人发布时需要 两份材料 和一个 苹果的开发者账号 个人准备: - 游戏自审查报告 - 计算机软件著作权登记书(简称 软著) - Apple ID (苹果开发者账号) 1.最上面就是你最基础的配置信息,你的游戏类型,你使用的游戏引擎,2.然后就是上传 刚才提到的那两份材料.3.填写你本次跟新的内容.4.如果你的游戏自己账号系统,需要提供一份给微信团队做测试的账号,密码,没有可以不填写.5.最后一项 Apple ID(必须是开发者账号). 至于怎么申请 成为 苹果的开发者 上百度自己查 企业发布整体流程同上但是比上面多要两份材料 企业需要: - 游戏自审查报告 - 计算机软件著作权登记书(简称 软著) - 广电总局版号批文(简称版号) - 文化部备案信息 - Apple ID (苹果开发者账号) 差异如果是以个人发布的话 你的权限会受到影响,个人不支持内置支付,唯一盈利的途径就是接入广告, 以企业发布 可以接入支付 , 但是 需要版号(申请时间周期长) , 比较的麻烦 上面的信息 填写完毕后 可以直接提交发布. 代码上传的注意的问题你只有提交代码后才可以向微信提交审核, 上传代码的步骤很简单, 打开你的微信开发者工具 点击上传 然后会弹出如下的弹窗 填写你的这次的版本信息 和 这次游戏更新的内容或则是修复的bug 这里如果是使用 cocos creator 的话 ,,由于creator的js文件过大 导致 ES6 转换成 ES5 失败 ,你可以自己在网上找 软件去解决这个问题 ,, 当然也可以先直接提交. ,, 这个问题不大,, 然后在微信后台 的 开发管理里面 会有你提交的小游戏版本信息 , 这里你可以把你刚才提交的小游戏设置为体验版本,这样做的好处是,产生的二维码不会过期. 这里需要注意的是,你每次上传代码都会覆盖掉后台上已经存在的版本,也就是说你的后台,只能存在一个版本.不会同时出现多个不同的版本. 代码审核会出现的问题 代码审核不通过 原因出现 可能是出现诱导分享,如果是这种原因,不可怕, 具体的做法就是 ,将微信团队反馈出来截图中涉及到诱导到分享的功能 的控制权全部移交到后端, 就是每次游戏启动的时候都会想后端 请求一次数据 ,, 访问是否开启某个模块,在审核的时候将这些模块在后台关掉,审核通过后再在后台打开,就行了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"}]},{"title":"微信小游戏开发记录","date":"2018-06-30T14:28:48.000Z","path":"/posts/777fe656/","text":"刚换个新工作,是做微信小游戏的.已经好长时间没有写一些东西了,今天就在这总结一下我这个月的做的事吧,我也是刚使用 cocos creator 时间不长,以前一直用的是 cocos2dx-lua ,写的不好请多多指教,好了废话不多说. 本片文章主要是对微信小游戏开发和总结.引擎: cocos creator发布平台: 微信小游戏(微信sdk ver:2.1.1) 本文大纲 使用 cocos creator 引擎发布到微信上 记录调用微信 API 的记录 微信排行榜实现(开放数据域的使用) 在开发过程中遇到的问题 发布这里首先要准备的东西是: appid 你的游戏工程 微信开发工具 appid:是你注册微信小程序公众号时候能够得到的,这个是你发布的时候要用的东西,当然你也可以使用 cocos creator 提供的默认的账号,(使用这个账号的弊端是你项目相关人员没办法测试,只有你的微信账号可以做测试)微信团队注册和接入微信小游戏的教程在这里注册你的微信公众号账号 微信公众平台在这里选择小程序进行注册,然后按照流程进行注册,你可以是个体,也可以是以企业身份进行注册,(个人注册在后期发布上线的时候要做的事情比较少,企业注册就需要东西比个人多两样,后面详细介绍.) 一般这些东西注册比较简单,这里就仔细叙述了,如果你是管理员的话,你可微信扫码直接登录,如果不是可以让管理员给你直接加一下权限. 你需要配置的信息如下: 这里要注意的就是我第二张图里面指向的地方, 这些你都填写完毕后就可以拿到 appid 了,有了这个id后你可以给其他的项目相关测试人员在微信后台添加 成员并给他们相应的权限,这样他们也可以进行测试你现在开发的小游戏了. 然后在 cocos creator 引擎中去填写, 我这里指向了几个地方,这里你们要是明白的话就更好,要是不明白,先这样做,我只是不想要这篇文章篇幅过长. 至于下面的 开放数据域, 服务器地址, 现在可以先不配置, 到后面我会去介绍的. 在这里再说一下,在点击运行的时候需要先配置,微信开发工具,微信开发工具 download 那里面有配置的完整路径.^-^ 然后引擎会在构建完成之后,点击运行,微信开发者工具启动后,点击预览会生成一个二维码,然后在微信后台,成员管理里面的成员只要有测试权限的都可以通过这个二维码进行游戏测试. 好了到这里你就发布成功了. 这个是 cocos creator 官方团队提供发布微信小游戏的教程 如果运行出现错误可以到这里看看有没有微信小游戏问题总汇 #微信小游戏API 微信小游戏API微信小游戏文档 这里只是演示 cocos creator 是怎么调用微信小游戏的 api,复杂的调用我就先不说了. 123456789101112131415161718192021function test(argument) &#123; // CC_WECHATGAME 这个是 creator 全局宏用来判断是否在微信小游戏环境下 if(CC_WECHATGAME)&#123; wx.login(&#123; success: ()=&gt; &#123; // 调用成功后回调 wx.getUserInfo(&#123; success: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: ()=&gt; &#123; // 调用失败后回调 &#125;, complete: ()=&gt; &#123; // 成功失败都会调用 &#125; &#125;); &#125;&#125; #微信开放数据域 微信的开放数据域要求,解释起来比较复杂,我先给你提供微信官方的解释,和creator 团队做出的解释和例子. 微信的解释creator团队的解释 相信你看完这两个解释,会有一些概念了,这里我就开始直接上代码,这个是最直接. 这个是主域渲染的代码sharedCanvas 是微信提供的全局变量,在微信环境下有用,当然这个是有开放数据域的工程后才行. 123456789101112131415161718192021222324252627cc.Class(&#123; extends: cc.Component, properties: &#123; rankView: cc.Sprite, &#125;, onLoad() &#123; if (CC_WECHATGAME) &#123; this.tex = new cc.Texture2D() window.sharedCanvas.width = 720 window.sharedCanvas.height = 1280 &#125; &#125;, update() &#123; this._updateSubDomainCanvas() &#125;, // 刷新子域的纹理 _updateSubDomainCanvas() &#123; if (CC_WECHATGAME) &#123; if (window.sharedCanvas != undefined) &#123; this.tex.initWithElement(window.sharedCanvas) this.tex.handleLoadedTexture() this.rankView.spriteFrame = new cc.SpriteFrame(this.tex) &#125; &#125; &#125;,&#125;); 发送发送数据的代码 1234567891011121314151617181920212223242526272829303132// 这个是上传分数的一段代码/** @param score_ 要上传的分数*/uploadScore(score_)&#123; if(!this.checkIsWeChat()) &#123;return;&#125; GameTools.sendMessage(&#123; type: GameTools.msgType.submitScore, scoreData: &#123; key: cc.TB.GAME.weChatData.keyList[0], score: score_, &#125;, &#125;);&#125;// 这类型和开放数据域那里的类型保持一致就行了.msgType: &#123; clear: 0, updateRank: 1, submitScore: 2, updateSelfRank: 3, groupShare: 4,&#125;,// 这个是调用微信的API 给开放数据域发送数据的 APIsendMessage(data) &#123; if(CC_WECHATGAME) &#123; console.log('send sub content data'); let content = window.wx.getOpenDataContext(); content.postMessage(data); &#125;&#125;, 开放数据域的代码 这里我直接放一个文件的链接,我就不接去部分代码了,你可以直接修改然后自己使用. 开放数据域代码 这里在你发布开放数据域的工程的时候 好了开放数据域 介绍结束 ^-^ #问题记录 1.游戏包体超过4M 1.将你的资源放置服务器,在微信开放平台后端配置你的服务器地址,这里注意微信是不支持直接填写ip,而且还必须是https协议. 2.最近微信出现个分包加载机制,也可以突破微信不能超过4M的机制,这个我还没有实际实现过就先不写做法了, 2.微信小游戏分享传参问题1234567891011121314151617181920212223242526272829303132333435wx.shareAppMessage(&#123; title: '跟我一起玩', query: 'invite=1&amp;wc=2', imageUrl: address + 'share.jpg', success: (res) =&gt; &#123; console.log('分享 成功 ', res); if (res.shareTickets != undefined &amp;&amp; res.shareTickets.length &gt; 0) &#123; &#125; &#125;&#125;);// 这里主要是利用 query 这个字段进行参数传递// **********************************************// 启动let option = wx.getLaunchOptionsSync();console.log('小游戏启动',option);if(option.shareTicket != undefined) &#123; cc.TB.GAME.weChatData.shareTicket = option.shareTicket; this.onGroupShareFunc();&#125;// 由后台切换到前台是调用的函数wx.onShow((res)=&gt;&#123; // shareTicket console.log('切换到前台',res); if(res.shareTicket)&#123; cc.TB.GAME.weChatData.shareTicket = res.shareTicket; // 显示群排行 this.onGroupShareFunc(); &#125;&#125;);// 在这里 这个函数的返回值里 wx.getLaunchOptionsSync();// 和 这个函数 wx.onShow() 回调里面会有刚才传进来的参数 微信分享主要是利用 query 字段,这个字段类型是 string 只要按照这个格式就可以在在通过分享的链接进入游戏是获取相应参数的值. 好了,今天就先到这里了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://leng521.top/tags/Cocos-Creator/"}]},{"title":"解决运行exe时缺少dll问题","date":"2018-05-23T09:01:51.000Z","path":"/posts/8e17853e/","text":"今天主要是解决如果你使用 cocos2dx 做的游戏(exe) 要放到别人的电脑上运行问题,在有些时候你可能会将自己的exe放到别人的电脑上,但是不幸的是,运行不了,提示说找不到*.dll. 解决思路1.你可能会直接去百度上下载一堆dll但是发现没什么用,还是会报错.那就看来这个思路是行不通的,换一个思路就是你去思考你的电脑比他电脑多了什么东西,其实也就是多了cocos2dx的运行框架,多了个VS.那既然我们已经将cocos2dx编译出来的和锁依赖的dll已经全部放在他的电脑上了,那就剩下个VS,这下目标很清晰喽,直接从VS下手,事实证明这是对的. 解决方案1.去找VS的dll存放的地方,我这里就不找,直接利用电脑管家去全局搜索某个文件,如下图 2.将你缺少的dll全部放在对方这个路径下C:\\Windows\\SysWOW64 Note:当然这里你怕放在这里影响其他的应用的话你也可以不放在,直接放在和你要运行的exe同级目录下就行.我这里只是为了解决多人时出现的问题. 3.copy你通过VS编译出来的exe和它所依赖的dll文件,具体目录在~/simulator/win32/*~代表你项目的根目录,然后将你项目根目录下的src和res文件夹拷贝到他的电脑上,其实就是将win32目录下的src和res给删除,将你项目根目录下的src和res放进去,为了只是保证资源和代码是最新的. 4.如果有人动了c++代码的话,你如果不是太了解C++中dll是干啥的就直接将自己~/simulator/win32/*.dll这个目录下的dll再重新覆盖一下. 好了就先到这里了.","tags":[{"name":"缺少dll","slug":"缺少dll","permalink":"https://leng521.top/tags/缺少dll/"}]},{"title":"给sublime写自定义的插件","date":"2018-05-10T06:17:48.000Z","path":"/posts/b1de475b/","text":"以前总是在sublime中装各种插件,去实现某种便捷,如装一个 git 插件可以直接快速的去查看当前打开的文件与远端的这个文件的差异.但是这些插件总是满足不了你的欲望,有的时候在有一些奇葩的需求,可能没有现有的插件可用,这个时候就要自己去写插件了.首先Sublime是支持自定义插件的,其次是Sublime的插件是采用python的语法,所以你要在写插件之前至少要了解python语法.不然就望而生畏了. 第一步 创建python脚本文件直接打开 Sublime 在最上面工具栏中 找到 Tools/Developer/New Plugin 点击完成之后会有一个内容类似下面的未保存文件1234567import sublimeimport sublime_pluginclass ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, \"Hello, World!\") 关于 sublime 这两个包的 API可以去 SublimeAPI 可能需要翻墙,我只是翻墙之后快了许多. 第二步 填充自己的python文件并保存到相应位置 打开上面所指向的目录自己新建一个文件夹,和你那个User目录同级就行了.列如我建立一个PythonHead 的目录如下: 里面有个 head.py 的python文件,具体内容如下 123456789101112import sublimeimport sublime_pluginimport datetimestr_head = \"\"\"#!usr/bin/env python2#-*- coding: utf-8 -*-#data:%s\\n\"\"\"class PyHeadCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0,str_head % (datetime.datetime.now().strftime(\"%y-%m-%d %H:%m:%s\"))) 这个自定义的功能主要是给自己python文件定义加了一些通用的注释而已.样子就如下面这样 这一写完之后你可以直接打开 Sublime 的命令行 快捷键 ctrl+` 如果快捷键冲突可以直接 View/Show Console 这个也可以 直接在这里面输入如下代码 就会向上面显示的那样. 当然这样肯定是不行的因为这个效率太低下,这里我们直接使用快捷键 第三步 绑定快捷键在上面的那个PyHead的文件夹下面有个 Default (Windows).sublime-keymap 它这个分了一些平台 如 Default (OSX).sublime-keymap Default (Linux).sublime-keymap这样的文件夹,这个是你绑定快捷键到你这个 功能上面.里面的内容如下(使用json的数据格式): 123[ &#123;\"keys\": [\"ctrl+alt+h\"], \"command\": \"py_head\"&#125;] 如果不熟悉json的话可以自己去补一下. 前面这个定义快捷键,后面是你要调用的函数,这里你可能有疑问了,为啥定义是PyHeadCommand 这个名字 却写个这,那是因为在Sublime中 函数的绑定都是小写, 如果你是大写就像上面那样驼峰式命名在绑定的时候是以下划线开头在这个大写字母前面,然后全部小写.举一个例子吧123如 函数名 PyHead 绑定的 command 是 py_head函数名 pyhead 绑定的 command 是 pyhead 函数名 PYHead 绑定的 command 是 p_y_head 这下应该明白了吧. 这样你就成功的写了一个 Sublime 插件的 hello world,如果你要写更厉害的插件你还得去学习 正则表达式,至于这个是啥怎么用自己去找,网上一大堆. 好了今天就先到这.有时间我在接着写一些其他的文档如 Sublime的API文档.","tags":[{"name":"sublime插件","slug":"sublime插件","permalink":"https://leng521.top/tags/sublime插件/"}]},{"title":"linux升级gcc","date":"2018-05-09T01:37:30.000Z","path":"/posts/f62a7c7d/","text":"这一篇是对linux centos7 中 gcc 的升级.这次升级gcc的版本是 8.1.0 方法一12345678910111213141516171819$ su \\\\进入 root# sudo yum install libmpc-devel mpfr-devel gmp-devel...# cd 下载# curl ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/* \\\\* 号为自己想要更新的版本号\\\\ 做法是自己将这个 地址放到浏览器中自己去选取合适的版本直接下载.\\\\ 我这里下载的是 8.1.0 # tar zxfv gcc-8.1.0.tar.gz# cd gcc-8.1.0# ./configure --disable-multilib --enable-languages=c,c++# make -j 4...# make install...# gcc -v...线程模式:posixgcc 版本 8.1.0(GCC)\\\\ ... 意思省略 方法二在 etc/yum.repos.d下面添加repo1touch FedoraRepo.repo 然后添加下面的内容: 123456[warning:fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=https://getfedora.org/static/34EC9CBA.txt 然后更新gcc 1yum -y update gcc gcc-c++ 然后就是新版本了但是这我还不太懂.所以就没有用这个方法. 我用的是方法一.因为方法一可以自己选择gcc版本,并不是所有的东西都要更新到最新的版本,当然这个根据你们自己了.根据情况而定. 方法二更简单一点. 好了今天就先到这了.","tags":[{"name":"gcc","slug":"gcc","permalink":"https://leng521.top/tags/gcc/"}]},{"title":"9宫格纹理的更新问题","date":"2018-04-26T01:40:53.000Z","path":"/posts/1e09c0f5/","text":"这一篇文章主要是讲解一下 cocos2dx 9宫格纹理更新问题我这里就不说 cocos2dx 9宫格怎么使用了。在网上一搜一大堆。基本内容都是那样。我不想做无谓的叙述了。 问题描述现在的环境是： cocos2dx 3.15 VS 2015 使用 lua 写项目 注意这里是说使用 plist 里面的纹理 也就是精灵帧 现在面临的问题是: cocos2dx 对9宫格纹理更新，不能像更新精灵那样使用它提供的函数 setSpriteFrame虽然9宫格就是对精灵的在次封装。 cocos2dx 九宫格的这个函数（setSpriteFrame）在C++定义的头文件中是长这样的 123// UIScale9Sprite.hvirtual void setSpriteFrame(SpriteFrame * spriteFrame, const Rect&amp; capInsets);//它没有提供直接输入字符串来实现纹理的更换. 这说明我们需要一个精灵帧类型，但是这个类型我用了这么时间，基本没用过。 问题剖析我上面有说过九宫格是对纹理的再次封装实现的，说以就去查看他的父类Sprite.h这个是怎么初始化的。 追了 它父类的初始化函数 Sprite.h 看到了它是怎么创建出精灵帧的，下面是他初始化它内部的精灵帧的操作。12345678910111213141516void Sprite::setSpriteFrame(const std::string &amp;spriteFrameName)&#123; CCASSERT(!spriteFrameName.empty(), \"spriteFrameName must not be empty\"); if (spriteFrameName.empty()) &#123; return; &#125; SpriteFrameCache *cache = SpriteFrameCache::getInstance(); // 根据名字在精灵帧缓存中查找相应的精灵帧。 SpriteFrame *spriteFrame = cache-&gt;getSpriteFrameByName(spriteFrameName); CCASSERT(spriteFrame, std::string(\"Invalid spriteFrameName :\").append(spriteFrameName).c_str()); // 设置自己内部的精灵帧对象 setSpriteFrame(spriteFrame);&#125; 原理是在精灵帧缓存中查找对象设置精灵的精灵帧 代码实现这下就好办了。 lua层的代码就是 12345local spriteFrameCache = cc.SpriteFrameCache:getInstance()local frame = spriteFrameCache:getSpriteFrame(\"xxx.png\")-- xxx.png 就是你 plist文件中对应的文件名字。-- 这个就是我们需要的精灵帧对象-- 然后在调用它的 setSpriteFrame 具体的实现代码lua层的c++层我就不说了。暂时没有用到。做法都一样。上面的实现在 cocos2dx display的lua文件里面有实现。所以就直接调用。1234567891011121314151617181920212223242526-- desc: 创建9宫格图片-- params [ path | pos | capInsets | size | rect ]-- params.path 可以是精灵帧 ej: params.path = \"#xxx.png\"-- params.pos 精灵的位置-- params.capInsets 是9宫格中间 Rect 的位置和大小-- params.rect 可以不用填function T.cp_s9( parentNode, params ) local pos = params.pos local s = display.newSprite(params.path,pos.x,pos.y,params) local _ = parentNode and parentNode:addChild(s) return send-- desc: 9宫格图片纹理的更新-- path 无效添加报错机制function T.update_s9( node, path, capInsets, size ) if string.byte(path) == 35 then local sp = display.newSpriteFrame(path) node:setSpriteFrame(sp,capInsets) else if not cc.FileUtils:getInstance():isFileExist(path) then error(string.format(\"invalid path , file isn't exist , path - %s\",path)) end node:setTexture(path) end node:setContentSize(size)end 需要注意的一点就是在九宫格更新纹理后尺寸又变回原来的大小，你需要重新设置大小。","tags":[{"name":"cocos2d-x","slug":"cocos2d-x","permalink":"https://leng521.top/tags/cocos2d-x/"},{"name":"9宫格","slug":"9宫格","permalink":"https://leng521.top/tags/9宫格/"}]},{"title":"python-闭包问题","date":"2018-04-20T02:31:51.000Z","path":"/posts/87435431/","text":"本文主要是python闭包问题的记录。python 实现的有内部函数，那么自然就会使用内部函数外面的变量 。 注意这里是要改变局部变量 可以使用下面的策略，如果只是简单的引用，可以直接引用 不用使用 nonlocal 关键字 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-def A(): xxx = 0 def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment nonlocal xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3 这里主要是使用了python 内部的关键字 nonlocal主要是引用内部函数以外的局部变量 注意这里不是全局变量。 注意这个关键字是python3.x 中可以出现的关键字。在python2.x中会报错。在python2.x的版本中可以使用 list 封装一层，实现使用内部函数以外的局部变量。这里不能使用 元祖 因为元祖的变量时不可变的。 如果要引用全局变量要是用python的另外一个关键字 global。用法和上面相同。 使用例子如下： 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-xxx = 0def A(): def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment global xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"https://leng521.top/tags/闭包/"}]},{"title":"记录使用hexo写博客的问题","date":"2018-04-14T08:17:16.000Z","path":"/posts/a9ff66a6/","text":"在使用 hexo 总会遇到这种那种的错误我这里就记录一下,希望后面使用 hexo 写博客的人能少遇到一点麻烦，少走一点弯路，OK，废话不多说。 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false. 2. hexo skip_render 的使用123skip_render: - 'dir/**' # 忽略dir这目录下的所有文件，不进行渲染 - 'xx/**' # 道理同上。 3. 修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 `hexo clean`,每次记得使用这个命令清除一下","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"}]},{"title":"python_optionparser模块","date":"2018-04-11T08:01:20.000Z","path":"/posts/ce1d3b12/","text":"本文主要是 python 对命令行的处理模块 就象是这样的","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"optionParser","slug":"optionParser","permalink":"https://leng521.top/tags/optionParser/"}]},{"title":"git命令的记录","date":"2018-03-07T03:00:24.000Z","path":"/posts/82a402af/","text":"现在对git也使用快一年了现在总结一下常用的一些命令。 本文的大纲对以下命令做一些记录1.git clone2.git pull3.git commit4.git push5.git branch6.git remote7.git checkout8.git reset9.git stash10.git配置一些外部工具11.git merge12.git log13.git show git clonegit clone 是克隆别的仓库 1234git clone &lt;repo&gt; &lt;directory&gt;参数说明： repo:Git 仓库 directory:本地目录 ej:比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： git clone git://github.com/schacon/grit.git 或者是这样的 git clone git://github.com/schacon/grit.git test 这个就会克隆到 ../test 和目录 git pull拉取别人在远程仓库更新的内容 默认是远程的 origin 分支 git add将本地的改变提交到缓存区 git add -u 是将本地追踪的文件提交到缓存区 123ej:git add -u *.png--添加所有追踪的文件提交到缓存区 前提是以.png 为结尾的文件 git add -A 是将本地未追踪的文件提交到缓存区 123ej:git add -A .--添加所有的未追踪的文件提交到缓存区 git commit 将本地的改变提交到缓存区的内容到本地版本库 123ej:git commit -m &quot;test&quot;-- -m 是对此次的提交内容的描述(desc) git push 将本地的改变提交到本地版本库的内容推送到远程版本库 123ej:git push-- 默认是主为分支(origin) git push 将本地分支推送到云端 1git push origin/远程分支的名字 本地分支的名字 git branch 有关分支的一些使用 git branch 查看本地分支 git branch -vv 查看本地分支 与 远程分支的映射关系 git branch -a 查看 本地和远程分支 git branch -r 查看远程分支 git branch xx 创建新的xx分支 git branch -D xx 删除xx分支 git branch upstream(git 分支的映射关系)建立本地分支与远程分支的映射关系（或者为跟踪关系track）。这样使用`git pull`或者`git push`时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。 ej:从这上面可以看到本地分支与远程分支的映射关系若没有映射关系 git pull 或是 git push 会失败 与远程分支建立映射关系 使用 git branch -u origin/xx 与远程分支 建立 映射关系xx 为 远程分支的名字 与远程分支取消映射关系使用 git branch --unset-upstream 补充：不同名字客之间也是可以建立映射关系的 删除远程的分支12git push origin --delete xxx-- xxx 为远程分支的名字 git fetch 来一个关系式 git pull = git fecth + git merge拉取别人远程仓库的内容到自己本地的一个分支上 1234ej: git fecth origin test:temp -- 拉取远程分支 test 到 本地 temp 分支上 -- 注意这种拉取 本地分支和远程分支 是没有映射关系的 git remotegit remote and git remote -v git remote用来管理本地工作目录对应的远程代码仓库，在一般的工作目录下，执行git remote结果如下： git remote add 我们可以使用git remote add命令来增加一个远程仓库，这个远程仓库可以是ssh地址（如上面这种），可以是本地目录，也可以是git协议或者http协议的地址。 例如，我要把liming的仓库作为我的远程仓库之一，可以执行git remote add 来增加仓库，例如： 123456789$ git remote add liming /home/liming/repo$ git remotelimingorigin$ git remote -vliming /home/liming/repo (fetch)liming /home/liming/repo (push)origin git@remoteRepo (fetch)origin git@remoteRepo (push) 相应的，可以使用git remote rm或者git remote rename对远程代码仓库的名称进行修改（本地的，不会影响到对方的目录） git checkout作用： 1.切换分支 2.放弃对某个文件的修改 3.创建新的分支 git checkout xx 切换到xx分支 git checkout -b xx 在没有的时候 创建的新的分支xx 并跳转到 xx 分支上 git checkout xx.ext 放弃修改直接还原和版本库保持一致 拉取远程方法123git checkout -b 本地分支名x origin/远程分支名xNote:使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 git reset作用： 1.文件从暂存区回退到工作区 2.版本回退 作用1： git reset HEAD filename(xx)作用2: 我就直接转载一篇文章写的挺好的 git reset的使用 git 中文的教程 –貌似要科学上网 git stash你当前正在开发的分支上面，还有未提交的代码，你又不想把代码提交了，怎么办呢？作用： 将本地的改变存储起来，切换到另外的分支上。 1234git stash-- 将本地的改变存储起来git stash list-- 查看本地存储的列表 如何恢复工作现场呢？ 第一种方案，用`git stash apply`恢复，但是恢复后，stash内容不删除，需要用`git stash drop`来删除 第二种方案，用`git stash pop`,恢复的同时把stash内容也删除了。 git配置一些外部工具配置代码对比工具我配置了一个叫diffuse的工具 我这里给你提供一个下载地址，当然你也可以自己去下载别的 download diffuse 1.git查看有哪些对比工具可以设置命令： 1git difftool --tool-help 2.然后再设置对比工具，如： 12git config --global diff.tool diffusegit config --global difftool.diffuse.path &quot;E:\\Program Files (x86)\\Diffuse\\diffuse.exe&quot; 3.设置好后，使用命令是 git difftool 而不是之前的 git diff 了 git ProblemProblem : 1.为什么在切换分支的时,会出现有时要你提交本地的改变才可以切换，有的时候却不需要？ 出现融合的时候是你当前分支改变的内容与你将要切换分支的内容有冲突，这个时候不知要你融合。 1234解决的方法有我种： 1.使用 git stash 保存当前的改变 git stash 的用法在上面 2.使用 git merge 融合要切换的分支到当前的分支 3.使用 git checkout 还原当前冲突的文件 git merge– 2018年3月20日14:36:34git 融合：是融合你当前版本库没有的东西。你可以选择本地的分支也可以是远程的分支 123456-- 融合远程分支ej: git merge origin/分支的名字-- 融合本地分支ej: git merge 分支的名字 git 更高级的用法问题: 在你的使用 git merge 的时候也会出现冲突. git merge –abort选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好 git status -sb罗列出需要解决冲突的文件. 在你合并的时候 你可以将远端共同祖先的文件, 自己本地的文件, 要融合分支的文件,都下载到本地, 123git show :1:hello.rb &gt; hello.common.rbgit show :2:hello.rb &gt; hello.ours.rbgit show :3:hello.rb &gt; hello.theirs.rb git clean -f在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。就是通过上面的命令 git show :1 … 这个命令产出的文件. git log这里在更新一下 git log 的一些命令的使用 git log -n罗列出最近 n 次提交 ej: git log -3 // 罗列出最近三次的提交信息 git show显示一些提交的状态信息 git show –stat [commitId] ej: git show –stat 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42它会罗列出当前这次提交的信息,以文件更改列表的形式显示,如下图 git show [commitId]这个命令和上个命令很相似 , 只是去掉一个 –stat ej git show 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42 src/a.lua显示这次这个文件提交的内容","tags":[{"name":"git命令","slug":"git命令","permalink":"https://leng521.top/tags/git命令/"}]},{"title":"优化cocos2dxSpine库","date":"2018-01-22T12:44:31.000Z","path":"/posts/c4c0a180/","text":"对cocos2dxSpine库的升级和优化本文的大纲1.升级spine在cocos2dx-3.15的运行时库2.优化spine在创建的时候效率 在开发的时候出现的问题1.spine这个软件导出3.6新加的特效在cocos2dx3.15 不能使用2.spine在批量创建的时候帧数会下降 升级spine -&gt;3.6spine code github 地址去这个地址clone或者是下载Zip这个你随便然后会产现这个目录主要就是我使用箭头标记的这两个目录 spine-c/spine-c/include/spine/*.h spine-c/spine-c/src/spine/*.c spine-cocos2dx/src/spine/*.cpp and spine-cocos2dx/src/spine/*.h 找到自己的工程的根目录 然后去找这个目录全部放在 ···/frameworks/cocos2d-x/cocos/editor-support/spine 直接全部替换然后打开自己的VS去编译记住一点将你添加的C或C++的文件给添加到libSpine的工程中的源文件中 选中 Source Files 执行 Shift + Alt + A 添加现有项 或者是鼠标右键添加好可以 然后编译,你会惊奇的发现编译成功了,但是不要高兴的太早了,因为这个在编译Android的时候会报错,当然原因也很简单，接着往下面看。 在Android中的实现你找到 这个目录里面会有 ···/frameworks/cocos2d-x/cocos/editor-support/spineAndroid.mk的文件将你添加的写在这个配置里面 注意只写 *.h 的文件然后使用 Android Studio 编译 Apk, 这里你也可以使用NDK编译,但是在Android2.？这个不记得了,就已经不在支持NDK编译了所以还是使用Android Studio 吧 在 ios 中的实现也是同样如此，这里就不再讲述了 优化spine在创建的时候效率在原先的 spine 创建的时候每次都需要解析数据,生成骷髅数据,其实这个是很消耗CPU的,导致FPS下降。我的做法是保留 spine create 的原有接口,自己再从新写一个新的接口。原理：创建字典保留骷髅数据每次创建的时候询问这个 Map 是否存在 key 没有创建,有直接使用。 代码的写法有很多种,我这只是参考 在SkeletonAnimation.cpp 中添加如下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798SkeletonAnimation* SkeletonAnimation::createFromCache(const std::string&amp; key_skeletonData)&#123; if (spSkeletonData* skeleton_data = SkeletonAnimation::getSkeletonDataFromCache(key_skeletonData)) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; else &#123; skeleton_data = SkeletonAnimation::loadSkeletonDataToCache(key_skeletonData, key_skeletonData + \".json\", key_skeletonData + \".atlas\"); if (skeleton_data) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it == _allSkeletonDataCache.end()) &#123; SkeletonDataInCache skeleton_data_in_cache; spAtlas* atlas = nullptr; spAttachmentLoader* attachmentLoader = nullptr; skeleton_data_in_cache._skeleton_data = nullptr; atlas = spAtlas_createFromFile(atlasFile.c_str(), 0); CCASSERT(atlas, \"loadSkeletonDataToCache Error atlas file.\"); attachmentLoader = SUPER(Cocos2dAttachmentLoader_create(atlas)); spSkeletonJson* json = spSkeletonJson_createWithLoader(attachmentLoader); json-&gt;scale = scale; skeleton_data_in_cache._skeleton_data = spSkeletonJson_readSkeletonDataFile(json, skeletonJsonFile.c_str()); CCASSERT(skeleton_data_in_cache._skeleton_data, json-&gt;error ? json-&gt;error : \"loadSkeletonDataToCache Error reading skeleton data file.\"); spSkeletonJson_dispose(json); spAtlas_dispose(atlas); if (skeleton_data_in_cache._skeleton_data) &#123; _allSkeletonDataCache[key_skeletonData] = skeleton_data_in_cache; return skeleton_data_in_cache._skeleton_data; &#125; else &#123; //error release if (skeleton_data_in_cache._skeleton_data) &#123; spSkeletonData_dispose(skeleton_data_in_cache._skeleton_data); &#125; &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::getSkeletonDataFromCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return it-&gt;second._skeleton_data; &#125; return nullptr;&#125;bool SkeletonAnimation::removeSkeletonData(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); _allSkeletonDataCache.erase(it); return true; &#125; return false;&#125;void SkeletonAnimation::removeAllSkeletonData()&#123; for (iteratorSkeletonData it = _allSkeletonDataCache.begin(); it != _allSkeletonDataCache.end(); ++it) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); &#125; _allSkeletonDataCache.clear();&#125;bool SkeletonAnimation::isExistSkeletonDataInCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return true; &#125; return false;&#125;//endstd::map&lt;std::string, SkeletonAnimation::SkeletonDataInCache&gt; SkeletonAnimation::_allSkeletonDataCache; 在 SkeletonAnimation.h 中添加如下代码1234567891011121314static SkeletonAnimation* createFromCache(const std::string&amp; key_skeletonData);static spSkeletonData* loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale = 1);static spSkeletonData* getSkeletonDataFromCache(const std::string&amp; key_skeletonData);static bool removeSkeletonData(const std::string&amp; key_skeletonData);static void removeAllSkeletonData();static bool isExistSkeletonDataInCache(const std::string&amp; skeletonDataKeyName);private: struct SkeletonDataInCache &#123; spSkeletonData* _skeleton_data; &#125;; typedef std::map&lt;std::string, SkeletonDataInCache&gt;::iterator iteratorSkeletonData; static std::map&lt;std::string, SkeletonDataInCache&gt; _allSkeletonDataCache; //end Binding to lua既然写了这么多了,就要将这些代码绑定到lua中去 找到自己工程的的libluacocos2d的工程这里你可以自己写代码在 lua_cocos2dx_spine_auto.cpp 中,但是这不是一个程序员应该做的。第二种做是:既然它的文件名有 auto 这个单词,一看就不是人写出来的,OK,去寻找答案。 到这个目录中去 ···/frameworks/cocos2d-x/tools/tolua/ 你会发现有一个genbindings.py的文件你一运行可能报错,你去读他的 README.md ,发现他要你装一些python的库,那就按照说的安装吧你可以 pip 命令也可以 自己下载zip 这个随意。然后就是配置NDK,这个下载解压,配置 path 就完了,我就不多说了。 然后你运行可能还会报错 那就打开 genbindings.py 你会发现他需要的是NDK 3.3-3.4 然而自己的NDK经过查看 是 3.5-3.6 没关系,把它这个所有相关 3.3 3.4 全部改成 3.5-3.6的就OK了。 改完后运行 Prefect ^-^. 在lua中调用123456sp.SkeletonAnimation: createFromCache(key)sp.SkeletonAnimation: isExistSkeletonDataInCache(key)sp.SkeletonAnimation: loadSkeletonDataToCache(key,jsonFilePath,atlasFilePath,scale =1) sp.SkeletonAnimation: getSkeletonDataFromCache(key)sp.SkeletonAnimation: removeSkeletonData(key)sp.SkeletonAnimation: removeAllSkeletonData() 这里面有一个问题是你会发现返回的骨胳数据拿不到,这个是cocos2dx在绑定的时候并没有将这个数据类型绑定lua去,我上面那么写就是为了以后留个接口,当然你也可以自己把那个返回值去掉。 好了今天就到这吧。","tags":[{"name":"spine","slug":"spine","permalink":"https://leng521.top/tags/spine/"}]},{"title":"Using-Hexo","date":"2018-01-17T12:07:49.000Z","path":"/posts/6743743b/","text":"这篇文章只是我对 hexo 的一些功能的测试吧，可能后会常用到这些东西 Requirementsinstall Hexo123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David Levithan-Wide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 12alert(&apos;Hello World!&apos;);print(&apos;Hello World!&apos;) language -&gt; OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; language -&gt; python1print('Hello World!') 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块[language] [title] [url] [link text] code snippet language - &gt;OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; 插入Image图片12&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% asset_img fileName.* title&#125; 引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 使用iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"},{"name":"IT","slug":"IT","permalink":"https://leng521.top/tags/IT/"}]},{"title":"Hello World","date":"2018-01-16T16:00:00.000Z","path":"/posts/4a17b156/","text":"搭建自己的博客在github page经过2天的折腾的终于把自己的博客给搭建出来了,也可以说是自己的一个Hello World 吧这个主题是使用Litten的theme通过hexo搭建 准备环境* install git * install node * 注册github的账号 Git Downloadnodejs Downloadgithub 注册的地址 再创建之前思考一个事情就是在你做完这些之后，你开始写自己的博客的时候，突然之间要换电脑了，这个时候你要怎么办这个思考是对于那些使用过 github 或者是使用过别的版本控制的工具。 Build to blog安装 nodejs 很简单,就是傻瓜式的安装。 在安装 git 的时候也是一键式安装。 然后自己注册github的账号。 记得配置自己的 nodejs的Path 在 cmd 窗口 输入 path我自己的 nodejs 在E盘 同样看看自己的 git 的 path 有没有配置 然后就是验证你的安装是否正确打开你 cmd 输入 git输入 node -vgithub 就不用验证了吧 然后就是利用 node 的 npm 工具去安装 hexo 输入 npm install -g hexo-cli 如果自己的 hexo 安装成功的话 在 cmd 中 输入 hexo -v 创建自己的 hexo 工程假设自己的 hexo 的工程目录是在 D:\\Pro\\pro_wdh\\nodejs 1. 在 cmd 中 输入 pushd D:\\Pro\\pro_wdh\\nodejs 2. cmd的当前目录直接跳转到 D:\\Pro\\pro_wdh\\nodejs 3. 使用 hexo init 命令 初始化 （）hexo init [folderName] ） hexo init hexocd hexonmp install 完成之后目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 运行自己的hexo工程在 cmd 中 输入 hexo s 在自己的浏览器中打开 http://localhost:4000/. 这时你会看到自己的静态网页 更多的 hexo的命令hexo 的官网 部署自己的笔记2github网上的一些教程都是 使用 SSH 去上传自己的博客但是使用 htpp 的方式也同样可以 上传 创建自己的 github 的仓库上面的仓库名字就和你 github 的名字一样就行了 然后就是在 hexo 的根目录下的 _config.yml 中 找到按照图片上的配置自己的 github 仓库的地址github 仓库的地址在这里拿 然后执行 hexo的命令 在cmd中输入 1.hexo clean 2.hexo g 3.hexo d 静静的等待 上传完成之后 打开 http://Test.github.io 就可以看到自己的博客了 回答上面的提出的思考答案就是 在 github 上创建自己的 branch(分支) 我是在自己的 github 创建自己的 blog(分支) git 的一些命令 不是太全,但是应对日常还是可以的 做法如下： git chcekout -b blog git add -A git commit - m &quot;commit my blog&quot; git push origin blog 解释一下吧 创建新的分支 blog添加自己的文件到缓存区提交到本地版本库推送到远端 更多 git 的知识 这只是一些基础 更多需要你多去尝试,多自己动手。 有疑问可以加QQ一起讨论","tags":[{"name":"hello world","slug":"hello-world","permalink":"https://leng521.top/tags/hello-world/"},{"name":"github page","slug":"github-page","permalink":"https://leng521.top/tags/github-page/"},{"name":"博客","slug":"博客","permalink":"https://leng521.top/tags/博客/"}]}]