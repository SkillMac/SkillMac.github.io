[{"title":"cocos2dx-JS-OC-Java互相调用","date":"2018-12-15T02:21:49.000Z","path":"/posts/41d43874/","text":"cocos2dx js java oc 和 js 的相互调用引擎版本: 3.17语言: jsXcode: 10.1AndroidStudio: 3.2.1时间: 2018年12月14日16:23:47 看这篇文章需要 会一些 android java oc ios 的一些知识的基础 不然看着可能有点费劲. js调用javajs 调用 java java中声名的方法需要是静态方法(static method) Android 平台下123456if(cc.sys.os == cc.sys.OS_ANDROID)&#123; jsb.reflection.callStaticMethod('类名加全路径','方法名字','方法的签名','传递参数');&#125;ej: js jsb.reflection.callStaticMethod('org/cocos2dx/javascript/AppActivity','getStrVdong','(Ljava/lang/String;)V','haha'); 1234567891011121314ej: javapublic static void getStrVdong(String str) &#123; log.i('cocso2dx-js js call java', str);&#125; 其他方法签名的写法ej: (Ljava/lang/String;)V //参数是字符串 没有返回值 (I)V // void(int); ()V // void(); (IZ)V // void(int,boolean); (IZ)Z // boolean(int,boolean); ()Ljava/lang/String; //String(); 支持传递的数据类型 Z 布尔 I int F float 字符串 Ljava/lang/String; 注意这里有个字符串是有个分号的 java调用jsjava调用js 实际是 将字符串转成 function 然后调用 12345678910111213141516/* 导入需要的包 */import org.cocos2dx.lib.Cocos2dxJavascriptJavaBridge;import org.cocos2dx.lib.Cocos2dxHelper;/*这里需要注意的是调用 js 代码需要运行在 GL 线程中这里实现的逻辑是 将回调的逻辑移交到 js 代码层中, 这样就可以在 js 中 写逻辑 java 在合适的时机去执行这个调用 比如在做支付的时候 需要在之后响应后在 做游戏逻辑的处理.*/public static void callFuncVdong(final String code) &#123; Cocos2dxHelper.runOnGLThread(new Runnable()&#123; @Override public void run() &#123; Cocos2dxJavascriptJavaBridge.evalString(code); &#125; &#125;);&#125; 123456789/*写一下 js 调用的例子*/ej: jsb.reflection.callStaticMethod( \"org/cocos2dx/javascript/AppActivity\", \"callFuncVdong\", \"(Ljava/lang/String;)V\", \"g_funcList.callFunc()\"); /*呼叫一个全局函数*/ 问题记录js调用 java 没反应 有很大的几率是 js调用中 方法签名没有写正确 你需要检查你的写法 具体的写法上面有写的. js 调用 ocjs 调用 oc 其实和 Java的写法是大同小异的 在 ios/AppController.h 中声名 静态函数 1+(NSString *) showVdong:(NSString *)str title:(NSString *)tit; 在 ios/AppController.mm 文件中实现 123456789@implementation// 在这个之间实现函数+(NSString *) showVdong:(NSString *)str title:(NSString *)tit &#123; return @\"haha\";&#125;@end js 调用用例 1234if(cc.sys.os == cc.sys.OS_IOS || cc.sys.os == cc.sys.OS_OSX) &#123; var ret = jsb.reflection.callStaticMethod(\"AppController\",\"showVdong:title\",\"你是谁???\",\"天呢\"); cc.log('****************',ret);&#125; oc 调用 js 在 ios/AppController.mm 文件中实现 12345678#include \"cocos/scripting/js-bindings/manual/ScriptingCore.h\"+(NSString *) showVdong:(NSString *)str title:(NSString *)tit &#123; ScriptingCore::getInstance()-&gt;evalString(\"test\"); return @\"haha\";&#125; js 中的测试用例 123var test = function() &#123; cc.log(\"OC call JS success !!!\");&#125; 参考地址(这个是CocosCreator原生游戏调用) &gt; https://www.cnblogs.com/billyrun/articles/8529503.html","tags":[]},{"title":"AndroidStudio打包Cocos2dx","date":"2018-12-08T03:05:57.000Z","path":"/posts/a2412c06/","text":"前几天闲着没事,去弄了一下AndroidStudio打包最新版 cocos2dx 系列原生平台的安装包. 引擎版本: 3.17AndroidStudio版本: 3.2.1SDK: 27NDK: android-ndk-r16bgradle: 4.1 首先提供这几个下载地址,有的可能需要翻墙,这个你们自己解决. gradleandroid sdk android studio 自带有下载的管理器anroid ndkandroid studiococos2dx-系列 报错记录Gradle sync failed: SSL peer shut down incorrectly 查这个路径下 gradle–&gt;wrapper–&gt;gradle-wrapper.properties 要下载 gradle 版本 ej:distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip gradle下载地址 删除原先的资源 存放到下面路径下 C:\\Users\\Administrator.gradle\\wrapper\\dists\\gradle-4.1-all\\bzyivzo6n839fup2jbap0tjew 记住一定要放到这个乱码的文件夹中 如果上面的步骤你你把android随机生成的文件夹(bzyivzo6n839fup2jbap0tjew) 删了 你可以执行下面的步骤 D:\\pro\\cocos_pro\\testCocosJs\\frameworks\\runtime-src\\proj.android\\gradlew.bat 执行这个脚本也可以. 执行你这里面的这个预处理脚本,它会重新生成一个类似于上面个文件夹,不要希望这个脚本能够下载好你想要的 gradle 版本.这会很慢,可以直接停掉这个批处理.执行这一步的目的是为了生成 上面类似的文件夹(bzyivzo6n839fup2jbap0tjew). 当然如果你有更好的方案也可以. No cached version of com.android.tools.build:gradle:3.0.0 available for offline mode. File/setting/build…/gradle/Offline work 禁掉 如果 gradle 同步的很慢可以使用 镜像工程 替换proj.adnroid/build.gradle 中的地址替换为镜像库 maven { url ‘https://maven.aliyun.com/repository/google‘ } maven { url ‘https://maven.aliyun.com/repository/jcenter‘ } maven { url ‘http://maven.aliyun.com/nexus/content/groups/public‘ } 我这个下面有截图 官方提供的打包配置 地址 官方打包配置 No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 在 ndk 的根目录里面有个 toolchains 的文件夹 里面没有 这个文件 mips64el-linux-android 原因是我用的是 r18 的 但是那里面没有这个东西,我去使用r16 里面就有这个东西. ndk r9 下载路径 提供一下r9的下载路径 因为之前打包 3.15 是用的是 r9 所以这里记录一下地址 防止后面找不到了, 上面ndk 归档 只是到了 r10. NDK r9d： r9-x86-windowr9-x86_64-window[r9-x86-mac]http://dl.google.com/android/ndk/android-ndk-r9d-darwin-x86.tar.bz2（Mac环境）r9-x86-linuxr9-x86_64-linuxr9d-cxx-stl-libs-with-debug-info 配置NDK 环境变量 ANDROID_NDK_ROOT 编译externalNativeBuildDebug出错 可能出现路径太长导致 文件 查找失败(win10)下面路径有个大神写了个补丁. [修复ndk打包长路径查找失败]https://discuss.cocos2d-x.org/t/the-solution-of-ndk-compile-system-longpaths-issue-on-windows-platform/42705 这个打包记录是纯净的打包没有介入任何 sdk(如,微信的sdk facebook 第三方广告平台(admob) 等); 我的每篇文章都不希望写的太长,不然看着都烦人. 这里之所以记录时间是为了 提醒一下 阅读者这里也许不是最新的,如果已过很长时间,那就给你提供,经验的借鉴吧. 时间: 2018年12月7日22:28:49","tags":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"https://leng521.top/tags/cocos2dx/"},{"name":"android studio","slug":"android-studio","permalink":"https://leng521.top/tags/android-studio/"}]},{"title":"记录TweenLite库","date":"2018-11-21T13:45:42.000Z","path":"/posts/90e70f70/","text":"今天主要记录一下 TweenLite 这个补间动画库,他们的官方地址TweenLite官方网址 库版本是:2.0.2 这里面有几个文件可以使用 TweenLite TimelineLite TweenlineMax TweenMax 我这里就简单说一下这几个文件都做了什么事情,说先说明一下我这里主要研究跟 CocosCreator 相关的功能,它里面还有一些关于h5的东西,感兴趣的可以了解一下. 讲解每个文件的功能TweenLite这个是 Tween 动画的基础库, 所有的其他更丰富的功能都是在这个基础上封装的. 里面主要使用1TweenLite.to(target:Object, duration:Number, vars:Object) 第一个是操作的对象,第二个是执行的时间,第三个是要进行补间的属性. 首先你们要导入这个文件(TweenLite.js)你下载的文件里面应该是有个压缩后的文件 (TweenLite.min.js) 这个更省空间 例如如下的例子123456789import TweenLite from \"TweenLite.min\"function main() &#123; TweenLite.to(this.node,2,&#123;x:100,y:\"+=100\",rotation:45,opacity:\"+=255\",onComplete:()=&gt;&#123; console.log('执行结束'); &#125;&#125;);&#125;main(); 上面这个例子是 让一个node 同时执行 位置, 旋转 和透明度的 变换,这种写法要比 CocosCreator 的那套 Action 要简洁 其他的 API 我就捡着几个重要的说一下吧,其他的你们可以看一下他们的官文文档讲解的很清楚 主要说第三个参数12345678910111213&#123; x:100,// 跑到当前坐标系下 x=100 的位置 y:\"+=100\", // 自身值 增加100 ..., onStartParams:['123'], onStart:(p1)=&gt;&#123;console.log(p1)&#125;,// 输出 123 在这个动画开始执行的时候调用 onCompleteParams:['123'], onComplete:(p1)=&gt;&#123;console.log(p1)&#125;,// 输出入123 在这个动画结束的时候调用 onReverseComplete:()=&gt;&#123;&#125;, // 调用翻转函数的说 这个动画结束后 会调用 delay:2,// 开始延时 ease: Elastic.easeOut, // 要使用这东西要导入 easeing 文件下的那个 easePack.js 文件&#125; 调用TweenLite.to 函数的时候是会去返回一个对象的, 在这个补间动画库中 使用的是链式(chain)调用, 这个对象使用几个 api 的 pause 暂停当前的动画play 播放当前动画resume 恢复当前动画reverse 在任意时间都可以调用这个 翻转函数 翻转当前动画restart 从新开始progress 它的取值区间是[0,1] 指定当前动画处开始播放seek 跳转到指定位置 和 progress 函数有点相似 这个指的是时间的位置点 例子如下1234567891011121314import Ease from \"EasePack.min\";import TweenLite from \"TweenLite.min\"let tl = TweenLite.to(this.node,2,&#123; x:100, ease: Elastic.easeOut&#125;);tl.play();tl.pause();tl.resume();tl.restart();tl.progress(0.5);tl.seek(0.5);tl.progress(0.5).pause(); 因为他是链式调用所以 最后一个的写法是不会报错的.你们要是想要使用 ease 这个属性的话 是需要将 EasePack.min.js 导入到工程中 不需要在代码中导入, 至于为什么可以自己去看他们 uncompressed 文件下对应的代码文件. 后面那三个文件都是在这个基础上扩展的所以需要理解这个文件的用法. TweenLite 还有其他的几个静态函数 TweenLite.to TweenLite.from TweenLite.fromTo 用法比较的简单看文档也就可知道了. TimelineLite看这个名字凭字面上的意思是 时间线 也可以理解成 时间轴,看官方文档解释是他可以形成一个队列,就是说你可以组成一个动画列表一次播放. 例子如下123456import TimelineLite from \"TimelineLite.min\"let tl = new TimelineLite();// 创建一个新实例对象tl.to(this.node,2,&#123;x:\"+=100\"&#125;).to(this.node,2,&#123;y:\"+=100\"&#125;); 这个就是创建了一个动画队列,让一个物体向x轴正方向移动100像素, 然后在向y轴正方向移动100像素. 里面的参数配置和 TweenLite 里面的配置是一样的. 他提供了 TweenLite对象的嵌套 同时也支持 Timeline 的嵌套 为什么这么说看下面的例子 12345678910111213141516import TimelineLite from \"TimelineLite.min\";import TweenLite from \"TweenLite.min\";let tl = new TimelineLite();// 创建一个新实例对象tl.to(this.node,2,&#123;x:\"+=100\"&#125;).to(this.node,2,&#123;y:\"+=100\"&#125;);let tl1 = new TimelineLite();tl1.add(TweenLite.to(this.node,2,&#123;x:\"+=100\"&#125;));tl1.add(TweenLite.to(this.node,2,&#123;y:\"+=100\"&#125;));let tl2 = new TimelineLite();tl2.to(this.node,2,&#123;x:\"+=100\"&#125;);tl1.append(tl2); 这里面 to 和 add 的功能效果都是一样的 可以看到 add 里面是个 TweenLite 对象 所以 TimelineLite是维护 TweenLite每个对象进而形成 一个队列 TimelineLite 还有其他的用 入 addLabel 等函数,看他们解释和代码例子很容易懂 TimelineMax是对 TimelineLite 进行的扩展 主要扩展 使用 加入 repeat repeatDelay yoyo currentLabel(), addCallback(), removeCallback(), tweenTo(), tweenFromTo(), getLabelAfter(), getLabelBefore(), getActive(). 如果上面额功能不能满足你们项目的需求可以再去用 TimelineMax 这个更强大额 扩展包. TweenMaxTweenMax 是对 TweenLite 的扩展, 也加入 repeat(), repeatDelay(), yoyo() 等等, 而且看他们未压缩的 代码 好像这个文件是可以不要依赖 其他三的,因为他把其他三个都压缩到这个文件里面了,但是相应的文件的大小也增加了,同时也集成了一些扩展插件. 你们的项目如果对 代码的大小没有太高的要求的话,你们可以去直接导入这个TweenMax.min.js 这个文件. 上面讲了这么多也只是个入们吧,这个库里面还封装了一些很多有趣的东西,你们可以去多了解了解. 这里使用这个库去替代 CocosCreator 的 Action 主要是 api 使用灵活, 写法简单,运行速度也很快. 也有一些 Action 所不具有的动能 入随时翻转,控制动画流程,暂停动画等等,随机点开始播放动画,时间轴交叉等. 好了,今天就先到这里.写作不易,且行且珍惜. 我是小魏. 时间:2018年11月21日17:16:36.","tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://leng521.top/tags/CocosCreator/"},{"name":"TweenLite","slug":"TweenLite","permalink":"https://leng521.top/tags/TweenLite/"}]},{"title":"QQ玩一玩打包","date":"2018-10-30T14:45:53.000Z","path":"/posts/dd666e1a/","text":"今天主要纪录最近对 QQPlay(玩一玩)打包的纪录. 然后这里只是纪录我目前使用的引擎(Cocos Creator version 2.x.x),精力有限. QQPlay官方文档 大纲1. 玩一玩包体中缺少`Utils`文件 2. 怎么读取最新的 bricks 引擎 3. 解决 xcode 打包到手机过程中出现的错误 4. 空泛讲解整个玩一玩上传流程 5. 避免上传后台而实时跟新 android 机里面的逻辑为最新 6. 实现厘米秀大部分功能 7. 关于获取每个游戏用户的 openkey 的获取问题 未完待续厘米秀游戏性能审核标准自建后台 前后端需要注意什么审核前游戏应该准备些什么玩一玩后台需要的一些配置 玩一玩包体中缺少Utils文件在你上传厘米秀后台的时候如果只是单纯使用Cocos Creator 发布QQPlay 平台的时候,在 ~/build/qqplay/libs/element/ 这个路径下缺少一个 Utils.js 的脚本文件 但是引擎团队在2.x.x 版本中 还一直没有修复这个问题,原因在 ~/build/qqplay/libs/qqplay-adapter.js 中又引入过这个文件.在论坛中搜到的解决方案是 将 qqplay-adapter.js 脚本中的这一行代码注释掉,这个在前期没用到对应功能的时候不会报错,但是等用到Utils.js 里面的功能是就会发现会再次报错. 报错的原因:加载远程图片会使用 libs/element/HTMLImageElement.js 脚本 解决方案: 使用CocosCreator(1.x.x) 版本随便打包个 QQPlay 平台,将其中的Utils.js粘到当前工程中 的 ~/build/qqplay/libs/element/ 目录中 修改Utils.js中对其他库的引用路径(CocosCreator(2.x.x)中将第三方引来的脚本归类到~build/qqplay/libs/other/这个目录下了), 修改的点如下: 建立一个和 ~/build 同级的目录(build-templates) 将上一步的 Utils.js文件也复制一份到 ~/build-templates/qqplay/libs/element/ 中, 类似于下面的这样 (这样做的目的是可以每次构建的时候,打的玩一玩的包都含有 Utils.js 脚本); Utils.js.txt 1.9.3 打包的 Utils.js 脚本 可以参考 这里面我已经修改过了,可以直接使用. 怎么读取最新的 bricks 引擎下面这是引擎团队的说法 和 玩一玩官方文档的说法玩一玩 官方说法 需要科学上网bitbucket官网解决方案: 登录官网注册账号 将自己的账号发给 hudong@tencent.com 邮件的主题写 引擎申请权限等待大概 4 天左右 腾讯的相关工作人员会给你这个账号添加权限,你就可以试试获取最新的xcode工程 10.25 玩一玩官网 给出了 bricks 引擎的下载地址,也就是说你可以不用申请了bricks XCode 工程bricks 下载页面 解决 xcode 打包到手机过程中出现的错误这里主要是 苹果签名 出的错误这里面 会有 详细的 解决方案(我不想重复造轮子)解决打包签名报错问题他这里面用的是 将 com.tencent.PublicBrickEngineGame 修改为 com.test.PublicBrickEngineGame 你会发现还是报错 ,,, 那就将 test 修改为被人很难想到的名字就行了 ,,, 然后 try again 空泛讲解整个玩一玩上传流程 引擎打包 QQPlay 平台的包 修复引擎包内缺少的文件 gameConfig.json 里面需要的填充的内容如下 gameConfig.json|官方解释地址 在你调试期间可以先 不把 构建面板的 MD5 开始 , 这样你可以,先将 gameConfig.json 放入到 ~/build-templates/qqplay/ 中 ,,, 测试完毕后将 MD5 开启, 然后打正式包的时候需要手动填充 gameConfig.json 文件.gameConfig.json 内容如下: 在后台创建测试版 避免上传后台而实时跟新 android 机里面的逻辑为最新参考文档这个讲解的也很详细 ,,, 我就不重复造轮子了. 我到现在都还不知道怎么看 log 哪位大神知道 可以在下面评论 我加 QQ ,, 请教请教. 实现厘米秀大部分功能参考文章官方文档程序员主要是一些细节,,,可能会困扰你,这里我就不说啥了,,,官方也提供的挺详细的,,,你也可以借鉴.QQPlay.js.txt我这里在提供一份我封装好的 里面(获取 openId, 获取QQ名字, 获取QQ头像地址, 分数上传, 获取好友分数排行榜, 各个时间点的绑定, 公众号跳转, 分享, 分享链接, 生成快捷方式传参, 储存/读取个人云端数据,存储游戏数据到本地,获取openkey,创建 banner广告, 创建激励视频广告, Post 请求)还有一些功能 未完成(暂时项目没有需求就写, 后面会持续更新); 关于获取每个游戏用户的 openkey 的获取问题获取 openkey 是验证当前用户是否是手Q环境,,,避免有些模拟请求,,,使其更安全. 这个 openkey 比较的坑,,, 这是官方文档你会发现 这里面 没啥 这个 game.json 是个啥东西,,, needOpenkey 又是个啥 ,,, 然后点击游戏上架章节 嗯哼 Not Found ,,, 于是 又去找了找,你会发现这里还有点提示信息 到最后也没说 到底要放在哪里? 解决方案:在和gameConfig.json 同目录里面 创建一个 game.json 文件 里面内容为123&#123; \"needOpenkey\": 1&#125; 然后随同到包内. 然后就是调用12345BK.QQ.fetchOpenKey(function (errCode, cmd, data) &#123; if (errCode == 0) &#123; var openKey = data.openKey; &#125;&#125;); 这个借口去获取用户的 openkey","tags":[{"name":"cocos creator","slug":"cocos-creator","permalink":"https://leng521.top/tags/cocos-creator/"},{"name":"QQ玩一玩","slug":"QQ玩一玩","permalink":"https://leng521.top/tags/QQ玩一玩/"}]},{"title":"微信小游戏记录长连接(websocket)","date":"2018-09-15T02:55:43.000Z","path":"/posts/ba881459/","text":"哎,距离上次写博客竟然一个月了,真是时间不等人呀,好了废话不多说,直接进入正题.今天主要记录这几个问题: websocket 端口问题, http(短连接) 端口问题, 由于公司的云服务器都是使用的是阿里云,但是小游戏是腾讯的,腾讯云又推出了一堆有利于小游戏的服务,但是我们用不来了,那就自己去解决里面会遇到的问题, websocket 端口问题在微信小游戏里面所有用户的逻辑服务器或者是资源服务器 都是需要在微信公众平台配置服务器信息,但是微信是只要求使用 wss 协议 而且还必须是443端口,这就会暴露出一个问题,因为 https 写协议也是 443 端口,, 这就会出现端口占用问题? 解决的方案 使用 nginx 反向代理功能, 主要的思路就是 让 nginx 占用443 端口,然后在由 nginx 去分发不同的请求. 这里也没有什么好讲的吧 ,, 主要是 nginx 的配置表需要配置正确, 就可以实现上述的功能,这里就去讲解一下那个配置表要配置的东西, 12345678910111213141516171819202122232425262728293031323334# 将 http 连接升级map $http_upgrade $connection_upgrade &#123; default upgrade; &apos;&apos; close;&#125;# 这个 配置反向代理的地址upstream websocket &#123; server 127.0.0.1:3000;&#125;server &#123; # 开启 443 端口监听 listen 443 ssl; ... # 配置证书 这个是需要你自己的ssl证书 ssl_certificate *.crt ssl_certificate_key *.key # 这几个 也需要配置 , 这个我 还没有 特备的清楚具体的作用, 暂时就先不解释了 ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_protocols TLSV1.1 TLSV1.2 SSLv2 SSLv3; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location /wss&#123; proxy_pass https://websocket/; # 代理到上面的地址去 proxy_http_version 1.1; # 协议升级 proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; &#125;&#125; 然后 运行 nginx -t 去检查语法是否有误 如果没有出现错误 ,,, 就 nginx -s reload // 重启 然后你就可以 使用 http https wss 协议了wss://localhost/wsshttps://localhost/http://localhost/ http 短连接端口问题微信小游戏短连接是使用的是 https 协议 一般 https 的默认端口是 443 , 一般你在浏览器没有加端口,那是浏览器默认为443 ,,, 但是前面说了可以使用 nginx 来实现反向代理的问题, 如果是短连接的话 有个简单的 方法 ,, 经过我测试, 在微信后台配置其他端口在手机上是可以访问,所以 如果项目只是 短连接请求的话可以直接在后台配置你服务器开启的端口,这种方法只适用于 短连接,,, 长连接是不行, 长连接在 后台配置 会出现 在 微信开发工具上测试正常,到手机上测试会出现操作失败的错误,,,而且也连接不上. 好了,这篇文章就先这样. 我也不想 让文章的篇幅过长.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"websocket","slug":"websocket","permalink":"https://leng521.top/tags/websocket/"}]},{"title":"微信小游戏接入广告","date":"2018-08-18T14:34:25.000Z","path":"/posts/967bbd27/","text":"今天主要更新微信小游戏广告接入问题… 微信小游戏现在已经开始对外测试了,只要你的 UV(累计用户超过1000) 且没有违规行为,就可以填写个人信息,如,个人银行卡相关信息等,然后提交审核.如果接过广告的程序员,应该都知道在接入广告的时候需要先创建广告位,产生相关id.大致流程 满足条件 –&gt; 填写个人信息 –&gt; 提交申请 –&gt; 在微信后台创建广告位 –&gt; 游戏前端添加相应的代码逻辑 填写个人信息主要需要填写银行相关信息,账单流水邮件接收人的相关信息,,,这里我截图了,放在公司了,后面补上. 创建爱你广告位 这里主要是广告的类型,,,目前下游戏提供的广告类型,,,只有横幅广告 和 激励广告 横幅广告: 1.一般放在游戏的下方和游戏弹窗触发的情境下 2.横幅广告组件一旦被创建里面的广告内容不会被更新,如果需要更新内容需要,需要将当前组件销毁,重新创建新的组件 3.需要自己去放置位置,这里需要自己去计算位置和缩放和适配,计算不好会遮挡按钮,这个会违反微信小游戏广告规范,这样会有封号,或者是账号被冻结的问题. 激励广告: 1.这个一般是全屏,不需要自己去考虑组件的位置等等 2.主要运用的场景是游戏复活,获取积分,获取道具,获取新关卡机会等等 3.主要负责视频是否播放完毕 客户端逻辑实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 展示横幅广告showAD() &#123; if(CC_WECHATGAME &amp;&amp; wx &amp;&amp; typeof(wx.createBannerAd) != undefined) &#123; this.destroyAd() // 横幅广告接入 let bannerAd = wx.createBannerAd(&#123; adUnitId: 'adunit-68c37174ce72ce6b', style: &#123; left: 0, top: 0, width: 350 &#125; &#125;) // 一般放置屏幕的中下方 bannerAd.onResize(function()&#123; bannerAd.style.left = screenWidth / 2 - bannerAd.style.realWidth / 2 + 0.1; bannerAd.style.top = screenHeight - bannerAd.style.realHeight + 0.1; &#125;) // 默认广告组件是关闭的 bannerAd.show() this._lastBannerAd = bannerAd &#125; &#125;, // 销毁横幅广告 destroyAd() &#123; if(this._lastBannerAd) &#123; this._lastBannerAd.destroy() this._lastBannerAd = null &#125; &#125;, // 展示 激励广告 // obj.success 广告展示完毕回调 // obj.fail 广告展示中途被玩家给关闭会回调 showViewAd(obj)&#123; if(CC_WECHATGAME &amp;&amp; wx &amp;&amp; typeof(wx.createRewardedVideoAd) != undefined) &#123; let videoAd = wx.createRewardedVideoAd(&#123; adUnitId: 'adunit-4db163908fba72f2' &#125;) videoAd.load() .then(() =&gt; videoAd.show()) .catch(err =&gt; &#123; // console.log(err.errMsg) videoAd.load.then(() =&gt; videoAd.show()) &#125;) videoAd.onClose(res =&gt; &#123; if (res &amp;&amp; res.isEnded || res === undefined) &#123; // 正常播放结束，可以下发游戏奖励 if(obj.success) &#123; obj.success(res) &#125; &#125; else &#123; // 播放中途退出，不下发游戏奖励 if(obj.fail) &#123; obj.fail() &#125; &#125; &#125;) videoAd.onError(res =&gt;&#123; console.log('错误',res) &#125;) &#125; else &#123; T.showTips('微信版本过低,请升级使用') &#125; &#125;, 客户端的代码比较的简单,代码里都有注释,这里就不做过多的解释了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"广告","slug":"广告","permalink":"https://leng521.top/tags/广告/"}]},{"title":"微信小游戏开发问题总结","date":"2018-08-11T15:43:19.000Z","path":"/posts/4ec7de9/","text":"最近一个月有点忙呵,都没有时间写博客,今天就抽出一点时间记录一下这一个月中我开发过程遇到的问题,顺便记录一下微信小游戏开发过程中遇到的问题. 今天就接着,上面写的发布流程,接着写会面临的问题吧. 更新新版本问题你的游戏上线后,首先面临的一个问题就是,游戏更新逻辑问题,比如提示玩家更新游戏到最新的游戏版本.这里就直接使用小游戏提供的API. 我这里废话不多说直接给你们参考代码. 123456789101112131415161718192021checkNewVersion() &#123; if (CC_WECHATGAME &amp;&amp; typeof wx.getUpdateManager === 'function') &#123; const updateManager = wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123;&#125;) updateManager.onUpdateReady(function ( res ) &#123; wx.showModal(&#123; title: '更新提示', content: '新版本来袭，是否重启应用？', success: function (res) &#123; if (res.confirm) &#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123;&#125;) &#125; &#125; 这里主要是用到了微信交互控件中的 showModal . 这个函数 直接就是在启动应用的时候直接调用.检测是否有新版本. 微信用户拒绝授权问题还是直接上代码,说的多,不如自己看明白是怎么回事.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667getUserInfo(func_) &#123; if(!this.checkIsWeChat()) &#123;return;&#125; wx.getUserInfo(&#123; withCredentials : false, success: (res) =&gt; &#123; let userInfo = res.userInfo // 授权成功 // avatarUrl // nickName // gender //性别 0：未知、1：男、2：女 // province 省 // city // country &#125;, fail: (res)=&gt;&#123; // 未授权 处理 wx.showModal(&#123; title: '温馨提示', content: '为了良好的体验,请开启用户信息授权', success: res =&gt;&#123; if(res.confirm || res.cancel) &#123; let button = wx.createOpenSettingButton(&#123; type: 'text', text: '打开设置页面', style: &#123; left: 10, top: 76, width: 170, height: 40, lineHeight: 40, backgroundColor: '#4b6881', color: '#ffffff', textAlign: 'center', fontSize: 16, borderRadius: 4 &#125; &#125;) button.show() button.onTap(() =&gt; &#123; wx.getSetting(&#123; success: res =&gt; &#123; button.destroy() if(res.authSetting['scope.userInfo']) &#123; wx.getUserInfo(&#123; withCredentials : false, success: res =&gt; &#123; let info = res.userInfo KUN.Server.uploadUserData(JSON.stringify(info),res=&gt;&#123; if(res == '1') &#123; func_() &#125; else &#123; // 暂时不做处理 &#125; &#125;) &#125; &#125;) &#125; &#125; &#125;) &#125;) &#125; &#125; &#125;) &#125; &#125;); &#125;, 这里面就随便讲解一下,主要是用到了这个apiwx.createOpenSettingButton,在现在的微信小游戏的文档里面没有 按钮事件响应的方法名,我这里处理的方法是在模拟器中把button打印出来然后看里面的详细属性和方法,我这里发现了一个叫 onTap. 主要的思路是 首次进入游戏 -&gt; 用户拒绝授权 -&gt; 获取用户信息失败 -&gt; 创建打开时设置的按钮 -&gt; 绑定监听事件(onTap) -&gt; 再次处理获取用户信息的逻辑. 小游戏跳转功能最近小游戏又更新了一下,出现了一个小程序跳转功能,主要的API 是wx.navigateToMiniProgram 这里面你主要去填写 appid 和要跳转的发行版本 ,,, 其他的你可以去选择也可以不用选择. 还是老样子直接上代码12345678910111213141516171819if (typeof(wx.navigateToMiniProgram) != 'undefined') &#123; wx.navigateToMiniProgram(&#123; appId: 'xxxx', path: '', // 这个可以填写个空. // extarData: &#123; // open: '' // &#125;, envVersion: 'release', success(res) &#123; // 打开成功 &#125;, fail(res) &#123; // 打开失败 &#125; &#125;)&#125;else&#123; // 提示用户微信版本过低&#125; 小游戏推广中遇到的错误在我这篇博客没有写完之前就收到了 boss 的微信消息,说用户进不去了,黑屏了,我是一脸蒙蔽,测试完全没有问题,去推广的时候就出现问题了, 主要是以下几个问题(我只是记录我遇到问题,希望能够对你有帮助,只是说作参考吧,我也是一点点去采坑,一点点去记录.o(￣︶￣)o(持续更新中)) 1.用户的微信小游戏版本太低,导致你使用微信最新api时候报错. 只要在调用该API的时候 加一个判断 typeof(你要调用的小游戏的函数) != undefined,即可 2.服务器地址配置 https协议只能是 443 吗? 经过我测试,不是的只要你在小程序后台配置 类似这样的格式其实也是可以的 这样就可以去访问 服务器其他的端口了 https://xxx.com:8080 我这里说明一下,我没有去测试 websocket 因为现在业务还没有这方面的业务.有的小伙伴可去测试一下,可以告诉我一声.谢谢. 暂时先写到这里,后面这个我会持续更新的,如有不对欢迎指正.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"}]},{"title":"微信小游戏发布流程","date":"2018-07-09T15:02:35.000Z","path":"/posts/da41a120/","text":"今天主要说一下微信小游戏发布流程吧,这篇文章不会写的太长,涉及的东西不多. 个人发布 和 企业发布的流程 代码上传的注意的问题 代码审核会出现的问题 #个人发布和企业发布 这里的个人发布和企业发布是 取决于 你注册这个公众号时 绑定的主体信息是 个人还是企业 个人发布个人发布时需要 两份材料 和一个 苹果的开发者账号 个人准备: - 游戏自审查报告 - 计算机软件著作权登记书(简称 软著) - Apple ID (苹果开发者账号) 1.最上面就是你最基础的配置信息,你的游戏类型,你使用的游戏引擎,2.然后就是上传 刚才提到的那两份材料.3.填写你本次跟新的内容.4.如果你的游戏自己账号系统,需要提供一份给微信团队做测试的账号,密码,没有可以不填写.5.最后一项 Apple ID(必须是开发者账号). 至于怎么申请 成为 苹果的开发者 上百度自己查 企业发布整体流程同上但是比上面多要两份材料 企业需要: - 游戏自审查报告 - 计算机软件著作权登记书(简称 软著) - 广电总局版号批文(简称版号) - 文化部备案信息 - Apple ID (苹果开发者账号) 差异如果是以个人发布的话 你的权限会受到影响,个人不支持内置支付,唯一盈利的途径就是接入广告, 以企业发布 可以接入支付 , 但是 需要版号(申请时间周期长) , 比较的麻烦 上面的信息 填写完毕后 可以直接提交发布. 代码上传的注意的问题你只有提交代码后才可以向微信提交审核, 上传代码的步骤很简单, 打开你的微信开发者工具 点击上传 然后会弹出如下的弹窗 填写你的这次的版本信息 和 这次游戏更新的内容或则是修复的bug 这里如果是使用 cocos creator 的话 ,,由于creator的js文件过大 导致 ES6 转换成 ES5 失败 ,你可以自己在网上找 软件去解决这个问题 ,, 当然也可以先直接提交. ,, 这个问题不大,, 然后在微信后台 的 开发管理里面 会有你提交的小游戏版本信息 , 这里你可以把你刚才提交的小游戏设置为体验版本,这样做的好处是,产生的二维码不会过期. 这里需要注意的是,你每次上传代码都会覆盖掉后台上已经存在的版本,也就是说你的后台,只能存在一个版本.不会同时出现多个不同的版本. 代码审核会出现的问题 代码审核不通过 原因出现 可能是出现诱导分享,如果是这种原因,不可怕, 具体的做法就是 ,将微信团队反馈出来截图中涉及到诱导到分享的功能 的控制权全部移交到后端, 就是每次游戏启动的时候都会想后端 请求一次数据 ,, 访问是否开启某个模块,在审核的时候将这些模块在后台关掉,审核通过后再在后台打开,就行了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"cocos creator","slug":"cocos-creator","permalink":"https://leng521.top/tags/cocos-creator/"}]},{"title":"微信小游戏开发记录","date":"2018-06-30T14:28:48.000Z","path":"/posts/777fe656/","text":"刚换个新工作,是做微信小游戏的.已经好长时间没有写一些东西了,今天就在这总结一下我这个月的做的事吧,我也是刚使用 cocos creator 时间不长,以前一直用的是 cocos2dx-lua ,写的不好请多多指教,好了废话不多说. 本片文章主要是对微信小游戏开发和总结.引擎: cocos creator发布平台: 微信小游戏(微信sdk ver:2.1.1) 本文大纲 使用 cocos creator 引擎发布到微信上 记录调用微信 API 的记录 微信排行榜实现(开放数据域的使用) 在开发过程中遇到的问题 发布这里首先要准备的东西是: appid 你的游戏工程 微信开发工具 appid:是你注册微信小程序公众号时候能够得到的,这个是你发布的时候要用的东西,当然你也可以使用 cocos creator 提供的默认的账号,(使用这个账号的弊端是你项目相关人员没办法测试,只有你的微信账号可以做测试)微信团队注册和接入微信小游戏的教程在这里注册你的微信公众号账号 微信公众平台在这里选择小程序进行注册,然后按照流程进行注册,你可以是个体,也可以是以企业身份进行注册,(个人注册在后期发布上线的时候要做的事情比较少,企业注册就需要东西比个人多两样,后面详细介绍.) 一般这些东西注册比较简单,这里就仔细叙述了,如果你是管理员的话,你可微信扫码直接登录,如果不是可以让管理员给你直接加一下权限. 你需要配置的信息如下: 这里要注意的就是我第二张图里面指向的地方, 这些你都填写完毕后就可以拿到 appid 了,有了这个id后你可以给其他的项目相关测试人员在微信后台添加 成员并给他们相应的权限,这样他们也可以进行测试你现在开发的小游戏了. 然后在 cocos creator 引擎中去填写, 我这里指向了几个地方,这里你们要是明白的话就更好,要是不明白,先这样做,我只是不想要这篇文章篇幅过长. 至于下面的 开放数据域, 服务器地址, 现在可以先不配置, 到后面我会去介绍的. 在这里再说一下,在点击运行的时候需要先配置,微信开发工具,微信开发工具 download 那里面有配置的完整路径.^-^ 然后引擎会在构建完成之后,点击运行,微信开发者工具启动后,点击预览会生成一个二维码,然后在微信后台,成员管理里面的成员只要有测试权限的都可以通过这个二维码进行游戏测试. 好了到这里你就发布成功了. 这个是 cocos creator 官方团队提供发布微信小游戏的教程 如果运行出现错误可以到这里看看有没有微信小游戏问题总汇 #微信小游戏API 微信小游戏API微信小游戏文档 这里只是演示 cocos creator 是怎么调用微信小游戏的 api,复杂的调用我就先不说了. 123456789101112131415161718192021function test(argument) &#123; // CC_WECHATGAME 这个是 creator 全局宏用来判断是否在微信小游戏环境下 if(CC_WECHATGAME)&#123; wx.login(&#123; success: ()=&gt; &#123; // 调用成功后回调 wx.getUserInfo(&#123; success: res =&gt; &#123; console.log(res) &#125; &#125;) &#125;, fail: ()=&gt; &#123; // 调用失败后回调 &#125;, complete: ()=&gt; &#123; // 成功失败都会调用 &#125; &#125;); &#125;&#125; #微信开放数据域 微信的开放数据域要求,解释起来比较复杂,我先给你提供微信官方的解释,和creator 团队做出的解释和例子. 微信的解释creator团队的解释 相信你看完这两个解释,会有一些概念了,这里我就开始直接上代码,这个是最直接. 这个是主域渲染的代码sharedCanvas 是微信提供的全局变量,在微信环境下有用,当然这个是有开放数据域的工程后才行. 123456789101112131415161718192021222324252627cc.Class(&#123; extends: cc.Component, properties: &#123; rankView: cc.Sprite, &#125;, onLoad() &#123; if (CC_WECHATGAME) &#123; this.tex = new cc.Texture2D() window.sharedCanvas.width = 720 window.sharedCanvas.height = 1280 &#125; &#125;, update() &#123; this._updateSubDomainCanvas() &#125;, // 刷新子域的纹理 _updateSubDomainCanvas() &#123; if (CC_WECHATGAME) &#123; if (window.sharedCanvas != undefined) &#123; this.tex.initWithElement(window.sharedCanvas) this.tex.handleLoadedTexture() this.rankView.spriteFrame = new cc.SpriteFrame(this.tex) &#125; &#125; &#125;,&#125;); 发送发送数据的代码 1234567891011121314151617181920212223242526272829303132// 这个是上传分数的一段代码/** @param score_ 要上传的分数*/uploadScore(score_)&#123; if(!this.checkIsWeChat()) &#123;return;&#125; GameTools.sendMessage(&#123; type: GameTools.msgType.submitScore, scoreData: &#123; key: cc.TB.GAME.weChatData.keyList[0], score: score_, &#125;, &#125;);&#125;// 这类型和开放数据域那里的类型保持一致就行了.msgType: &#123; clear: 0, updateRank: 1, submitScore: 2, updateSelfRank: 3, groupShare: 4,&#125;,// 这个是调用微信的API 给开放数据域发送数据的 APIsendMessage(data) &#123; if(CC_WECHATGAME) &#123; console.log('send sub content data'); let content = window.wx.getOpenDataContext(); content.postMessage(data); &#125;&#125;, 开放数据域的代码 这里我直接放一个文件的链接,我就不接去部分代码了,你可以直接修改然后自己使用. 开放数据域代码 openContentData.txt 这里在你发布开放数据域的工程的时候 好了开放数据域 介绍结束 ^-^ #问题记录 1.游戏包体超过4M 1.将你的资源放置服务器,在微信开放平台后端配置你的服务器地址,这里注意微信是不支持直接填写ip,而且还必须是https协议. 2.最近微信出现个分包加载机制,也可以突破微信不能超过4M的机制,这个我还没有实际实现过就先不写做法了, 2.微信小游戏分享传参问题1234567891011121314151617181920212223242526272829303132333435wx.shareAppMessage(&#123; title: '跟我一起玩', query: 'invite=1&amp;wc=2', imageUrl: address + 'share.jpg', success: (res) =&gt; &#123; console.log('分享 成功 ', res); if (res.shareTickets != undefined &amp;&amp; res.shareTickets.length &gt; 0) &#123; &#125; &#125;&#125;);// 这里主要是利用 query 这个字段进行参数传递// **********************************************// 启动let option = wx.getLaunchOptionsSync();console.log('小游戏启动',option);if(option.shareTicket != undefined) &#123; cc.TB.GAME.weChatData.shareTicket = option.shareTicket; this.onGroupShareFunc();&#125;// 由后台切换到前台是调用的函数wx.onShow((res)=&gt;&#123; // shareTicket console.log('切换到前台',res); if(res.shareTicket)&#123; cc.TB.GAME.weChatData.shareTicket = res.shareTicket; // 显示群排行 this.onGroupShareFunc(); &#125;&#125;);// 在这里 这个函数的返回值里 wx.getLaunchOptionsSync();// 和 这个函数 wx.onShow() 回调里面会有刚才传进来的参数 微信分享主要是利用 query 字段,这个字段类型是 string 只要按照这个格式就可以在在通过分享的链接进入游戏是获取相应参数的值. 好了,今天就先到这里了.","tags":[{"name":"微信小游戏","slug":"微信小游戏","permalink":"https://leng521.top/tags/微信小游戏/"},{"name":"cocos creator","slug":"cocos-creator","permalink":"https://leng521.top/tags/cocos-creator/"}]},{"title":"解决运行exe时缺少dll问题","date":"2018-05-23T09:01:51.000Z","path":"/posts/8e17853e/","text":"今天主要是解决如果你使用 cocos2dx 做的游戏(exe) 要放到别人的电脑上运行问题,在有些时候你可能会将自己的exe放到别人的电脑上,但是不幸的是,运行不了,提示说找不到*.dll. 解决思路1.你可能会直接去百度上下载一堆dll但是发现没什么用,还是会报错.那就看来这个思路是行不通的,换一个思路就是你去思考你的电脑比他电脑多了什么东西,其实也就是多了cocos2dx的运行框架,多了个VS.那既然我们已经将cocos2dx编译出来的和锁依赖的dll已经全部放在他的电脑上了,那就剩下个VS,这下目标很清晰喽,直接从VS下手,事实证明这是对的. 解决方案1.去找VS的dll存放的地方,我这里就不找,直接利用电脑管家去全局搜索某个文件,如下图 2.将你缺少的dll全部放在对方这个路径下C:\\Windows\\SysWOW64 Note:当然这里你怕放在这里影响其他的应用的话你也可以不放在,直接放在和你要运行的exe同级目录下就行.我这里只是为了解决多人时出现的问题. 3.copy你通过VS编译出来的exe和它所依赖的dll文件,具体目录在~/simulator/win32/*~代表你项目的根目录,然后将你项目根目录下的src和res文件夹拷贝到他的电脑上,其实就是将win32目录下的src和res给删除,将你项目根目录下的src和res放进去,为了只是保证资源和代码是最新的. 4.如果有人动了c++代码的话,你如果不是太了解C++中dll是干啥的就直接将自己~/simulator/win32/*.dll这个目录下的dll再重新覆盖一下. 好了就先到这里了.","tags":[{"name":"缺少dll","slug":"缺少dll","permalink":"https://leng521.top/tags/缺少dll/"}]},{"title":"给sublime写自定义的插件","date":"2018-05-10T06:17:48.000Z","path":"/posts/b1de475b/","text":"以前总是在sublime中装各种插件,去实现某种便捷,如装一个 git 插件可以直接快速的去查看当前打开的文件与远端的这个文件的差异.但是这些插件总是满足不了你的欲望,有的时候在有一些奇葩的需求,可能没有现有的插件可用,这个时候就要自己去写插件了.首先Sublime是支持自定义插件的,其次是Sublime的插件是采用python的语法,所以你要在写插件之前至少要了解python语法.不然就望而生畏了. 第一步 创建python脚本文件直接打开 Sublime 在最上面工具栏中 找到 Tools/Developer/New Plugin 点击完成之后会有一个内容类似下面的未保存文件1234567import sublimeimport sublime_pluginclass ExampleCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0, \"Hello, World!\") 关于 sublime 这两个包的 API可以去 SublimeAPI 可能需要翻墙,我只是翻墙之后快了许多. 第二步 填充自己的python文件并保存到相应位置 打开上面所指向的目录自己新建一个文件夹,和你那个User目录同级就行了.列如我建立一个PythonHead 的目录如下: 里面有个 head.py 的python文件,具体内容如下 123456789101112import sublimeimport sublime_pluginimport datetimestr_head = \"\"\"#!usr/bin/env python2#-*- coding: utf-8 -*-#data:%s\\n\"\"\"class PyHeadCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.insert(edit, 0,str_head % (datetime.datetime.now().strftime(\"%y-%m-%d %H:%m:%s\"))) 这个自定义的功能主要是给自己python文件定义加了一些通用的注释而已.样子就如下面这样 这一写完之后你可以直接打开 Sublime 的命令行 快捷键 ctrl+` 如果快捷键冲突可以直接 View/Show Console 这个也可以 直接在这里面输入如下代码 就会向上面显示的那样. 当然这样肯定是不行的因为这个效率太低下,这里我们直接使用快捷键 第三步 绑定快捷键在上面的那个PyHead的文件夹下面有个 Default (Windows).sublime-keymap 它这个分了一些平台 如 Default (OSX).sublime-keymap Default (Linux).sublime-keymap这样的文件夹,这个是你绑定快捷键到你这个 功能上面.里面的内容如下(使用json的数据格式): 123[ &#123;\"keys\": [\"ctrl+alt+h\"], \"command\": \"py_head\"&#125;] 如果不熟悉json的话可以自己去补一下. 前面这个定义快捷键,后面是你要调用的函数,这里你可能有疑问了,为啥定义是PyHeadCommand 这个名字 却写个这,那是因为在Sublime中 函数的绑定都是小写, 如果你是大写就像上面那样驼峰式命名在绑定的时候是以下划线开头在这个大写字母前面,然后全部小写.举一个例子吧123如 函数名 PyHead 绑定的 command 是 py_head函数名 pyhead 绑定的 command 是 pyhead 函数名 PYHead 绑定的 command 是 p_y_head 这下应该明白了吧. 这样你就成功的写了一个 Sublime 插件的 hello world,如果你要写更厉害的插件你还得去学习 正则表达式,至于这个是啥怎么用自己去找,网上一大堆. 好了今天就先到这.有时间我在接着写一些其他的文档如 Sublime的API文档.","tags":[{"name":"sublime插件","slug":"sublime插件","permalink":"https://leng521.top/tags/sublime插件/"}]},{"title":"linux升级gcc","date":"2018-05-09T01:37:30.000Z","path":"/posts/f62a7c7d/","text":"这一篇是对linux centos7 中 gcc 的升级.这次升级gcc的版本是 8.1.0 方法一12345678910111213141516171819$ su \\\\进入 root# sudo yum install libmpc-devel mpfr-devel gmp-devel...# cd 下载# curl ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/* \\\\* 号为自己想要更新的版本号\\\\ 做法是自己将这个 地址放到浏览器中自己去选取合适的版本直接下载.\\\\ 我这里下载的是 8.1.0 # tar zxfv gcc-8.1.0.tar.gz# cd gcc-8.1.0# ./configure --disable-multilib --enable-languages=c,c++# make -j 4...# make install...# gcc -v...线程模式:posixgcc 版本 8.1.0(GCC)\\\\ ... 意思省略 方法二在 etc/yum.repos.d下面添加repo1touch FedoraRepo.repo 然后添加下面的内容: 123456[warning:fedora] name=fedora mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-23&amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=https://getfedora.org/static/34EC9CBA.txt 然后更新gcc 1yum -y update gcc gcc-c++ 然后就是新版本了但是这我还不太懂.所以就没有用这个方法. 我用的是方法一.因为方法一可以自己选择gcc版本,并不是所有的东西都要更新到最新的版本,当然这个根据你们自己了.根据情况而定. 方法二更简单一点. 好了今天就先到这了.","tags":[{"name":"gcc","slug":"gcc","permalink":"https://leng521.top/tags/gcc/"}]},{"title":"9宫格纹理的更新问题","date":"2018-04-26T01:40:53.000Z","path":"/posts/1e09c0f5/","text":"这一篇文章主要是讲解一下 cocos2dx 9宫格纹理更新问题我这里就不说 cocos2dx 9宫格怎么使用了。在网上一搜一大堆。基本内容都是那样。我不想做无谓的叙述了。 问题描述现在的环境是： cocos2dx 3.15 VS 2015 使用 lua 写项目 注意这里是说使用 plist 里面的纹理 也就是精灵帧 现在面临的问题是: cocos2dx 对9宫格纹理更新，不能像更新精灵那样使用它提供的函数 setSpriteFrame虽然9宫格就是对精灵的在次封装。 cocos2dx 九宫格的这个函数（setSpriteFrame）在C++定义的头文件中是长这样的 123// UIScale9Sprite.hvirtual void setSpriteFrame(SpriteFrame * spriteFrame, const Rect&amp; capInsets);//它没有提供直接输入字符串来实现纹理的更换. 这说明我们需要一个精灵帧类型，但是这个类型我用了这么时间，基本没用过。 问题剖析我上面有说过九宫格是对纹理的再次封装实现的，说以就去查看他的父类Sprite.h这个是怎么初始化的。 追了 它父类的初始化函数 Sprite.h 看到了它是怎么创建出精灵帧的，下面是他初始化它内部的精灵帧的操作。12345678910111213141516void Sprite::setSpriteFrame(const std::string &amp;spriteFrameName)&#123; CCASSERT(!spriteFrameName.empty(), \"spriteFrameName must not be empty\"); if (spriteFrameName.empty()) &#123; return; &#125; SpriteFrameCache *cache = SpriteFrameCache::getInstance(); // 根据名字在精灵帧缓存中查找相应的精灵帧。 SpriteFrame *spriteFrame = cache-&gt;getSpriteFrameByName(spriteFrameName); CCASSERT(spriteFrame, std::string(\"Invalid spriteFrameName :\").append(spriteFrameName).c_str()); // 设置自己内部的精灵帧对象 setSpriteFrame(spriteFrame);&#125; 原理是在精灵帧缓存中查找对象设置精灵的精灵帧 代码实现这下就好办了。 lua层的代码就是 12345local spriteFrameCache = cc.SpriteFrameCache:getInstance()local frame = spriteFrameCache:getSpriteFrame(\"xxx.png\")-- xxx.png 就是你 plist文件中对应的文件名字。-- 这个就是我们需要的精灵帧对象-- 然后在调用它的 setSpriteFrame 具体的实现代码lua层的c++层我就不说了。暂时没有用到。做法都一样。上面的实现在 cocos2dx display的lua文件里面有实现。所以就直接调用。1234567891011121314151617181920212223242526-- desc: 创建9宫格图片-- params [ path | pos | capInsets | size | rect ]-- params.path 可以是精灵帧 ej: params.path = \"#xxx.png\"-- params.pos 精灵的位置-- params.capInsets 是9宫格中间 Rect 的位置和大小-- params.rect 可以不用填function T.cp_s9( parentNode, params ) local pos = params.pos local s = display.newSprite(params.path,pos.x,pos.y,params) local _ = parentNode and parentNode:addChild(s) return send-- desc: 9宫格图片纹理的更新-- path 无效添加报错机制function T.update_s9( node, path, capInsets, size ) if string.byte(path) == 35 then local sp = display.newSpriteFrame(path) node:setSpriteFrame(sp,capInsets) else if not cc.FileUtils:getInstance():isFileExist(path) then error(string.format(\"invalid path , file isn't exist , path - %s\",path)) end node:setTexture(path) end node:setContentSize(size)end 需要注意的一点就是在九宫格更新纹理后尺寸又变回原来的大小，你需要重新设置大小。","tags":[{"name":"cocos2dx","slug":"cocos2dx","permalink":"https://leng521.top/tags/cocos2dx/"},{"name":"9宫格","slug":"9宫格","permalink":"https://leng521.top/tags/9宫格/"}]},{"title":"python-闭包问题","date":"2018-04-20T02:31:51.000Z","path":"/posts/87435431/","text":"本文主要是python闭包问题的记录。python 实现的有内部函数，那么自然就会使用内部函数外面的变量 。 注意这里是要改变局部变量 可以使用下面的策略，如果只是简单的引用，可以直接引用 不用使用 nonlocal 关键字 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-def A(): xxx = 0 def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment nonlocal xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3 这里主要是使用了python 内部的关键字 nonlocal主要是引用内部函数以外的局部变量 注意这里不是全局变量。 注意这个关键字是python3.x 中可以出现的关键字。在python2.x中会报错。在python2.x的版本中可以使用 list 封装一层，实现使用内部函数以外的局部变量。这里不能使用 元祖 因为元祖的变量时不可变的。 如果要引用全局变量要是用python的另外一个关键字 global。用法和上面相同。 使用例子如下： 123456789101112131415#!/usr/bin/env python3# -*- coding: utf-8 -*-xxx = 0def A(): def B(): #这个时候你可能会使用xxx变量。 直接引用是会报错的 #告诉你使用了没有分配的引用 referenced before assignment global xxx xxx += 1 return xxx return Bf = A()print(f(),f(),f())# 输出 1 2 3","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"https://leng521.top/tags/闭包/"}]},{"title":"记录使用hexo写博客的问题","date":"2018-04-14T08:17:16.000Z","path":"/posts/a9ff66a6/","text":"在使用 hexo 总会遇到这种那种的错误我这里就记录一下,希望后面使用 hexo 写博客的人能少遇到一点麻烦，少走一点弯路，OK，废话不多说。 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false. 2. hexo skip_render 的使用123skip_render: - 'dir/**' # 忽略dir这目录下的所有文件，不进行渲染 - 'xx/**' # 道理同上。 3. 修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 `hexo clean`,每次记得使用这个命令清除一下","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"}]},{"title":"python_optionparser模块","date":"2018-04-11T08:01:20.000Z","path":"/posts/ce1d3b12/","text":"本文主要是 python 对命令行的处理模块 就象是这样的","tags":[{"name":"python","slug":"python","permalink":"https://leng521.top/tags/python/"},{"name":"optionParser","slug":"optionParser","permalink":"https://leng521.top/tags/optionParser/"}]},{"title":"git命令的记录","date":"2018-03-07T03:00:24.000Z","path":"/posts/82a402af/","text":"现在对git也使用快一年了现在总结一下常用的一些命令。 本文的大纲对以下命令做一些记录1.git clone2.git pull3.git commit4.git push5.git branch6.git remote7.git checkout8.git reset9.git stash10.git配置一些外部工具11.git merge12.git log13.git show git clonegit clone 是克隆别的仓库 1234git clone &lt;repo&gt; &lt;directory&gt;参数说明： repo:Git 仓库 directory:本地目录 ej:比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： git clone git://github.com/schacon/grit.git 或者是这样的 git clone git://github.com/schacon/grit.git test 这个就会克隆到 ../test 和目录 git pull拉取别人在远程仓库更新的内容 默认是远程的 origin 分支 git add将本地的改变提交到缓存区 git add -u 是将本地追踪的文件提交到缓存区 123ej:git add -u *.png--添加所有追踪的文件提交到缓存区 前提是以.png 为结尾的文件 git add -A 是将本地未追踪的文件提交到缓存区 123ej:git add -A .--添加所有的未追踪的文件提交到缓存区 git commit 将本地的改变提交到缓存区的内容到本地版本库 123ej:git commit -m &quot;test&quot;-- -m 是对此次的提交内容的描述(desc) git push 将本地的改变提交到本地版本库的内容推送到远程版本库 123ej:git push-- 默认是主为分支(origin) git push 将本地分支推送到云端 1git push origin/远程分支的名字 本地分支的名字 git branch 有关分支的一些使用 git branch 查看本地分支 git branch -vv 查看本地分支 与 远程分支的映射关系 git branch -a 查看 本地和远程分支 git branch -r 查看远程分支 git branch xx 创建新的xx分支 git branch -D xx 删除xx分支 git branch upstream(git 分支的映射关系)建立本地分支与远程分支的映射关系（或者为跟踪关系track）。这样使用`git pull`或者`git push`时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。 ej:从这上面可以看到本地分支与远程分支的映射关系若没有映射关系 git pull 或是 git push 会失败 与远程分支建立映射关系 使用 git branch -u origin/xx 与远程分支 建立 映射关系xx 为 远程分支的名字 与远程分支取消映射关系使用 git branch --unset-upstream 补充：不同名字客之间也是可以建立映射关系的 删除远程的分支12git push origin --delete xxx-- xxx 为远程分支的名字 git fetch 来一个关系式 git pull = git fecth + git merge拉取别人远程仓库的内容到自己本地的一个分支上 1234ej: git fecth origin test:temp -- 拉取远程分支 test 到 本地 temp 分支上 -- 注意这种拉取 本地分支和远程分支 是没有映射关系的 git remotegit remote and git remote -v git remote用来管理本地工作目录对应的远程代码仓库，在一般的工作目录下，执行git remote结果如下： git remote add 我们可以使用git remote add命令来增加一个远程仓库，这个远程仓库可以是ssh地址（如上面这种），可以是本地目录，也可以是git协议或者http协议的地址。 例如，我要把liming的仓库作为我的远程仓库之一，可以执行git remote add 来增加仓库，例如： 123456789$ git remote add liming /home/liming/repo$ git remotelimingorigin$ git remote -vliming /home/liming/repo (fetch)liming /home/liming/repo (push)origin git@remoteRepo (fetch)origin git@remoteRepo (push) 相应的，可以使用git remote rm或者git remote rename对远程代码仓库的名称进行修改（本地的，不会影响到对方的目录） git checkout作用： 1.切换分支 2.放弃对某个文件的修改 3.创建新的分支 git checkout xx 切换到xx分支 git checkout -b xx 在没有的时候 创建的新的分支xx 并跳转到 xx 分支上 git checkout xx.ext 放弃修改直接还原和版本库保持一致 拉取远程方法123git checkout -b 本地分支名x origin/远程分支名xNote:使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 git reset作用： 1.文件从暂存区回退到工作区 2.版本回退 作用1： git reset HEAD filename(xx)作用2: 我就直接转载一篇文章写的挺好的 git reset的使用 git 中文的教程 –貌似要科学上网 git stash你当前正在开发的分支上面，还有未提交的代码，你又不想把代码提交了，怎么办呢？作用： 将本地的改变存储起来，切换到另外的分支上。 1234git stash-- 将本地的改变存储起来git stash list-- 查看本地存储的列表 如何恢复工作现场呢？ 第一种方案，用`git stash apply`恢复，但是恢复后，stash内容不删除，需要用`git stash drop`来删除 第二种方案，用`git stash pop`,恢复的同时把stash内容也删除了。 git配置一些外部工具配置代码对比工具我配置了一个叫diffuse的工具 我这里给你提供一个下载地址，当然你也可以自己去下载别的 download diffuse 1.git查看有哪些对比工具可以设置命令： 1git difftool --tool-help 2.然后再设置对比工具，如： 12git config --global diff.tool diffusegit config --global difftool.diffuse.path &quot;E:\\Program Files (x86)\\Diffuse\\diffuse.exe&quot; 3.设置好后，使用命令是 git difftool 而不是之前的 git diff 了 git ProblemProblem : 1.为什么在切换分支的时,会出现有时要你提交本地的改变才可以切换，有的时候却不需要？ 出现融合的时候是你当前分支改变的内容与你将要切换分支的内容有冲突，这个时候不知要你融合。 1234解决的方法有我种： 1.使用 git stash 保存当前的改变 git stash 的用法在上面 2.使用 git merge 融合要切换的分支到当前的分支 3.使用 git checkout 还原当前冲突的文件 git merge– 2018年3月20日14:36:34git 融合：是融合你当前版本库没有的东西。你可以选择本地的分支也可以是远程的分支 123456-- 融合远程分支ej: git merge origin/分支的名字-- 融合本地分支ej: git merge 分支的名字 git 更高级的用法问题: 在你的使用 git merge 的时候也会出现冲突. git merge –abort选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好 git status -sb罗列出需要解决冲突的文件. 在你合并的时候 你可以将远端共同祖先的文件, 自己本地的文件, 要融合分支的文件,都下载到本地, 123git show :1:hello.rb &gt; hello.common.rbgit show :2:hello.rb &gt; hello.ours.rbgit show :3:hello.rb &gt; hello.theirs.rb git clean -f在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。就是通过上面的命令 git show :1 … 这个命令产出的文件. git log这里在更新一下 git log 的一些命令的使用 git log -n罗列出最近 n 次提交 ej: git log -3 // 罗列出最近三次的提交信息 git show显示一些提交的状态信息 git show –stat [commitId] ej: git show –stat 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42它会罗列出当前这次提交的信息,以文件更改列表的形式显示,如下图 git show [commitId]这个命令和上个命令很相似 , 只是去掉一个 –stat ej git show 96daa2f6bb9b413ae3ce5a1ccf3f58ee22b32b42 src/a.lua显示这次这个文件提交的内容","tags":[{"name":"git命令","slug":"git命令","permalink":"https://leng521.top/tags/git命令/"}]},{"title":"优化cocos2dxSpine库","date":"2018-01-22T12:44:31.000Z","path":"/posts/c4c0a180/","text":"对cocos2dxSpine库的升级和优化本文的大纲1.升级spine在cocos2dx-3.15的运行时库2.优化spine在创建的时候效率 在开发的时候出现的问题1.spine这个软件导出3.6新加的特效在cocos2dx3.15 不能使用2.spine在批量创建的时候帧数会下降 升级spine -&gt;3.6spine code github 地址去这个地址clone或者是下载Zip这个你随便然后会产现这个目录主要就是我使用箭头标记的这两个目录 spine-c/spine-c/include/spine/*.h spine-c/spine-c/src/spine/*.c spine-cocos2dx/src/spine/*.cpp and spine-cocos2dx/src/spine/*.h 找到自己的工程的根目录 然后去找这个目录全部放在 ···/frameworks/cocos2d-x/cocos/editor-support/spine 直接全部替换然后打开自己的VS去编译记住一点将你添加的C或C++的文件给添加到libSpine的工程中的源文件中 选中 Source Files 执行 Shift + Alt + A 添加现有项 或者是鼠标右键添加好可以 然后编译,你会惊奇的发现编译成功了,但是不要高兴的太早了,因为这个在编译Android的时候会报错,当然原因也很简单，接着往下面看。 在Android中的实现你找到 这个目录里面会有 ···/frameworks/cocos2d-x/cocos/editor-support/spineAndroid.mk的文件将你添加的写在这个配置里面 注意只写 *.h 的文件然后使用 Android Studio 编译 Apk, 这里你也可以使用NDK编译,但是在Android2.？这个不记得了,就已经不在支持NDK编译了所以还是使用Android Studio 吧 在 ios 中的实现也是同样如此，这里就不再讲述了 优化spine在创建的时候效率在原先的 spine 创建的时候每次都需要解析数据,生成骷髅数据,其实这个是很消耗CPU的,导致FPS下降。我的做法是保留 spine create 的原有接口,自己再从新写一个新的接口。原理：创建字典保留骷髅数据每次创建的时候询问这个 Map 是否存在 key 没有创建,有直接使用。 代码的写法有很多种,我这只是参考 在SkeletonAnimation.cpp 中添加如下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798SkeletonAnimation* SkeletonAnimation::createFromCache(const std::string&amp; key_skeletonData)&#123; if (spSkeletonData* skeleton_data = SkeletonAnimation::getSkeletonDataFromCache(key_skeletonData)) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; else &#123; skeleton_data = SkeletonAnimation::loadSkeletonDataToCache(key_skeletonData, key_skeletonData + \".json\", key_skeletonData + \".atlas\"); if (skeleton_data) &#123; return SkeletonAnimation::createWithData(skeleton_data, false); &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it == _allSkeletonDataCache.end()) &#123; SkeletonDataInCache skeleton_data_in_cache; spAtlas* atlas = nullptr; spAttachmentLoader* attachmentLoader = nullptr; skeleton_data_in_cache._skeleton_data = nullptr; atlas = spAtlas_createFromFile(atlasFile.c_str(), 0); CCASSERT(atlas, \"loadSkeletonDataToCache Error atlas file.\"); attachmentLoader = SUPER(Cocos2dAttachmentLoader_create(atlas)); spSkeletonJson* json = spSkeletonJson_createWithLoader(attachmentLoader); json-&gt;scale = scale; skeleton_data_in_cache._skeleton_data = spSkeletonJson_readSkeletonDataFile(json, skeletonJsonFile.c_str()); CCASSERT(skeleton_data_in_cache._skeleton_data, json-&gt;error ? json-&gt;error : \"loadSkeletonDataToCache Error reading skeleton data file.\"); spSkeletonJson_dispose(json); spAtlas_dispose(atlas); if (skeleton_data_in_cache._skeleton_data) &#123; _allSkeletonDataCache[key_skeletonData] = skeleton_data_in_cache; return skeleton_data_in_cache._skeleton_data; &#125; else &#123; //error release if (skeleton_data_in_cache._skeleton_data) &#123; spSkeletonData_dispose(skeleton_data_in_cache._skeleton_data); &#125; &#125; &#125; return nullptr;&#125;spSkeletonData* SkeletonAnimation::getSkeletonDataFromCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return it-&gt;second._skeleton_data; &#125; return nullptr;&#125;bool SkeletonAnimation::removeSkeletonData(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); _allSkeletonDataCache.erase(it); return true; &#125; return false;&#125;void SkeletonAnimation::removeAllSkeletonData()&#123; for (iteratorSkeletonData it = _allSkeletonDataCache.begin(); it != _allSkeletonDataCache.end(); ++it) &#123; if (it-&gt;second._skeleton_data) spSkeletonData_dispose(it-&gt;second._skeleton_data); &#125; _allSkeletonDataCache.clear();&#125;bool SkeletonAnimation::isExistSkeletonDataInCache(const std::string&amp; key_skeletonData)&#123; iteratorSkeletonData it = _allSkeletonDataCache.find(key_skeletonData); if (it != _allSkeletonDataCache.end()) &#123; return true; &#125; return false;&#125;//endstd::map&lt;std::string, SkeletonAnimation::SkeletonDataInCache&gt; SkeletonAnimation::_allSkeletonDataCache; 在 SkeletonAnimation.h 中添加如下代码1234567891011121314static SkeletonAnimation* createFromCache(const std::string&amp; key_skeletonData);static spSkeletonData* loadSkeletonDataToCache(const std::string&amp; key_skeletonData, const std::string&amp; skeletonJsonFile, const std::string&amp; atlasFile, float scale = 1);static spSkeletonData* getSkeletonDataFromCache(const std::string&amp; key_skeletonData);static bool removeSkeletonData(const std::string&amp; key_skeletonData);static void removeAllSkeletonData();static bool isExistSkeletonDataInCache(const std::string&amp; skeletonDataKeyName);private: struct SkeletonDataInCache &#123; spSkeletonData* _skeleton_data; &#125;; typedef std::map&lt;std::string, SkeletonDataInCache&gt;::iterator iteratorSkeletonData; static std::map&lt;std::string, SkeletonDataInCache&gt; _allSkeletonDataCache; //end Binding to lua既然写了这么多了,就要将这些代码绑定到lua中去 找到自己工程的的libluacocos2d的工程这里你可以自己写代码在 lua_cocos2dx_spine_auto.cpp 中,但是这不是一个程序员应该做的。第二种做是:既然它的文件名有 auto 这个单词,一看就不是人写出来的,OK,去寻找答案。 到这个目录中去 ···/frameworks/cocos2d-x/tools/tolua/ 你会发现有一个genbindings.py的文件你一运行可能报错,你去读他的 README.md ,发现他要你装一些python的库,那就按照说的安装吧你可以 pip 命令也可以 自己下载zip 这个随意。然后就是配置NDK,这个下载解压,配置 path 就完了,我就不多说了。 然后你运行可能还会报错 那就打开 genbindings.py 你会发现他需要的是NDK 3.3-3.4 然而自己的NDK经过查看 是 3.5-3.6 没关系,把它这个所有相关 3.3 3.4 全部改成 3.5-3.6的就OK了。 改完后运行 Prefect ^-^. 在lua中调用123456sp.SkeletonAnimation: createFromCache(key)sp.SkeletonAnimation: isExistSkeletonDataInCache(key)sp.SkeletonAnimation: loadSkeletonDataToCache(key,jsonFilePath,atlasFilePath,scale =1) sp.SkeletonAnimation: getSkeletonDataFromCache(key)sp.SkeletonAnimation: removeSkeletonData(key)sp.SkeletonAnimation: removeAllSkeletonData() 这里面有一个问题是你会发现返回的骨胳数据拿不到,这个是cocos2dx在绑定的时候并没有将这个数据类型绑定lua去,我上面那么写就是为了以后留个接口,当然你也可以自己把那个返回值去掉。 好了今天就到这吧。","tags":[{"name":"spine","slug":"spine","permalink":"https://leng521.top/tags/spine/"}]},{"title":"Using-Hexo","date":"2018-01-17T12:07:49.000Z","path":"/posts/6743743b/","text":"这篇文章只是我对 hexo 的一些功能的测试吧，可能后会常用到这些东西 Requirementsinstall Hexo123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David Levithan-Wide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 12alert(&apos;Hello World!&apos;);print(&apos;Hello World!&apos;) language -&gt; OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; language -&gt; python1print('Hello World!') 附加说明Array.map1array.map(callback[, thisArg]) 附加说明和网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块[language] [title] [url] [link text] code snippet language - &gt;OC1[rectangle setX: 10 y: 10 width: 20 height: 20]; 插入Image图片12&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;&#123;% asset_img fileName.* title&#125; /posts/6743743b/test.lua test.lua 引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 使用iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://leng521.top/tags/hexo/"},{"name":"IT","slug":"IT","permalink":"https://leng521.top/tags/IT/"}]},{"title":"Hello World","date":"2018-01-16T16:00:00.000Z","path":"/posts/4a17b156/","text":"搭建自己的博客在github page经过2天的折腾的终于把自己的博客给搭建出来了,也可以说是自己的一个Hello World 吧这个主题是使用Litten的theme通过hexo搭建 准备环境* install git * install node * 注册github的账号 Git Downloadnodejs Downloadgithub 注册的地址 再创建之前思考一个事情就是在你做完这些之后，你开始写自己的博客的时候，突然之间要换电脑了，这个时候你要怎么办这个思考是对于那些使用过 github 或者是使用过别的版本控制的工具。 Build to blog安装 nodejs 很简单,就是傻瓜式的安装。 在安装 git 的时候也是一键式安装。 然后自己注册github的账号。 记得配置自己的 nodejs的Path 在 cmd 窗口 输入 path path 我自己的 nodejs 在E盘 同样看看自己的 git 的 path 有没有配置 然后就是验证你的安装是否正确打开你 cmd 输入 git git 输入 node -v node -v github 就不用验证了吧 然后就是利用 node 的 npm 工具去安装 hexo 输入 npm install -g hexo-cli 如果自己的 hexo 安装成功的话 在 cmd 中 输入 hexo -v hexo -v 创建自己的 hexo 工程假设自己的 hexo 的工程目录是在 D:\\Pro\\pro_wdh\\nodejs 1. 在 cmd 中 输入 pushd D:\\Pro\\pro_wdh\\nodejs 2. cmd的当前目录直接跳转到 D:\\Pro\\pro_wdh\\nodejs 3. 使用 hexo init 命令 初始化 （）hexo init [folderName] ） hexo init hexocd hexonmp install 完成之后目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 运行自己的hexo工程在 cmd 中 输入 hexo s 在自己的浏览器中打开 http://localhost:4000/. 这时你会看到自己的静态网页 更多的 hexo的命令hexo 的官网 部署自己的笔记2github网上的一些教程都是 使用 SSH 去上传自己的博客但是使用 htpp 的方式也同样可以 上传 创建自己的 github 的仓库 上面的仓库名字就和你 github 的名字一样就行了 然后就是在 hexo 的根目录下的 _config.yml 中 找到 按照图片上的配置自己的 github 仓库的地址github 仓库的地址在这里拿 然后执行 hexo的命令 在cmd中输入 1.hexo clean 2.hexo g 3.hexo d 静静的等待 上传完成之后 打开 http://Test.github.io 就可以看到自己的博客了 回答上面的提出的思考答案就是 在 github 上创建自己的 branch(分支) 我是在自己的 github 创建自己的 blog(分支) git 的一些命令 不是太全,但是应对日常还是可以的 做法如下： git chcekout -b blog git add -A git commit - m &quot;commit my blog&quot; git push origin blog 解释一下吧 创建新的分支 blog添加自己的文件到缓存区提交到本地版本库推送到远端 更多 git 的知识 这只是一些基础 更多需要你多去尝试,多自己动手。 有疑问可以加QQ一起讨论","tags":[{"name":"hello world","slug":"hello-world","permalink":"https://leng521.top/tags/hello-world/"},{"name":"github page","slug":"github-page","permalink":"https://leng521.top/tags/github-page/"},{"name":"博客","slug":"博客","permalink":"https://leng521.top/tags/博客/"}]}]